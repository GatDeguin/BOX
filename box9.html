<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOX 9 - Travelling ringside</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #020203;
            font-family: "Inter", system-ui, -apple-system, sans-serif;
        }
        #overlay {
            position: absolute;
            top: 24px;
            width: 100%;
            text-align: center;
            color: #dfe6ff;
            pointer-events: none;
            letter-spacing: 0.18em;
            text-shadow: 0 6px 24px rgba(0,0,0,0.8);
        }
        #overlay .badge {
            display: inline-flex;
            padding: 12px 24px;
            border-radius: 999px;
            background: rgba(12, 16, 26, 0.65);
            border: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(14px);
            box-shadow: 0 15px 45px rgba(0,0,0,0.6);
        }
        #info-layer {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            pointer-events: auto;
            z-index: 20;
            transition: opacity 0.6s ease, filter 0.6s ease;
        }
        #info-layer.fade-out {
            opacity: 0;
            filter: blur(12px);
            pointer-events: none;
        }
        #info {
            text-align: center;
            color: #eaf1ff;
            font-family: "Inter", system-ui, -apple-system, sans-serif;
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0,0,0,0.9);
            z-index: 10;
        }
        #info .instruction {
            background: radial-gradient(circle at top, rgba(200,200,220,0.1), rgba(5,5,8,0.9));
            padding: 18px 40px 24px;
            border-radius: 6px;
            border-bottom: 2px solid rgba(255, 100, 50, 0.4);
            display: inline-flex;
            flex-direction: column;
            gap: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 12px 42px rgba(0,0,0,0.8);
        }
        .pill-btn {
            pointer-events: auto;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 10px 18px;
            min-width: 88px;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #f6f7ff;
            background: rgba(0,0,0,0.72);
            border: 1px solid rgba(255,255,255,0.32);
            border-radius: 999px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.55);
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        }
        .pill-btn:hover {
            transform: translateY(-1px) scale(1.02);
            background: rgba(10,12,18,0.9);
            box-shadow: 0 12px 36px rgba(0,0,0,0.65);
        }
        .pill-btn:active {
            transform: translateY(0);
            box-shadow: 0 8px 24px rgba(0,0,0,0.55);
        }
        .cta-row {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        #modal-layer {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at 50% 30%, rgba(6,10,16,0.8), rgba(3,4,7,0.9));
            backdrop-filter: blur(8px);
            z-index: 18;
        }

        #modal-layer.active {
            display: flex;
        }

        .modal-card {
            width: min(480px, 92vw);
            color: #dfe6ff;
            background: linear-gradient(145deg, rgba(8,10,18,0.92), rgba(10,12,24,0.95));
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 16px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.65);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .modal-title {
            letter-spacing: 0.16em;
            text-transform: uppercase;
            font-weight: 800;
            font-size: 14px;
            color: #9fb3ff;
        }

        .modal-close {
            cursor: pointer;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.18);
            color: #eaf1ff;
            border-radius: 10px;
            padding: 6px 12px;
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .option-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px;
            border-radius: 12px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.05);
        }

        .option-row label {
            display: flex;
            flex-direction: column;
            gap: 4px;
            letter-spacing: 0.03em;
        }

        .option-row span {
            opacity: 0.7;
            font-size: 12px;
        }

        .option-toggle {
            width: 48px;
            height: 26px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.18);
            background: rgba(255,255,255,0.12);
            position: relative;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .option-row label input { display: none; }

        .option-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 3px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0b0d16;
            box-shadow: 0 6px 16px rgba(0,0,0,0.65);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .option-row label input:checked + .option-toggle {
            background: linear-gradient(135deg, rgba(109,224,255,0.35), rgba(141,157,255,0.35));
        }

        .option-row label input:checked + .option-toggle::after {
            transform: translateX(20px);
            background: linear-gradient(135deg, #6de0ff, #8d9dff);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #character-ui {
            position: absolute;
            bottom: 22px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            align-items: center;
            color: #dfe6ff;
            font-size: 13px;
            letter-spacing: 0.04em;
            text-shadow: 0 4px 16px rgba(0,0,0,0.7);
            pointer-events: none;
            z-index: 12;
        }

        .chip {
            background: rgba(10, 12, 18, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 999px;
            padding: 10px 16px;
            display: inline-flex;
            gap: 8px;
            align-items: center;
            box-shadow: 0 12px 34px rgba(0, 0, 0, 0.55);
        }

        .chip .label {
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.18em;
            color: #9fb3ff;
        }

        .chip .value {
            font-weight: 700;
            color: #f7fbff;
        }

        .chip.speed span {
            display: inline-block;
            width: 8px;
            height: 14px;
            margin-left: 4px;
            border-radius: 3px;
            background: linear-gradient(180deg, #73f2ff 0%, #5a7bff 100%);
            opacity: 0.28;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
        }

        .chip.speed span.active {
            opacity: 1;
            box-shadow: 0 0 12px rgba(92, 153, 255, 0.8);
        }

        #selection-helper {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 18px;
            border-radius: 10px;
            background: rgba(9, 10, 15, 0.72);
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: 0 12px 32px rgba(0,0,0,0.6);
            color: #cbd5ff;
            letter-spacing: 0.08em;
            font-size: 12px;
            text-transform: uppercase;
            pointer-events: none;
            z-index: 12;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <div class="badge">Travelling + DOF + Godrays</div>
    </div>

    <div id="info-layer">
        <div id="info">
            <div class="instruction">
                <div style="font-size:11px; letter-spacing:0.34em; opacity:0.8; text-transform:uppercase; color:#cbd5ff;">Box 9 • Travelling Ringside</div>
                <h1 style="font-size:26px; font-weight:900; letter-spacing:0.18em; text-transform:uppercase;">Entra al Ring</h1>
                <p style="font-size:13px; letter-spacing:0.12em; color:#cbd5ff; text-transform:uppercase; margin: 0;">Pulsa para iniciar • Godrays • Depth of Field</p>
                <div class="cta-row">
                    <button class="pill-btn" id="startBtn">Jugar</button>
                    <button class="pill-btn" id="optionsBtn">Opciones</button>
                    <button class="pill-btn" id="creditsBtn">Créditos</button>
                </div>
            </div>
        </div>
    </div>

    <div id="modal-layer">
        <div class="modal-card" id="modal-card" role="dialog" aria-modal="true" aria-labelledby="modal-title">
            <div class="modal-header">
                <div class="modal-title" id="modal-title">Opciones rápidas</div>
                <button class="modal-close" id="closeModalBtn">Cerrar</button>
            </div>
            <div class="option-row">
                <label for="skipIntro">
                    Saltar introducción
                    <span>Entra directo a la selección sin travelling.</span>
                </label>
                <label>
                    <input type="checkbox" id="skipIntro" hidden>
                    <span class="option-toggle"></span>
                </label>
            </div>
            <div class="option-row">
                <label for="freeCam">
                    Cámara libre
                    <span>Deja los controles activos tras elegir luchador.</span>
                </label>
                <label>
                    <input type="checkbox" id="freeCam" hidden>
                    <span class="option-toggle"></span>
                </label>
            </div>
            <div class="option-row">
                <label>
                    Créditos
                    <span>Modelos FBX y GLB desde los assets locales del proyecto.</span>
                </label>
                <div style="font-size:12px; opacity:0.75; letter-spacing:0.05em;">Ring 3.glb • Tyson/Boxing/Cyber FBX</div>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div id="selection-helper" style="display:none;">Navega con ←/→ o mando • Enter para elegir</div>
    <div id="character-ui" style="display:none;">
        <div class="chip" id="chip-name"><span class="label">Nombre</span><span class="value">---</span></div>
        <div class="chip" id="chip-weight"><span class="label">Peso</span><span class="value">---</span></div>
        <div class="chip" id="chip-reach"><span class="label">Alcance</span><span class="value">---</span></div>
        <div class="chip speed" id="chip-speed"><span class="label">Velocidad</span><span class="value">---</span></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const container = document.getElementById('canvas-container');
        const infoLayer = document.getElementById('info-layer');
        const startBtn = document.getElementById('startBtn');
        const optionsBtn = document.getElementById('optionsBtn');
        const creditsBtn = document.getElementById('creditsBtn');
        const modalLayer = document.getElementById('modal-layer');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const skipIntroToggle = document.getElementById('skipIntro');
        const freeCamToggle = document.getElementById('freeCam');
        const selectionHelper = document.getElementById('selection-helper');
        const characterUi = document.getElementById('character-ui');
        const chipName = document.getElementById('chip-name').querySelector('.value');
        const chipWeight = document.getElementById('chip-weight').querySelector('.value');
        const chipReach = document.getElementById('chip-reach').querySelector('.value');
        const chipSpeed = document.getElementById('chip-speed');

        container.style.pointerEvents = 'none';

        const fadeOutOverlay = (callback) => {
            if (infoLayer.classList.contains('fade-out')) return;
            infoLayer.classList.add('fade-out');
            setTimeout(() => {
                infoLayer.style.display = 'none';
                container.style.pointerEvents = 'auto';
                if (typeof callback === 'function') callback();
            }, 650);
        };

        let skipIntro = false;
        let freeCameraMode = false;

        const openModal = () => modalLayer.classList.add('active');
        const closeModal = () => modalLayer.classList.remove('active');

        function startExperience(){
            fadeOutOverlay(() => {
                if(skipIntro){
                    travelTime = travelDuration;
                    applyLighting(1);
                    updateFog(travelTime, 1);
                    updateCamera(1);
                    gameState = 'selecting';
                    startSelectionMode();
                }
            });
        }

        infoLayer.addEventListener('click', startExperience);
        startBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            startExperience();
        });
        optionsBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            openModal();
        });
        creditsBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            openModal();
        });
        closeModalBtn.addEventListener('click', closeModal);
        modalLayer.addEventListener('click', (event) => {
            if(event.target === modalLayer){
                closeModal();
            }
        });

        skipIntroToggle.addEventListener('change', (event) => {
            skipIntro = event.target.checked;
        });

        freeCamToggle.addEventListener('change', (event) => {
            freeCameraMode = event.target.checked;
        });

        // ------ ESCENA BÁSICA ------
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020203);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 120);
        camera.position.set(-9, 2.5, 8.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.8));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.enabled = false;
        controls.minDistance = 4;
        controls.maxDistance = 10;
        controls.maxPolarAngle = Math.PI / 1.8;

        // POSTPROCESADO
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        const bokehPass = new BokehPass(scene, camera, {
            focus: 4.2,
            aperture: 0.00045,
            maxblur: 0.015,
            width: window.innerWidth,
            height: window.innerHeight,
        });
        const outputPass = new OutputPass();
        composer.addPass(renderPass);
        composer.addPass(bokehPass);
        composer.addPass(outputPass);

        // ------ LUCES Y PRESETS ------
        const lightingPresets = {
            night: {
                ambient: { color: 0x0c0f1a, intensity: 0.65 },
                key: { color: 0xffb377, intensity: 7.2 },
                fill: { color: 0x4b6cff, intensity: 0.8 },
                rim: { color: 0x5ea0ff, intensity: 1.3 },
                ring: { color: 0xfff0c2, intensity: 1.1 },
                fogColor: 0x020203,
                fogDensity: 0.055,
                volumetricHue: 0.1,
                background: 0x020203,
            },
            sunset: {
                ambient: { color: 0x2f1a10, intensity: 0.85 },
                key: { color: 0xffc58f, intensity: 8.4 },
                fill: { color: 0x9dc3ff, intensity: 0.55 },
                rim: { color: 0xff8a55, intensity: 1.2 },
                ring: { color: 0xffe8ba, intensity: 1.0 },
                fogColor: 0x1b0f08,
                fogDensity: 0.032,
                volumetricHue: 0.07,
                background: 0x1b0f08,
            },
        };

        const ambientLight = new THREE.HemisphereLight(0x0c0f1a, 0x050505, 0.8);
        const keyLight = new THREE.SpotLight(0xffb377, 7.2, 45, Math.PI / 5, 0.42, 1.5);
        keyLight.position.set(-5, 6, 6);
        const fillLight = new THREE.SpotLight(0x4b6cff, 0.8, 45, Math.PI / 4, 0.65, 1.4);
        fillLight.position.set(5, 5, 8);
        const rimLight = new THREE.DirectionalLight(0x5ea0ff, 1.3);
        rimLight.position.set(0, 6, -6);
        const ringLight = new THREE.PointLight(0xfff0c2, 1.1, 20, 1.3);
        ringLight.position.set(0, 3.6, 3.2);

        scene.add(ambientLight, keyLight, keyLight.target, fillLight, fillLight.target, rimLight, ringLight);
        keyLight.target.position.set(0, 1.4, 0);
        fillLight.target.position.set(0, 1.0, 0.5);

        // Fog inicial
        scene.fog = new THREE.FogExp2(lightingPresets.night.fogColor, lightingPresets.night.fogDensity);

        // ------ RING DESDE EL REPO ------
        const gltfLoader = new GLTFLoader();
        const ringGroup = new THREE.Group();
        scene.add(ringGroup);

        const assetBaseUrl = new URL('./', import.meta.url);
        const resolveAsset = (name) => new URL(name, assetBaseUrl).href;

        gltfLoader.load(
            resolveAsset('modelos/Ring 3.glb'),
            (gltf) => {
                const ringScene = gltf.scene;
                ringScene.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                const bbox = new THREE.Box3().setFromObject(ringScene);
                const ringFloorOffset = -bbox.min.y;
                ringScene.position.set(0, ringFloorOffset, 0);
                ringGroup.add(ringScene);

                const center = new THREE.Vector3();
                bbox.getCenter(center);
                ringLight.position.set(center.x, 3.6, center.z + 0.2);
                selectionStage.position.y = ringFloorOffset + 0.62;
            },
            undefined,
            (error) => console.error('No se pudo cargar el ring:', error)
        );

        // ------ SUBESCENARIO DE SELECCIÓN ------
        const selectionStage = new THREE.Group();
        selectionStage.position.set(0, 0.62, -0.4);

        const podium = new THREE.Mesh(
            new THREE.CylinderGeometry(1.7, 1.7, 0.4, 40, 1, false),
            new THREE.MeshStandardMaterial({ color: 0x0f141f, roughness: 0.45, metalness: 0.15, emissive: 0x0b0f16, emissiveIntensity: 0.2 })
        );
        podium.receiveShadow = true;
        selectionStage.add(podium);

        const podiumRim = new THREE.Mesh(
            new THREE.CylinderGeometry(1.8, 1.8, 0.05, 40, 1, true),
            new THREE.MeshStandardMaterial({ color: 0x202c44, roughness: 0.3, metalness: 0.4, emissive: 0x11265a, emissiveIntensity: 0.35, side: THREE.DoubleSide })
        );
        podiumRim.position.y = 0.22;
        selectionStage.add(podiumRim);

        const stageGrid = new THREE.Mesh(
            new THREE.CircleGeometry(2.8, 48),
            new THREE.MeshBasicMaterial({ color: 0x112033, opacity: 0.2, transparent: true })
        );
        stageGrid.rotation.x = -Math.PI / 2;
        stageGrid.position.y = -0.05;
        selectionStage.add(stageGrid);

        scene.add(selectionStage);

        const characterLoader = new FBXLoader();
        const characterConfigs = [
            { name: 'Tyson', model: 'modelos/Tyson.fbx', idle: 'animaciones/Walking.fbx', jab: 'animaciones/Lead Jab.fbx', weight: '101 kg', reach: '210 cm', speed: 5 },
            { name: 'Rookie', model: 'animaciones/Boxing.fbx', idle: 'animaciones/Walking.fbx', jab: 'animaciones/Lead Jab.fbx', weight: '83 kg', reach: '190 cm', speed: 3 },
            { name: 'Cyber', model: 'modelos/Cyber_boxing.fbx', idle: 'animaciones/Walking.fbx', jab: 'animaciones/Lead Jab.fbx', weight: '95 kg', reach: '202 cm', speed: 4 },
        ];

        const characterSlots = [];
        const mixers = [];
        let selectionActive = false;
        let currentCharacter = 0;
        let selectedCharacter = null;
        let gameState = 'cinematic';
        let lastPadSwap = 0;

        function buildSpeedBars(level){
            const valueEl = chipSpeed.querySelector('.value');
            valueEl.textContent = `Lvl ${level}`;
            chipSpeed.querySelectorAll('.speed-bar').forEach(bar => bar.remove());
            for(let i = 0; i < 5; i++){
                const bar = document.createElement('span');
                bar.classList.add('speed-bar');
                if(i < level){
                    bar.classList.add('active');
                }
                chipSpeed.appendChild(bar);
            }
        }

        function updateCharacterUi(config){
            chipName.textContent = config?.name ?? '---';
            chipWeight.textContent = config?.weight ?? '---';
            chipReach.textContent = config?.reach ?? '---';
            buildSpeedBars(config?.speed ?? 0);
        }

        function setActiveCharacter(index){
            currentCharacter = THREE.MathUtils.euclideanModulo(index, characterConfigs.length);
            characterSlots.forEach((slot, i) => {
                slot.group.visible = i === currentCharacter;
                if(i === currentCharacter && slot.actions.idle){
                    slot.actions.idle.reset().play();
                }
            });
            updateCharacterUi(characterConfigs[currentCharacter]);
        }

        function loadAnimation(slot, path, key){
            characterLoader.load(resolveAsset(path), (animAsset) => {
                if (!animAsset.animations.length) return;
                const clip = animAsset.animations[0];
                const action = slot.mixer.clipAction(clip);
                action.loop = THREE.LoopRepeat;
                action.clampWhenFinished = true;
                if(key === 'idle'){
                    action.play();
                }
                slot.actions[key] = action;
            });
        }

        function loadCharacter(config, index){
            characterLoader.load(resolveAsset(config.model), (model) => {
                model.scale.setScalar(0.007);
                model.position.set(0, 0.28, 0);
                model.traverse((child) => {
                    if(child.isMesh){
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                const holder = new THREE.Group();
                holder.visible = index === 0;
                holder.add(model);
                selectionStage.add(holder);

                const mixer = new THREE.AnimationMixer(model);
                mixers.push(mixer);

                const slot = { group: holder, mixer, actions: {}, config };
                characterSlots[index] = slot;

                loadAnimation(slot, config.idle, 'idle');
                loadAnimation(slot, config.jab, 'jab');

                if(index === 0){
                    updateCharacterUi(config);
                }
            });
        }

        characterConfigs.forEach((cfg, i) => loadCharacter(cfg, i));

        const presetNight = lightingPresets.night;
        const selectionDirectional = new THREE.DirectionalLight(presetNight.key.color, 1.8);
        selectionDirectional.position.set(-2.2, 3.2, 2.8);
        scene.add(selectionDirectional);

        const selectionRim = new THREE.DirectionalLight(presetNight.rim.color, 1.3);
        selectionRim.position.set(1.8, 2.6, -2.8);
        scene.add(selectionRim);

        const selectionSpot = new THREE.SpotLight(presetNight.ring.color, 2.15, 14, Math.PI / 5, 0.3, 1.8);
        selectionSpot.position.set(0, 4.1, 0.9);
        selectionSpot.target = podium;
        scene.add(selectionSpot, selectionSpot.target);

        // ------ PARTÍCULAS DE POLVO ------
        const dustCount = 900;
        const dustPositions = new Float32Array(dustCount * 3);
        const dustGeo = new THREE.BufferGeometry();
        for (let i = 0; i < dustCount; i++) {
            const ix = i * 3;
            dustPositions[ix] = (Math.random() - 0.5) * 26;
            dustPositions[ix + 1] = Math.random() * 6 + 0.5;
            dustPositions[ix + 2] = (Math.random() - 0.5) * 26;
        }
        dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
        const dustMat = new THREE.PointsMaterial({
            size: 0.08,
            color: 0xffffff,
            transparent: true,
            opacity: 0.36,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
        });
        const dustPoints = new THREE.Points(dustGeo, dustMat);
        scene.add(dustPoints);

        // ------ VOLUMETRIC GODRAYS SIMPLES ------
        const godrayMaterial = new THREE.ShaderMaterial({
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            uniforms: {
                time: { value: 0 },
                hue: { value: lightingPresets.night.volumetricHue },
                opacity: { value: 0.32 },
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                uniform float time;
                uniform float hue;
                uniform float opacity;
                float random(vec2 st){
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }
                void main(){
                    float radial = smoothstep(0.0, 0.55, 1.0 - length(vUv - 0.5));
                    float drift = random(vUv + time * 0.07) * 0.4;
                    float alpha = clamp(radial * 0.9 + drift * 0.25, 0.0, 1.0);
                    vec3 col = vec3(1.0, 0.8 + hue, 0.65 + hue * 0.6);
                    gl_FragColor = vec4(col * 0.8, alpha * opacity);
                }
            `,
        });
        const godrayPlane = new THREE.Mesh(new THREE.PlaneGeometry(10, 8, 1, 1), godrayMaterial);
        godrayPlane.position.set(-1.5, 2.5, 1.6);
        godrayPlane.rotation.y = Math.PI / 8;
        godrayPlane.rotation.x = -0.15;
        scene.add(godrayPlane);

        // ------ FOG ANIMADO ------
        let fogTarget = lightingPresets.night.fogDensity;
        function updateFog(elapsed, mixFactor) {
            const presetFog = THREE.MathUtils.lerp(lightingPresets.night.fogDensity, lightingPresets.sunset.fogDensity, mixFactor);
            fogTarget = presetFog + Math.sin(elapsed * 0.35) * 0.01;
            scene.fog.density = THREE.MathUtils.lerp(scene.fog.density, Math.max(0.0, fogTarget), 0.05);
            scene.fog.color.lerpColors(new THREE.Color(lightingPresets.night.fogColor), new THREE.Color(lightingPresets.sunset.fogColor), mixFactor);
            scene.background = scene.fog.color.clone();
        }

        // ------ TRAVELLING DE CÁMARA ------
        const travelDuration = 16.0;
        const startPos = new THREE.Vector3(-9, 2.5, 8.5);
        const midPos = new THREE.Vector3(-4.5, 3.1, 5.5);
        const endPos = new THREE.Vector3(0, 2.3, 5.2);
        const lookTarget = new THREE.Vector3(0, 1.3, 0.4);
        const tempVec = new THREE.Vector3();

        function smoothstep(t){ return t * t * (3 - 2 * t); }

        function updateCamera(progress){
            const first = Math.min(progress * 1.6, 1.0);
            tempVec.copy(startPos).lerp(midPos, smoothstep(Math.min(progress * 1.2, 1.0)));
            const endLerp = THREE.MathUtils.clamp((progress - 0.45) / 0.55, 0, 1);
            tempVec.lerp(endPos, smoothstep(endLerp));
            camera.position.copy(tempVec);
            camera.lookAt(lookTarget);
            camera.fov = THREE.MathUtils.lerp(62, 55, smoothstep(endLerp));
            camera.updateProjectionMatrix();
        }

        // ------ INTERPOLACIÓN DE LUCES ------
        function lerpColor(a, b, t){
            const ca = new THREE.Color(a);
            const cb = new THREE.Color(b);
            return ca.lerp(cb, t);
        }
        function applyLighting(progress){
            ambientLight.color.copy(lerpColor(lightingPresets.night.ambient.color, lightingPresets.sunset.ambient.color, progress));
            ambientLight.intensity = THREE.MathUtils.lerp(lightingPresets.night.ambient.intensity, lightingPresets.sunset.ambient.intensity, progress);

            keyLight.color.copy(lerpColor(lightingPresets.night.key.color, lightingPresets.sunset.key.color, progress));
            keyLight.intensity = THREE.MathUtils.lerp(lightingPresets.night.key.intensity, lightingPresets.sunset.key.intensity, progress);
            fillLight.color.copy(lerpColor(lightingPresets.night.fill.color, lightingPresets.sunset.fill.color, progress));
            fillLight.intensity = THREE.MathUtils.lerp(lightingPresets.night.fill.intensity, lightingPresets.sunset.fill.intensity, progress);
            rimLight.color.copy(lerpColor(lightingPresets.night.rim.color, lightingPresets.sunset.rim.color, progress));
            rimLight.intensity = THREE.MathUtils.lerp(lightingPresets.night.rim.intensity, lightingPresets.sunset.rim.intensity, progress);
            ringLight.color.copy(lerpColor(lightingPresets.night.ring.color, lightingPresets.sunset.ring.color, progress));
            ringLight.intensity = THREE.MathUtils.lerp(lightingPresets.night.ring.intensity, lightingPresets.sunset.ring.intensity, progress);

            selectionDirectional.color.copy(lerpColor(lightingPresets.night.key.color, lightingPresets.sunset.key.color, progress));
            selectionDirectional.intensity = THREE.MathUtils.lerp(1.8, 2.4, progress);
            selectionRim.color.copy(lerpColor(lightingPresets.night.rim.color, lightingPresets.sunset.rim.color, progress));
            selectionRim.intensity = THREE.MathUtils.lerp(1.3, 1.9, progress);
            selectionSpot.color.copy(lerpColor(lightingPresets.night.ring.color, lightingPresets.sunset.ring.color, progress));
            selectionSpot.intensity = THREE.MathUtils.lerp(2.15, 2.6, progress);

            godrayMaterial.uniforms.hue.value = THREE.MathUtils.lerp(
                lightingPresets.night.volumetricHue,
                lightingPresets.sunset.volumetricHue,
                progress
            );
        }

        // ------ ANIMACIONES AUXILIARES ------
        function animateDust(time){
            const positions = dustGeo.attributes.position.array;
            for(let i = 0; i < dustCount; i++){
                const ix = i * 3;
                positions[ix] += Math.sin((ix + time * 10) * 0.005) * 0.005;
                positions[ix + 1] += Math.cos((ix + time * 12) * 0.003) * 0.002;
                positions[ix + 2] += Math.sin((ix + time * 14) * 0.004) * 0.004;
            }
            dustGeo.attributes.position.needsUpdate = true;
        }

        function updateMixers(delta){
            mixers.forEach((mixer) => mixer.update(delta));
        }

        function previewJab(slot){
            if(slot?.actions?.jab && slot?.actions?.idle){
                slot.actions.jab.reset();
                slot.actions.jab.setLoop(THREE.LoopOnce);
                slot.actions.jab.clampWhenFinished = true;
                slot.actions.jab.play();
                slot.actions.jab.crossFadeFrom(slot.actions.idle, 0.18, false);
                setTimeout(() => {
                    slot.actions.idle.reset().fadeIn(0.2).play();
                }, 820);
            }
        }

        function navigateCharacter(direction){
            if(!selectionActive) return;
            const nextIndex = currentCharacter + direction;
            setActiveCharacter(nextIndex);
            previewJab(characterSlots[currentCharacter]);
        }

        function confirmSelection(){
            if(!selectionActive) return;
            selectedCharacter = characterConfigs[currentCharacter];
            selectionActive = false;
            selectionHelper.textContent = freeCameraMode
                ? `${selectedCharacter.name} listo • Cámara libre activa`
                : `${selectedCharacter.name} elegido • Volviendo al juego`;
            controls.enabled = freeCameraMode;
            camera.position.copy(new THREE.Vector3(0, 2.3, 5.2));
            camera.lookAt(new THREE.Vector3(0, 1.3, 0.4));
            gameState = 'playing';
        }

        function startSelectionMode(){
            selectionActive = true;
            controls.enabled = true;
            controls.target.set(0, 1.0, 0);
            controls.update();
            selectionHelper.textContent = 'Navega con ←/→ o mando • Enter para elegir';
            selectionHelper.style.display = 'block';
            characterUi.style.display = 'flex';
            setActiveCharacter(currentCharacter);
        }

        window.addEventListener('keydown', (event) => {
            if(!selectionActive) return;
            if(event.code === 'ArrowLeft' || event.code === 'KeyA'){
                navigateCharacter(-1);
            }
            if(event.code === 'ArrowRight' || event.code === 'KeyD'){
                navigateCharacter(1);
            }
            if(event.code === 'Enter' || event.code === 'Space'){
                confirmSelection();
            }
        });

        function pollGamepad(delta){
            const pads = navigator.getGamepads ? navigator.getGamepads() : [];
            const pad = pads.find((p) => p);
            if(!pad) return;
            lastPadSwap += delta;
            const axisX = pad.axes[0] ?? 0;
            if(Math.abs(axisX) > 0.4 && lastPadSwap > 0.35){
                navigateCharacter(axisX < 0 ? -1 : 1);
                lastPadSwap = 0;
            }
            if(pad.buttons[0]?.pressed){
                confirmSelection();
            }
        }

        // ------ LOOP ------
        const clock = new THREE.Clock();
        let travelTime = 0;

        function animate(){
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            travelTime += delta;
            const elapsed = travelTime;
            const progress = THREE.MathUtils.clamp(travelTime / travelDuration, 0, 1);

            applyLighting(progress);
            updateFog(elapsed, progress);

            if(gameState === 'cinematic'){
                updateCamera(progress);
                if(progress >= 1.0){
                    gameState = 'selecting';
                    startSelectionMode();
                }
            } else {
                controls.update();
                updateMixers(delta);
                pollGamepad(delta);
            }

            animateDust(elapsed);
            godrayMaterial.uniforms.time.value = elapsed;
            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bokehPass.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
