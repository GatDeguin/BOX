<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ring POV – Three.js</title>
  <link rel="icon" href="data:," />
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at 20% 20%, #0b0f1d 0%, #05060a 55%);
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 12px 18px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(6px);
      background: rgba(10, 12, 24, 0.75);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    header h1 {
      font-size: 1.1rem;
      letter-spacing: 0.02em;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      font-size: 0.8rem;
    }

    .tag span {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22d3ee;
      box-shadow: 0 0 10px rgba(34, 211, 238, 0.8);
    }

    main {
      flex: 1;
      position: relative;
    }

    canvas {
      width: 100%;
      height: calc(100vh - 66px);
      display: block;
    }

    #overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
      pointer-events: none;
    }

    .pill {
      padding: 6px 12px;
      background: rgba(17, 24, 39, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 999px;
      font-size: 0.8rem;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.35);
      pointer-events: auto;
    }

    .hud {
      position: absolute;
      left: 14px;
      bottom: 18px;
      padding: 10px 12px;
      background: rgba(15, 23, 42, 0.82);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      max-width: 260px;
      font-size: 0.9rem;
      line-height: 1.45;
      box-shadow: 0 15px 45px rgba(0, 0, 0, 0.45);
    }

    .hud__title {
      font-weight: 700;
      font-size: 0.95rem;
      margin-bottom: 6px;
      color: #cbd5f5;
      letter-spacing: 0.01em;
    }

    .hud ul {
      list-style: none;
      display: grid;
      gap: 6px;
      padding-left: 0;
    }

    .hud li {
      display: flex;
      gap: 6px;
      align-items: center;
      color: #d1d5db;
    }

    .hud strong {
      display: inline-flex;
      width: 28px;
      height: 28px;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
      font-weight: 700;
      color: #f8fafc;
    }
  </style>
</head>
<body>
  <header>
    <h1>Ring POV • Three.js</h1>
    <div class="tag"><span></span> Carga: Ring.glb + FBX</div>
  </header>
  <main>
    <div id="overlay"></div>
    <div class="hud">
      <div class="hud__title">Controles rápidos</div>
      <ul>
        <li><strong>C</strong> • Cambiar POV / Orbital</li>
        <li><strong>P</strong> • Pausar / reanudar animaciones</li>
        <li><strong>R</strong> • Regenerar público</li>
        <li><strong>Click + WASD</strong> • Moverte en POV</li>
      </ul>
    </div>
    <canvas id="scene"></canvas>
  </main>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
    import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { FilmPass } from 'three/examples/jsm/postprocessing/FilmPass.js';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
    import { VignetteShader } from 'three/examples/jsm/shaders/VignetteShader.js';

    const canvas = document.getElementById('scene');
    const overlay = document.getElementById('overlay');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#030712');
    scene.fog = new THREE.FogExp2('#0b1b2f', 0.05);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.8));

    const povCamera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight - 66), 0.1, 100);
    povCamera.position.set(0, 1.6, 0.35);
    povCamera.lookAt(0, 1.4, -1);

    const orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight - 66), 0.1, 200);
    orbitCamera.position.set(6, 4.5, 6);
    orbitCamera.lookAt(0, 1, 0);

    let activeCamera = povCamera;
    const controls = new OrbitControls(orbitCamera, renderer.domElement);
    controls.enableDamping = true;
    controls.enabled = false;
    controls.target.set(0, 1, 0);

    const povControls = new PointerLockControls(povCamera, renderer.domElement);
    const povMoveState = { forward: false, backward: false, left: false, right: false };
    const POV_MOVE_SPEED = 3.8;

    function resetPovMovement() {
      povMoveState.forward = false;
      povMoveState.backward = false;
      povMoveState.left = false;
      povMoveState.right = false;
    }

    povControls.addEventListener('unlock', resetPovMovement);

    const hemiLight = new THREE.HemisphereLight('#dbeafe', '#0f172a', 0.35);
    hemiLight.position.set(0, 8, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight('#bcd7ff', 0.55);
    dirLight.position.set(4, 8, 2);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 30;
    dirLight.shadow.camera.left = -10;
    dirLight.shadow.camera.right = 10;
    dirLight.shadow.camera.top = 10;
    dirLight.shadow.camera.bottom = -10;
    scene.add(dirLight);

    const spotGroup = new THREE.Group();
    const spotConfig = [
      { position: new THREE.Vector3(0, 8, 0), angle: 0.5 },
      { position: new THREE.Vector3(4, 7.5, 2), angle: 0.45 },
      { position: new THREE.Vector3(-4, 7.2, -2), angle: 0.45 },
      { position: new THREE.Vector3(2, 7.6, -4), angle: 0.45 },
    ];

    spotConfig.forEach(({ position, angle }) => {
      const spot = new THREE.SpotLight('#dff3ff', 2.8, 22, angle + 0.05, 0.55, 1.5);
      spot.position.copy(position);
      spot.target.position.set(0, 1.2, 0);
      spot.castShadow = true;
      spot.shadow.mapSize.set(1024, 1024);
      spot.shadow.bias = -0.0004;
      spot.penumbra = 0.65;
      spotGroup.add(spot);
      spotGroup.add(spot.target);
    });
    scene.add(spotGroup);

    const ambient = new THREE.AmbientLight('#a5b4fc', 0.16);
    scene.add(ambient);

    const ledPanels = [];
    const ledPanelGeometry = new THREE.BoxGeometry(2.6, 1.2, 0.08);
    const ledBaseColor = new THREE.Color('#0ea5e9');

    const fxGroup = new THREE.Group();
    scene.add(fxGroup);

    const edgeStripMaterial = new THREE.MeshStandardMaterial({
      color: '#0a0f1f',
      emissive: '#38bdf8',
      emissiveIntensity: 1.3,
      roughness: 0.38,
      metalness: 0.12,
      transparent: true,
      opacity: 0.9,
    });

    const edgeStripGeometry = new THREE.BoxGeometry(6.8, 0.06, 0.16);
    const edgeStripPositions = [
      new THREE.Vector3(0, 0.14, 3.4),
      new THREE.Vector3(0, 0.14, -3.4),
      new THREE.Vector3(3.4, 0.14, 0),
      new THREE.Vector3(-3.4, 0.14, 0),
    ];

    edgeStripPositions.forEach((pos, idx) => {
      const strip = new THREE.Mesh(edgeStripGeometry, edgeStripMaterial.clone());
      strip.position.copy(pos);
      if (idx >= 2) {
        strip.rotation.y = Math.PI / 2;
      }
      strip.castShadow = false;
      strip.receiveShadow = true;
      fxGroup.add(strip);
    });

    const ledPositions = [
      { position: new THREE.Vector3(0, 0.7, 9.5), rotation: new THREE.Euler(0, 0, 0) },
      { position: new THREE.Vector3(0, 0.7, -9.5), rotation: new THREE.Euler(0, Math.PI, 0) },
      { position: new THREE.Vector3(9.5, 0.7, 0), rotation: new THREE.Euler(0, -Math.PI / 2, 0) },
      { position: new THREE.Vector3(-9.5, 0.7, 0), rotation: new THREE.Euler(0, Math.PI / 2, 0) },
    ];

    ledPositions.forEach(({ position, rotation }) => {
      const material = new THREE.MeshStandardMaterial({
        color: '#0f172a',
        emissive: ledBaseColor.clone(),
        emissiveIntensity: 1.5,
        metalness: 0.45,
        roughness: 0.35,
      });
      const panel = new THREE.Mesh(ledPanelGeometry, material);
      panel.position.copy(position);
      panel.rotation.copy(rotation);
      panel.castShadow = false;
      panel.receiveShadow = true;
      ledPanels.push(panel);
      scene.add(panel);
    });

    const cornerLights = [
      new THREE.Vector3(3.2, 1.7, 3.2),
      new THREE.Vector3(3.2, 1.7, -3.2),
      new THREE.Vector3(-3.2, 1.7, 3.2),
      new THREE.Vector3(-3.2, 1.7, -3.2),
    ];

    cornerLights.forEach((position) => {
      const point = new THREE.PointLight('#ffb37a', 0.6, 4.5, 1.8);
      point.position.copy(position);
      point.castShadow = true;
      scene.add(point);
    });

    const mixers = new Set();
    const loaderManager = new THREE.LoadingManager();

    const gltfLoader = new GLTFLoader(loaderManager);
    const fbxLoader = new FBXLoader(loaderManager);

    const fighters = {
      tyson: { label: 'Tyson', url: 'modelos/Tyson.fbx' },
      principal: { label: 'Principal', url: 'modelos/Principal.fbx' },
      mma: { label: 'MMA', url: 'modelos/MMA.fbx' },
      bodybuilder: { label: 'Bodybuilder', url: 'modelos/Bodybuilder.fbx' },
    };

    const fighterSlots = {
      player: {
        position: new THREE.Vector3(2.2, 0, 2.2),
        flip: true,
        current: 'principal',
        model: null,
        mixer: null,
        requestId: 0,
      },
      rival: {
        position: new THREE.Vector3(-2.2, 0, -2.2),
        flip: false,
        current: 'tyson',
        model: null,
        mixer: null,
        requestId: 0,
      },
    };

    const stageProfiles = {
      Presentación: {
        intensity: 0.35,
        noise: 0.45,
        ledColor: '#22d3ee',
        audio: 'sonidos/publico_intro.wav',
      },
      Combate: {
        intensity: 0.72,
        noise: 0.75,
        ledColor: '#f472b6',
        audio: 'sonidos/publico_enojado.wav',
      },
      Clímax: {
        intensity: 1,
        noise: 1,
        ledColor: '#f97316',
        audio: 'sonidos/publico_victoria.wav',
      },
    };

    let fightIntensity = stageProfiles.Presentación.intensity;
    let crowdNoiseLevel = stageProfiles.Presentación.noise;
    let stageName = 'Presentación';

    function setShadows(object) {
      object.traverse?.((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
    }

    async function loadRing() {
      const candidates = ['modelos/Ring.glb', 'modelos/Ring 2.glb'];
      for (const url of candidates) {
        try {
          const gltf = await gltfLoader.loadAsync(url);
          const ring = gltf.scene;
          ring.name = 'RingBase';
          ring.rotation.y = Math.PI / 2;
          setShadows(ring);
          scene.add(ring);
          return;
        } catch (err) {
          console.warn('No se pudo cargar', url, err.message);
        }
      }
      console.warn('No se encontró ningún modelo Ring.glb/Ring 2.glb');
    }

    async function loadFighter(url, position, flip = false) {
      try {
        const model = await fbxLoader.loadAsync(url);
        model.scale.setScalar(0.01);
        model.position.copy(position);
        model.rotation.y = flip ? Math.PI / 4 : -Math.PI / 4;
        setShadows(model);

        let mixer = null;
        if (model.animations?.length) {
          mixer = new THREE.AnimationMixer(model);
          model.animations.forEach((clip) => mixer.clipAction(clip).play());
        }

        return { model, mixer };
      } catch (err) {
        console.warn('No se pudo cargar', url, err.message);
        return null;
      }
    }

    function disposeModel(model) {
      model.traverse?.((child) => {
        if (!child.isMesh) return;
        child.geometry?.dispose?.();
        const materials = Array.isArray(child.material) ? child.material : [child.material];
        materials.forEach((material) => material?.dispose?.());
      });
    }

    async function setFighter(slotKey, fighterKey) {
      const slot = fighterSlots[slotKey];
      const fighter = fighters[fighterKey];
      if (!slot || !fighter) return;

      slot.requestId += 1;
      const requestId = slot.requestId;

      const loaded = await loadFighter(fighter.url, slot.position, slot.flip);
      if (!loaded || requestId !== slot.requestId) {
        loaded?.model && disposeModel(loaded.model);
        return;
      }

      if (slot.model) {
        scene.remove(slot.model);
        disposeModel(slot.model);
      }

      if (slot.mixer) {
        mixers.delete(slot.mixer);
      }

      slot.current = fighterKey;
      slot.model = loaded.model;
      slot.mixer = loaded.mixer;
      scene.add(loaded.model);
      if (loaded.mixer) {
        mixers.add(loaded.mixer);
      }
    }

    const params = {
      camara: 'POV',
      rival: 'tyson',
      pausarAnimaciones: false,
      luzDireccional: dirLight.intensity,
      hemi: hemiLight.intensity,
      espectadores: 1200,
      niebla: scene.fog.density,
      bloom: 1.2,
      bloomUmbral: 0.82,
      etapa: stageName,
    };

    fighterSlots.rival.current = params.rival;

    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, activeCamera);
    const unrealBloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), params.bloom, 0.9, params.bloomUmbral);
    unrealBloomPass.threshold = params.bloomUmbral;
    unrealBloomPass.strength = params.bloom;
    const filmPass = new FilmPass(0.22, 0.35, 648, false);
    const vignettePass = new ShaderPass(VignetteShader);
    vignettePass.uniforms['offset'].value = 1.1;
    vignettePass.uniforms['darkness'].value = 1.3;
    composer.addPass(renderPass);
    composer.addPass(unrealBloomPass);
    composer.addPass(filmPass);
    composer.addPass(vignettePass);

    function resize() {
      const width = window.innerWidth;
      const height = window.innerHeight - 66;
      renderer.setSize(width, height, false);
      composer.setSize(width, height);
      unrealBloomPass.setSize(width, height);
      [povCamera, orbitCamera].forEach((cam) => {
        cam.aspect = width / height;
        cam.updateProjectionMatrix();
      });
    }

    window.addEventListener('resize', resize);
    resize();

    const gui = new GUI({ width: 320, container: overlay });
    gui.domElement.style.pointerEvents = 'auto';

    const rivalOptions = {
      Tyson: 'tyson',
      Principal: 'principal',
      MMA: 'mma',
      Bodybuilder: 'bodybuilder',
    };

    function applyCameraMode(mode) {
      params.camara = mode;
      const useOrbit = mode === 'Orbital';
      controls.enabled = useOrbit;
      activeCamera = useOrbit ? orbitCamera : povCamera;
      renderPass.camera = activeCamera;
      attachListener(activeCamera);
      if (!useOrbit) {
        povCamera.position.set(0, 1.6, 0.35);
        povCamera.lookAt(0, 1.4, -1);
        povControls.getObject().position.copy(povCamera.position);
        povControls.getObject().rotation.copy(povCamera.rotation);
      } else {
        povControls.unlock();
        resetPovMovement();
      }
      updateStatusText();
    }

    function toggleAnimations() {
      params.pausarAnimaciones = !params.pausarAnimaciones;
      pauseController.setValue(params.pausarAnimaciones);
      updateStatusText();
    }

    const cameraController = gui.add(params, 'camara', ['POV', 'Orbital']).name('Modo de cámara').onChange(applyCameraMode);

    const rivalController = gui
      .add(params, 'rival', rivalOptions)
      .name('Rival')
      .onChange((value) => {
        setFighter('rival', value);
        updateStatusText();
      });

    const pauseController = gui.add(params, 'pausarAnimaciones').name('Pausar animaciones').onChange(() => {
      params.pausarAnimaciones = !!params.pausarAnimaciones;
      updateStatusText();
    });
    gui.add(params, 'etapa', Object.keys(stageProfiles)).name('Etapa de pelea').onChange((value) => setStage(value));
    gui.add(params, 'luzDireccional', 0, 2, 0.05).name('Luz direccional').onChange((v) => dirLight.intensity = v);
    gui.add(params, 'hemi', 0, 1.5, 0.05).name('Luz ambiente').onChange((v) => hemiLight.intensity = v);
    gui.add(params, 'niebla', 0, 0.25, 0.005).name('Densidad niebla').onChange((v) => scene.fog.density = v);
    gui.add(params, 'bloomUmbral', 0.4, 1.5, 0.01).name('Umbral bloom').onChange((v) => unrealBloomPass.threshold = v);
    gui.add(params, 'bloom', 0, 3, 0.05).name('Intensidad bloom').onChange((v) => unrealBloomPass.strength = v);
    gui.add(params, 'espectadores', 400, 4000, 50).name('Espectadores').onChange(() => {
      rebuildSpectators();
      updateStatusText();
    });

    const status = document.createElement('div');
    status.className = 'pill';
    status.textContent = 'Cargando modelos…';
    overlay.appendChild(status);

    function updateStatusText() {
      const rivalLabel = fighters[params.rival]?.label ?? params.rival;
      status.textContent = `Listo • ${params.camara} • ${stageName} • Rival: ${rivalLabel} • Animaciones: ${params.pausarAnimaciones ? 'Pausadas' : 'Activas'} • ${params.espectadores} espectadores`;
    }

    Promise.all([
      loadRing(),
      setFighter('player', fighterSlots.player.current),
      setFighter('rival', params.rival),
    ]).finally(() => {
      updateStatusText();
    });

    const clock = new THREE.Clock();

    const spectatorGeometry = new THREE.CapsuleGeometry(0.12, 0.35, 8, 16);
    const spectatorMaterial = new THREE.MeshStandardMaterial({
      color: '#111827',
      roughness: 0.65,
      metalness: 0.05,
    });

    let spectatorsMesh = null;
    let spectatorData = [];
    const spectatorDummy = new THREE.Object3D();

    const listener = new THREE.AudioListener();
    const crowdAudio = new THREE.Audio(listener);
    const bellAudio = new THREE.Audio(listener);
    const audioLoader = new THREE.AudioLoader();
    povCamera.add(listener);

    const smokeCount = 90;
    const smokePositions = new Float32Array(smokeCount * 3);
    const smokeVelocities = new Float32Array(smokeCount);
    const smokeMaterial = new THREE.PointsMaterial({
      color: '#9fb3c8',
      size: 0.55,
      transparent: true,
      opacity: 0.32,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });
    const smokeGeometry = new THREE.BufferGeometry();
    smokeGeometry.setAttribute('position', new THREE.BufferAttribute(smokePositions, 3));
    const smokePoints = new THREE.Points(smokeGeometry, smokeMaterial);
    smokePoints.frustumCulled = false;
    fxGroup.add(smokePoints);

    function resetSmokeParticle(index, baseY = 0.05) {
      const radius = 3.2 + Math.random() * 1.1;
      const angle = Math.random() * Math.PI * 2;
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius;
      const y = baseY + Math.random() * 0.35;

      smokePositions[index * 3] = x;
      smokePositions[index * 3 + 1] = y;
      smokePositions[index * 3 + 2] = z;
      smokeVelocities[index] = 0.08 + Math.random() * 0.12;
    }

    for (let i = 0; i < smokeCount; i++) {
      resetSmokeParticle(i, Math.random() * 0.2);
    }

    smokeGeometry.attributes.position.needsUpdate = true;

    const dustCount = 140;
    const dustPositions = new Float32Array(dustCount * 3);
    const dustVelocity = new Float32Array(dustCount * 3);
    const dustLife = new Float32Array(dustCount).fill(0);
    const dustMaterial = new THREE.PointsMaterial({
      color: '#f3ddc2',
      size: 0.085,
      transparent: true,
      opacity: 0.06,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });
    const dustGeometry = new THREE.BufferGeometry();
    dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
    const dustPoints = new THREE.Points(dustGeometry, dustMaterial);
    dustPoints.frustumCulled = false;
    fxGroup.add(dustPoints);

    for (let i = 0; i < dustCount; i++) {
      dustPositions[i * 3 + 1] = -10;
    }
    dustGeometry.attributes.position.needsUpdate = true;

    const loadedBuffers = new Map();

    function attachListener(camera) {
      listener.removeFromParent();
      camera.add(listener);
    }

    function playCrowdAudio(stageKey) {
      const config = stageProfiles[stageKey];
      if (!config?.audio) return;
      const url = config.audio;
      const volume = 0.45 + config.intensity * 0.45;

      const playBuffer = (buffer) => {
        if (crowdAudio.isPlaying) {
          crowdAudio.stop();
        }
        crowdAudio.setBuffer(buffer);
        crowdAudio.setLoop(true);
        crowdAudio.setVolume(volume);
        crowdAudio.play();
      };

      if (loadedBuffers.has(url)) {
        playBuffer(loadedBuffers.get(url));
        return;
      }

      audioLoader.load(url, (buffer) => {
        loadedBuffers.set(url, buffer);
        playBuffer(buffer);
      });
    }

    function playBell() {
      const url = 'sonidos/campana.mp3';
      const volume = 0.9;

      const start = (buffer) => {
        bellAudio.stop();
        bellAudio.setBuffer(buffer);
        bellAudio.setLoop(false);
        bellAudio.setVolume(volume);
        bellAudio.play();
      };

      if (loadedBuffers.has(url)) {
        start(loadedBuffers.get(url));
        return;
      }

      audioLoader.load(url, (buffer) => {
        loadedBuffers.set(url, buffer);
        start(buffer);
      });
    }

    function setStage(nextStage) {
      const config = stageProfiles[nextStage];
      if (!config) return;
      const startingCombat = stageName !== 'Combate' && nextStage === 'Combate';
      stageName = nextStage;
      params.etapa = nextStage;
      fightIntensity = config.intensity;
      crowdNoiseLevel = config.noise;
      ledBaseColor.set(config.ledColor);
      updateAtmosphere(0);
      playCrowdAudio(nextStage);
      if (startingCombat) {
        playBell();
      }
      updateStatusText();
    }

    function updateAtmosphere(time) {
      const hue = THREE.MathUtils.lerp(0.62, 0.02, fightIntensity);
      const saturation = 0.7 + fightIntensity * 0.25;
      const lightness = 0.55 + fightIntensity * 0.15;
      const lightColor = new THREE.Color().setHSL(hue, saturation, lightness);
      const pulse = Math.sin(time * (1.4 + fightIntensity)) * 0.05;

      ambient.color.copy(lightColor);
      hemiLight.color.copy(lightColor);
      ambient.intensity = 0.12 + fightIntensity * 0.4 + pulse * 0.5;
      hemiLight.intensity = params.hemi + fightIntensity * 0.35 + pulse * 0.6;

      spotGroup.children.forEach((child) => {
        if (child.isLight) {
          child.color.lerp(lightColor, 0.35);
          child.intensity = 2 + fightIntensity * 1.8 + Math.sin(time * 2 + child.position.x) * 0.08;
        }
      });
    }

    function updateLedPanels(noise, time) {
      const vivid = THREE.MathUtils.clamp(noise, 0, 1);
      const reactiveColor = new THREE.Color().setHSL(0.56 - vivid * 0.38, 0.9, 0.55 + vivid * 0.25);
      const emissiveColor = ledBaseColor.clone().lerp(reactiveColor, 0.6);

      ledPanels.forEach((panel, index) => {
        const flicker = Math.sin(time * 3 + index) * 0.08 + Math.random() * 0.02;
        const level = THREE.MathUtils.clamp(1.2 + vivid * 2.6 + flicker, 0.8, 3.8);
        panel.material.emissive.copy(emissiveColor);
        panel.material.emissiveIntensity = level;
        panel.scale.y = 1 + vivid * 0.25 + Math.sin(time * 5 + index) * 0.04;
      });
    }

    function updateSmoke(delta, time) {
      for (let i = 0; i < smokeCount; i++) {
        smokePositions[i * 3 + 1] += smokeVelocities[i] * delta;
        smokePositions[i * 3] += Math.sin(time * 0.35 + i) * 0.015 * delta;
        smokePositions[i * 3 + 2] += Math.cos(time * 0.35 + i) * 0.015 * delta;

        if (smokePositions[i * 3 + 1] > 1) {
          resetSmokeParticle(i, 0.04);
        }
      }

      const swell = 0.2 + fightIntensity * 0.35 + Math.sin(time * 0.5) * 0.05;
      smokeMaterial.opacity = THREE.MathUtils.clamp(0.22 + swell * 0.25, 0.18, 0.42);
      smokeGeometry.attributes.position.needsUpdate = true;
    }

    function spawnDustBurst() {
      const burstSize = 10 + Math.floor(Math.random() * 12);
      const radius = 0.6 + Math.random() * 1.2;
      const centerAngle = Math.random() * Math.PI * 2;

      for (let i = 0; i < dustCount; i++) {
        if (dustLife[i] > 0) continue;
        const angle = centerAngle + (Math.random() - 0.5) * 0.7;
        const dist = radius + (Math.random() - 0.5) * 0.35;
        dustPositions[i * 3] = Math.cos(angle) * dist;
        dustPositions[i * 3 + 1] = 0.08 + Math.random() * 0.04;
        dustPositions[i * 3 + 2] = Math.sin(angle) * dist;
        dustVelocity[i * 3] = (Math.random() - 0.5) * 0.3;
        dustVelocity[i * 3 + 1] = 0.45 + Math.random() * 0.4;
        dustVelocity[i * 3 + 2] = (Math.random() - 0.5) * 0.3;
        dustLife[i] = 1.2 + Math.random() * 0.4;
        if (--burstSize <= 0) break;
      }

      dustGeometry.attributes.position.needsUpdate = true;
    }

    function updateDust(delta) {
      let active = 0;

      for (let i = 0; i < dustCount; i++) {
        if (dustLife[i] <= 0) continue;
        active++;

        dustPositions[i * 3] += dustVelocity[i * 3] * delta;
        dustPositions[i * 3 + 1] += dustVelocity[i * 3 + 1] * delta;
        dustPositions[i * 3 + 2] += dustVelocity[i * 3 + 2] * delta;
        dustVelocity[i * 3 + 1] -= delta * 0.28;
        dustLife[i] -= delta * 1.1;

        if (dustLife[i] <= 0 || dustPositions[i * 3 + 1] < 0) {
          dustLife[i] = 0;
          dustPositions[i * 3 + 1] = -10;
        }
      }

      const pulse = Math.min(active / 40, 1);
      dustMaterial.opacity = 0.05 + pulse * 0.35;
      dustGeometry.attributes.position.needsUpdate = true;
    }

    function updatePovMovement(delta) {
      if (params.camara !== 'POV' || !povControls.isLocked) return;

      const distance = POV_MOVE_SPEED * delta;
      if (povMoveState.forward) povControls.moveForward(distance);
      if (povMoveState.backward) povControls.moveForward(-distance);
      if (povMoveState.left) povControls.moveRight(-distance);
      if (povMoveState.right) povControls.moveRight(distance);
    }

    updateAtmosphere(0);

    let audioPrimed = false;
    function resumeCrowdAudio() {
      if (audioPrimed) return;
      audioPrimed = true;
      listener.context.resume?.();
      playCrowdAudio(stageName);
    }
    window.addEventListener('pointerdown', resumeCrowdAudio, { once: true });

    renderer.domElement.addEventListener('click', () => {
      if (params.camara === 'POV' && !povControls.isLocked) {
        povControls.lock();
      }
    });

    function handleMoveKey(key, pressed, event) {
      let handled = true;
      switch (key) {
        case 'w':
        case 'arrowup':
          povMoveState.forward = pressed;
          break;
        case 's':
        case 'arrowdown':
          povMoveState.backward = pressed;
          break;
        case 'a':
        case 'arrowleft':
          povMoveState.left = pressed;
          break;
        case 'd':
        case 'arrowright':
          povMoveState.right = pressed;
          break;
        default:
          handled = false;
          break;
      }

      if (handled && params.camara === 'POV') {
        event?.preventDefault?.();
      }

      return handled;
    }

    function rebuildSpectators() {
      if (spectatorsMesh) {
        scene.remove(spectatorsMesh);
        spectatorsMesh.dispose?.();
      }

      const total = Math.max(400, Math.min(4000, Math.floor(params.espectadores)));
      spectatorData = [];
      spectatorsMesh = new THREE.InstancedMesh(spectatorGeometry, spectatorMaterial, total);
      spectatorsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      spectatorsMesh.receiveShadow = true;
      spectatorsMesh.castShadow = true;

      const baseRadius = 7.5;
      const ringSpacing = 0.9;
      const radialJitter = 0.15;
      const angleJitterStrength = 0.3;
      const densityStep = 0.55;

      let remaining = total;
      let ringIndex = 0;
      let instanceId = 0;

      while (remaining > 0) {
        const radius = baseRadius + ringSpacing * ringIndex;
        const idealCount = Math.max(12, Math.round((2 * Math.PI * radius) / densityStep));
        const ringCount = Math.min(idealCount, remaining);
        const angleStep = (Math.PI * 2) / ringCount;

        for (let i = 0; i < ringCount; i++) {
          const jitter = (Math.random() - 0.5) * angleStep * angleJitterStrength;
          const angle = i * angleStep + jitter;
          const offsetRadius = radius + (Math.random() - 0.5) * radialJitter;

          const x = Math.cos(angle) * offsetRadius;
          const z = Math.sin(angle) * offsetRadius;
          const baseY = 0.2 + Math.random() * 0.32;
          const rotationY = angle + Math.PI + (Math.random() - 0.5) * 0.35;
          const amplitude = 0.02 + Math.random() * 0.1;
          const speed = 0.8 + Math.random() * 1.1;
          const phase = Math.random() * Math.PI * 2;
          const rotAmplitude = 0.015 + Math.random() * 0.05;
          const rotSpeed = 0.45 + Math.random() * 0.9;
          const rotPhase = Math.random() * Math.PI * 2;

          spectatorData.push({
            position: new THREE.Vector3(x, baseY, z),
            rotationY,
            amplitude,
            speed,
            phase,
            rotAmplitude,
            rotSpeed,
            rotPhase,
          });

          spectatorDummy.position.set(x, baseY, z);
          spectatorDummy.rotation.set(0, rotationY, 0);
          spectatorDummy.updateMatrix();
          spectatorsMesh.setMatrixAt(instanceId, spectatorDummy.matrix);
          instanceId++;
        }

        remaining -= ringCount;
        ringIndex++;
      }

      scene.add(spectatorsMesh);
    }

    rebuildSpectators();

    window.addEventListener('keydown', (event) => {
      if (event.repeat) return;
      const activeTag = document.activeElement?.tagName?.toLowerCase();
      if (activeTag === 'input' || activeTag === 'textarea') return;

      const key = event.key.toLowerCase();
      if (handleMoveKey(key, true, event)) return;

      if (key === 'c') {
        const nextMode = params.camara === 'POV' ? 'Orbital' : 'POV';
        cameraController.setValue(nextMode);
        applyCameraMode(nextMode);
      } else if (key === 'p') {
        toggleAnimations();
      } else if (key === 'r') {
        rebuildSpectators();
        updateStatusText();
      }
    });

    window.addEventListener('keyup', (event) => {
      handleMoveKey(event.key.toLowerCase(), false, event);
    });

    function render() {
      requestAnimationFrame(render);
      const delta = clock.getDelta();
      const time = clock.elapsedTime;

      const stageConfig = stageProfiles[stageName] ?? stageProfiles.Presentación;
      const rhythmicPulse = (Math.sin(time * (1.1 + fightIntensity * 0.4)) + 1) * 0.12;
      const slowWave = (Math.sin(time * 0.35) + 1) * 0.08;
      const targetNoise = THREE.MathUtils.clamp(stageConfig.noise + rhythmicPulse + slowWave, 0.25, 1.05);
      crowdNoiseLevel = THREE.MathUtils.lerp(crowdNoiseLevel, targetNoise, 0.04);

      if (!params.pausarAnimaciones) {
        mixers.forEach((mixer) => mixer.update(delta));
        if (Math.random() < 0.02 + fightIntensity * 0.01) {
          spawnDustBurst();
        }
      }

      if (spectatorsMesh) {
        spectatorData.forEach((data, index) => {
          spectatorDummy.position.copy(data.position);
          const lift = data.amplitude * (0.6 + crowdNoiseLevel * 0.8);
          const sway = data.rotAmplitude * (0.6 + crowdNoiseLevel * 0.7);
          spectatorDummy.position.y = data.position.y + Math.sin(time * data.speed + data.phase) * lift;
          spectatorDummy.rotation.set(0, data.rotationY + Math.sin(time * data.rotSpeed + data.rotPhase) * sway, 0);
          spectatorDummy.updateMatrix();
          spectatorsMesh.setMatrixAt(index, spectatorDummy.matrix);
        });
        spectatorsMesh.instanceMatrix.needsUpdate = true;
      }

      updateLedPanels(crowdNoiseLevel, time);
      updateSmoke(delta, time);
      updateDust(delta);
      updatePovMovement(delta);
      updateAtmosphere(time);
      controls.update();
      renderPass.camera = activeCamera;
      composer.render();
    }

    render();
  </script>
</body>
</html>
