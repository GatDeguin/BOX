<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ring POV – Three.js</title>
  <link rel="icon" href="data:," />
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at 20% 20%, #0b0f1d 0%, #05060a 55%);
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 12px 18px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(6px);
      background: rgba(10, 12, 24, 0.75);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    header h1 {
      font-size: 1.1rem;
      letter-spacing: 0.02em;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      font-size: 0.8rem;
    }

    .tag span {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22d3ee;
      box-shadow: 0 0 10px rgba(34, 211, 238, 0.8);
    }

    main {
      flex: 1;
      position: relative;
    }

    .hud__lifebars {
      display: grid;
      gap: 8px;
      margin-bottom: 10px;
    }

    .lifebar {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .lifebar__label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      letter-spacing: 0.01em;
      color: #cbd5f5;
    }

    .lifebar__track {
      width: 100%;
      height: 14px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08);
      overflow: hidden;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    .lifebar__fill {
      height: 100%;
      border-radius: inherit;
      background: linear-gradient(90deg, #22d3ee, #10b981, #fbbf24);
      width: 100%;
      transition: width 0.25s ease;
    }

    canvas {
      width: 100%;
      height: calc(100vh - 66px);
      display: block;
    }

    #overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
      pointer-events: none;
    }

    .pill {
      padding: 6px 12px;
      background: rgba(17, 24, 39, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 999px;
      font-size: 0.8rem;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.35);
      pointer-events: auto;
    }

    .hud {
      position: absolute;
      left: 14px;
      bottom: 18px;
      padding: 10px 12px;
      background: rgba(15, 23, 42, 0.82);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      max-width: 260px;
      font-size: 0.9rem;
      line-height: 1.45;
      box-shadow: 0 15px 45px rgba(0, 0, 0, 0.45);
    }

    .hud__title {
      font-weight: 700;
      font-size: 0.95rem;
      margin-bottom: 6px;
      color: #cbd5f5;
      letter-spacing: 0.01em;
    }

    .hud ul {
      list-style: none;
      display: grid;
      gap: 6px;
      padding-left: 0;
    }

    .hud li {
      display: flex;
      gap: 6px;
      align-items: center;
      color: #d1d5db;
    }

    .hud strong {
      display: inline-flex;
      width: 28px;
      height: 28px;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
      font-weight: 700;
      color: #f8fafc;
    }
  </style>
</head>
<body>
  <header>
    <h1>Ring POV • Three.js</h1>
    <div class="tag"><span></span> Carga: Ring.glb + FBX</div>
  </header>
    <main>
      <div id="overlay"></div>
      <div class="hud">
        <div class="hud__lifebars">
          <div class="lifebar" id="player-bar">
            <div class="lifebar__label">Jugador</div>
            <div class="lifebar__track"><div class="lifebar__fill"></div></div>
          </div>
          <div class="lifebar" id="rival-bar">
            <div class="lifebar__label">Rival</div>
            <div class="lifebar__track"><div class="lifebar__fill"></div></div>
          </div>
        </div>
        <div class="hud__title">Controles rápidos</div>
        <ul>
          <li><strong>C</strong> • Cambiar POV / Orbital</li>
        <li><strong>P</strong> • Pausar / reanudar animaciones</li>
        <li><strong>R</strong> • Regenerar público</li>
        <li><strong>Click + WASD</strong> • Moverte en POV</li>
      </ul>
    </div>
    <canvas id="scene"></canvas>
  </main>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
    import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { FilmPass } from 'three/examples/jsm/postprocessing/FilmPass.js';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
    import { VignetteShader } from 'three/examples/jsm/shaders/VignetteShader.js';

    const canvas = document.getElementById('scene');
    const overlay = document.getElementById('overlay');
    const lifeBars = {
      player: document.querySelector('#player-bar .lifebar__fill'),
      rival: document.querySelector('#rival-bar .lifebar__fill'),
    };

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#030712');
    scene.fog = new THREE.FogExp2('#0b1b2f', 0.05);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.8));

    const povCamera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight - 66), 0.1, 100);
    povCamera.position.set(0, 1.9, 0.35);
    povCamera.lookAt(0, 1.7, -1);

    const orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight - 66), 0.1, 200);
    orbitCamera.position.set(6, 4.5, 6);
    orbitCamera.lookAt(0, 1, 0);

    let activeCamera = povCamera;
    const controls = new OrbitControls(orbitCamera, renderer.domElement);
    controls.enableDamping = true;
    controls.enabled = false;
    controls.target.set(0, 1, 0);

    const povControls = new PointerLockControls(povCamera, renderer.domElement);
    const povMoveState = { forward: false, backward: false, left: false, right: false };
    const POV_MOVE_SPEED = 3.8;

    function resetPovMovement() {
      povMoveState.forward = false;
      povMoveState.backward = false;
      povMoveState.left = false;
      povMoveState.right = false;
    }

    povControls.addEventListener('unlock', resetPovMovement);

    const hemiLight = new THREE.HemisphereLight('#dbeafe', '#0f172a', 0.35);
    hemiLight.position.set(0, 8, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight('#bcd7ff', 0.55);
    dirLight.position.set(4, 8, 2);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 30;
    dirLight.shadow.camera.left = -10;
    dirLight.shadow.camera.right = 10;
    dirLight.shadow.camera.top = 10;
    dirLight.shadow.camera.bottom = -10;
    scene.add(dirLight);

    const spotGroup = new THREE.Group();
    const rigLights = [];
    const rigBeamLights = [];
    const rigBeamEmitters = [];
    const rimLights = [];
    const fillLights = [];
    const backlights = [];
    let spectatorOuterRadius = 12;

    const ringRadius = 4.8;
    const spotCount = 8;
    for (let i = 0; i < spotCount; i++) {
      const angle = (i / spotCount) * Math.PI * 2 + Math.PI / spotCount;
      const position = new THREE.Vector3(
        Math.cos(angle) * ringRadius,
        8.4,
        Math.sin(angle) * ringRadius,
      );

      const spot = new THREE.SpotLight('#dff3ff', 3, 24, 0.4, 0.6, 1.4);
      spot.position.copy(position);
      spot.target.position.set(0, 1.2, 0);
      // Limitar los mapas de sombra para no saturar las unidades de textura.
      spot.castShadow = i < 4;
      spot.shadow.mapSize.set(1024, 1024);
      spot.shadow.bias = -0.0004;
      spot.penumbra = 0.7;
      spotGroup.add(spot);
      spotGroup.add(spot.target);
    }

    const keyLight = new THREE.SpotLight('#fff3d9', 3.8, 26, 0.48, 0.55, 1.3);
    keyLight.position.set(0.6, 9.4, 0.6);
    keyLight.target.position.set(0, 1.35, 0);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(1024, 1024);
    keyLight.shadow.bias = -0.00032;
    spotGroup.add(keyLight);
    spotGroup.add(keyLight.target);

    scene.add(spotGroup);

    const rimConfig = [
      { position: new THREE.Vector3(-6.5, 3.4, 0.6), target: new THREE.Vector3(0, 1.2, 0), color: '#e0f2fe' },
      { position: new THREE.Vector3(0.6, 3.6, 6.5), target: new THREE.Vector3(0, 1.1, 0), color: '#ffe4e6' },
    ];

    rimConfig.forEach(({ position, target, color }) => {
      const rim = new THREE.SpotLight(color, 1.4, 24, 0.7, 0.45, 1.8);
      rim.position.copy(position);
      rim.target.position.copy(target);
      rim.castShadow = false;
      rim.shadow.mapSize.set(1024, 1024);
      rim.shadow.bias = -0.00025;
      rim.penumbra = 0.5;
      rimLights.push(rim);
      scene.add(rim);
      scene.add(rim.target);
    });

    const skyFill = new THREE.SpotLight('#c7ddff', 0.6, 60, Math.PI / 2.2, 1, 2.2);
    skyFill.position.set(0, 13, 0);
    skyFill.target.position.set(0, -2, 0);
    skyFill.castShadow = false;
    fillLights.push(skyFill);
    scene.add(skyFill);
    scene.add(skyFill.target);

    const backlightGroup = new THREE.Group();
    const backlightCount = 8;
    const backlightBaseIntensity = 1.15;

    function updateBacklightPositions() {
      const radius = spectatorOuterRadius + 4.5;
      const height = 4.8;

      backlights.forEach((light, index) => {
        const angle = (index / backlightCount) * Math.PI * 2 + Math.PI / backlightCount;
        light.position.set(Math.cos(angle) * radius, height, Math.sin(angle) * radius);
        light.target.position.set(0, 2.4, 0);
      });
    }

    function refreshBacklightIntensity(enabled) {
      backlights.forEach((light) => {
        light.intensity = enabled ? light.userData.baseIntensity : 0;
      });
    }

    for (let i = 0; i < backlightCount; i++) {
      const rimColor = i % 2 === 0 ? '#b7d6ff' : '#d8e0ff';
      const backlight = new THREE.SpotLight(rimColor, backlightBaseIntensity, 70, 0.35, 0.5, 1.8);
      backlight.castShadow = false;
      backlight.penumbra = 0.65;
      backlight.shadow.bias = -0.0002;
      backlight.decay = 1.6;
      backlight.userData.baseIntensity = backlightBaseIntensity;
      backlights.push(backlight);
      backlightGroup.add(backlight);
      backlightGroup.add(backlight.target);
    }

    scene.add(backlightGroup);
    updateBacklightPositions();

    const rigGroup = new THREE.Group();
    const rigHeight = 8.6;
    const rigSize = 10;

    const trussMaterial = new THREE.MeshStandardMaterial({
      color: '#1f2937',
      metalness: 0.75,
      roughness: 0.32,
      emissive: '#0b1220',
      emissiveIntensity: 0.25,
    });

    const mainBeamGeo = new THREE.BoxGeometry(rigSize, 0.2, 0.2);
    const sideBeamGeo = new THREE.BoxGeometry(0.2, 0.2, rigSize);

    [
      { geometry: mainBeamGeo, position: new THREE.Vector3(0, rigHeight, rigSize / 2) },
      { geometry: mainBeamGeo, position: new THREE.Vector3(0, rigHeight, -rigSize / 2) },
      { geometry: sideBeamGeo, position: new THREE.Vector3(rigSize / 2, rigHeight, 0) },
      { geometry: sideBeamGeo, position: new THREE.Vector3(-rigSize / 2, rigHeight, 0) },
    ].forEach(({ geometry, position }) => {
      const beam = new THREE.Mesh(geometry, trussMaterial);
      beam.position.copy(position);
      beam.castShadow = false;
      beam.receiveShadow = true;
      rigGroup.add(beam);
    });

    const diagonalGeo = new THREE.BoxGeometry(0.16, 0.16, Math.sqrt(2) * rigSize);
    const diagonals = [
      { position: new THREE.Vector3(0, rigHeight - 0.3, 0), rotation: new THREE.Euler(0, Math.PI / 4, Math.PI / 2) },
      { position: new THREE.Vector3(0, rigHeight - 0.3, 0), rotation: new THREE.Euler(0, -Math.PI / 4, Math.PI / 2) },
    ];

    diagonals.forEach(({ position, rotation }) => {
      const brace = new THREE.Mesh(diagonalGeo, trussMaterial.clone());
      brace.position.copy(position);
      brace.rotation.copy(rotation);
      brace.castShadow = false;
      brace.receiveShadow = true;
      rigGroup.add(brace);
    });

    const reflectorConfig = [
      { position: new THREE.Vector3(4.2, rigHeight - 0.1, 4.2), target: new THREE.Vector3(1.2, 1.3, 1.2), angle: 0.45 },
      { position: new THREE.Vector3(-4.2, rigHeight - 0.1, 4.2), target: new THREE.Vector3(-1.2, 1.3, 1.2), angle: 0.45 },
      { position: new THREE.Vector3(4.2, rigHeight - 0.1, -4.2), target: new THREE.Vector3(1.2, 1.3, -1.2), angle: 0.45 },
      { position: new THREE.Vector3(-4.2, rigHeight - 0.1, -4.2), target: new THREE.Vector3(-1.2, 1.3, -1.2), angle: 0.45 },
      { position: new THREE.Vector3(0, rigHeight - 0.2, 0), target: new THREE.Vector3(0, 1, 0), angle: 0.35 },
    ];

    reflectorConfig.forEach(({ position, target, angle }, index) => {
      const color = index === reflectorConfig.length - 1 ? '#fcd34d' : '#dbeafe';
      const reflector = new THREE.SpotLight(color, 2.2, 28, angle, 0.5, 1.1);
      reflector.position.copy(position);
      reflector.target.position.copy(target);
      reflector.castShadow = false;
      reflector.shadow.mapSize.set(1024, 1024);
      reflector.shadow.bias = -0.00035;
      reflector.penumbra = 0.55;
      rigLights.push(reflector);
      rigGroup.add(reflector);
      rigGroup.add(reflector.target);
    });

    const rigFill = new THREE.PointLight('#7dd3fc', 0.4, 30, 1.5);
    rigFill.position.set(0, rigHeight + 0.3, 0);
    rigGroup.add(rigFill);
    rigLights.push(rigFill);

    const beamEmitterGeometry = new THREE.CylinderGeometry(0.06, 0.1, 0.32, 12);
    const baseEmitterIntensity = 2.3;
    const beamEmitterMaterial = new THREE.MeshStandardMaterial({
      color: '#e0f2fe',
      emissive: '#38bdf8',
      emissiveIntensity: baseEmitterIntensity,
      metalness: 0.42,
      roughness: 0.2,
    });

    const rigBeamOffsets = [-rigSize / 2 + 1.2, 0, rigSize / 2 - 1.2];
    const rigBeamDistance = rigSize / 2;
    const beamLightIntensity = 1.45;

    rigBeamOffsets.forEach((offset) => {
      const positions = [
        new THREE.Vector3(offset, rigHeight - 0.15, rigBeamDistance),
        new THREE.Vector3(offset, rigHeight - 0.15, -rigBeamDistance),
        new THREE.Vector3(rigBeamDistance, rigHeight - 0.15, offset),
        new THREE.Vector3(-rigBeamDistance, rigHeight - 0.15, offset),
      ];

      positions.forEach((position) => {
        const emitter = new THREE.Mesh(beamEmitterGeometry, beamEmitterMaterial.clone());
        emitter.position.copy(position);
        emitter.castShadow = false;
        emitter.receiveShadow = false;
        emitter.material.userData.baseEmissiveIntensity = baseEmitterIntensity;
        rigBeamEmitters.push(emitter);
        rigGroup.add(emitter);

        const beamLight = new THREE.PointLight('#8bd1ff', beamLightIntensity, 28, 2);
        beamLight.position.copy(position).add(new THREE.Vector3(0, -0.08, 0));
        beamLight.castShadow = false;
        beamLight.decay = 1.7;
        beamLight.userData.baseIntensity = beamLightIntensity;
        rigBeamLights.push(beamLight);
        rigGroup.add(beamLight);
      });
    });

    scene.add(rigGroup);

    function refreshRigBeamLights(enabled) {
      rigBeamLights.forEach((light) => {
        light.intensity = enabled ? light.userData.baseIntensity : 0;
      });

      rigBeamEmitters.forEach((mesh) => {
        const base = mesh.material.userData.baseEmissiveIntensity ?? baseEmitterIntensity;
        mesh.material.emissiveIntensity = enabled ? base : 0.05;
      });
    }

    const ambient = new THREE.AmbientLight('#a5b4fc', 0.16);
    scene.add(ambient);

    const ledPanels = [];
    const jumbotrons = [];
    const ledPanelGeometry = new THREE.BoxGeometry(2.6, 1.2, 0.08);
    const ledBaseColor = new THREE.Color('#0ea5e9');

    const fxGroup = new THREE.Group();
    scene.add(fxGroup);

    const edgeStripMaterial = new THREE.MeshStandardMaterial({
      color: '#0a0f1f',
      emissive: '#38bdf8',
      emissiveIntensity: 1.3,
      roughness: 0.38,
      metalness: 0.12,
      transparent: true,
      opacity: 0.9,
    });

    const edgeStripGeometry = new THREE.BoxGeometry(6.8, 0.06, 0.16);
    const edgeStripPositions = [
      new THREE.Vector3(0, 0.14, 3.4),
      new THREE.Vector3(0, 0.14, -3.4),
      new THREE.Vector3(3.4, 0.14, 0),
      new THREE.Vector3(-3.4, 0.14, 0),
    ];

    edgeStripPositions.forEach((pos, idx) => {
      const strip = new THREE.Mesh(edgeStripGeometry, edgeStripMaterial.clone());
      strip.position.copy(pos);
      if (idx >= 2) {
        strip.rotation.y = Math.PI / 2;
      }
      strip.castShadow = false;
      strip.receiveShadow = true;
      fxGroup.add(strip);
    });

    const ledPositions = [
      { position: new THREE.Vector3(0, 0.7, 9.5), rotation: new THREE.Euler(0, 0, 0) },
      { position: new THREE.Vector3(0, 0.7, -9.5), rotation: new THREE.Euler(0, Math.PI, 0) },
      { position: new THREE.Vector3(9.5, 0.7, 0), rotation: new THREE.Euler(0, -Math.PI / 2, 0) },
      { position: new THREE.Vector3(-9.5, 0.7, 0), rotation: new THREE.Euler(0, Math.PI / 2, 0) },
    ];

    ledPositions.forEach(({ position, rotation }) => {
      const material = new THREE.MeshStandardMaterial({
        color: '#0f172a',
        emissive: ledBaseColor.clone(),
        emissiveIntensity: 1.5,
        metalness: 0.45,
        roughness: 0.35,
      });
      const panel = new THREE.Mesh(ledPanelGeometry, material);
      panel.position.copy(position);
      panel.rotation.copy(rotation);
      panel.castShadow = false;
      panel.receiveShadow = true;
      ledPanels.push(panel);
      scene.add(panel);
    });

    const jumbotronGeometry = new THREE.PlaneGeometry(4.6, 2.5);
    const jumbotronMaterial = new THREE.MeshStandardMaterial({
      color: '#0b1020',
      emissive: '#1d4ed8',
      emissiveIntensity: 4,
      roughness: 0.4,
      metalness: 0.18,
      side: THREE.DoubleSide,
    });

    const jumbotronPositions = [
      { position: new THREE.Vector3(0, 3.4, 12.4), rotation: new THREE.Euler(0, Math.PI, 0) },
      { position: new THREE.Vector3(-12.4, 3.1, 0), rotation: new THREE.Euler(0, Math.PI / 2, 0) },
    ];

    jumbotronPositions.forEach(({ position, rotation }) => {
      const screen = new THREE.Mesh(jumbotronGeometry, jumbotronMaterial.clone());
      screen.position.copy(position);
      screen.rotation.copy(rotation);
      screen.receiveShadow = false;
      screen.castShadow = false;
      jumbotrons.push(screen);
      scene.add(screen);
    });

    const cornerLights = [
      new THREE.Vector3(3.2, 1.7, 3.2),
      new THREE.Vector3(3.2, 1.7, -3.2),
      new THREE.Vector3(-3.2, 1.7, 3.2),
      new THREE.Vector3(-3.2, 1.7, -3.2),
    ];

    cornerLights.forEach((position) => {
      const point = new THREE.PointLight('#ffb37a', 0.6, 4.5, 1.8);
      point.position.copy(position);
      point.castShadow = false;
      scene.add(point);
    });

    const mixers = new Set();
    const loaderManager = new THREE.LoadingManager();

    const gltfLoader = new GLTFLoader(loaderManager);
    const fbxLoader = new FBXLoader(loaderManager);
    const objLoader = new OBJLoader(loaderManager);
    const textureLoader = new THREE.TextureLoader(loaderManager);

    const fighters = {
      tyson: {
        label: 'Tyson',
        url: 'modelos/Tyson.fbx',
        scale: 1,
        textures: {
          map: { url: 'texturas/Tyson.jpeg', flipY: false, colorSpace: THREE.SRGBColorSpace },
        },
      },
      principal: { label: 'Principal', url: 'modelos/Principal.fbx', scale: 0.01 },
      mma: { label: 'MMA', url: 'modelos/MMA.fbx', scale: 0.0095 },
      bodybuilder: { label: 'Bodybuilder', url: 'modelos/Bodybuilder.fbx', scale: 0.0105 },
    };

    const gloveConfig = {
      url: 'modelos/Guantes_Amateur.obj',
      scale: 0.01,
      baseRotation: new THREE.Euler(-Math.PI / 2, Math.PI, 0),
      offset: new THREE.Vector3(0, 0, -0.08),
      textures: {
        map: { url: 'texturas/Boxing_Gloves_Leather_Tan.jpg', colorSpace: THREE.SRGBColorSpace },
        normalMap: { url: 'texturas/Boxing_Gloves_BUMP.jpg', colorSpace: THREE.NoColorSpace },
      },
    };

    let glovePrototype = null;
    const playerGloves = { left: null, right: null };

    const animationLibrary = {
      idle: { url: 'animaciones/descanso/Action Idle To Fight Idle.fbx', loop: THREE.LoopRepeat },
      rest: { url: 'animaciones/descanso/Arm Stretching.fbx', loop: THREE.LoopRepeat },
      attackLight: { url: 'animaciones/ataque/Lead Jab.fbx', loop: THREE.LoopOnce, damage: 8 },
      attackHeavy: { url: 'animaciones/ataque/Hook.fbx', loop: THREE.LoopOnce, damage: 12 },
      attackCombo: { url: 'animaciones/ataque/Jab Cross.fbx', loop: THREE.LoopOnce, damage: 16 },
      attackElbow: { url: 'animaciones/ataque/Illegal Elbow Punch.fbx', loop: THREE.LoopOnce, damage: 18 },
      defend: { url: 'animaciones/defensa/Left Block.fbx', loop: THREE.LoopRepeat },
      dodge: { url: 'animaciones/defensa/Dodging.fbx', loop: THREE.LoopRepeat },
      walk: { url: 'animaciones/movimiento/Walking.fbx', loop: THREE.LoopRepeat },
      walkBack: { url: 'animaciones/movimiento/Walk back.fbx', loop: THREE.LoopRepeat },
      damage: { url: 'animaciones/daño/Light Hit To Head.fbx', loop: THREE.LoopOnce },
      fall: { url: 'animaciones/daño/caida/Fall Over.fbx', loop: THREE.LoopOnce },
      getup: { url: 'animaciones/daño/caida/Getting Up.fbx', loop: THREE.LoopOnce },
    };

    const animationCache = new Map();
    const fighterStates = {
      player: { health: 100, maxHealth: 100, mode: 'Presentación', blocking: false, dodging: false, down: false, aiTimer: null, activeAction: null, knockdowns: 0, countdownTimer: null },
      rival: { health: 100, maxHealth: 100, mode: 'Presentación', blocking: false, dodging: false, down: false, aiTimer: null, activeAction: null, knockdowns: 0, countdownTimer: null },
    };

    const fighterSlots = {
      player: {
        position: new THREE.Vector3(2.2, 0, 2.2),
        target: 'rival',
        current: 'principal',
        model: null,
        mixer: null,
        requestId: 0,
        scale: null,
      },
      rival: {
        position: new THREE.Vector3(-2.2, 0, -2.2),
        target: 'player',
        current: 'tyson',
        model: null,
        mixer: null,
        requestId: 0,
        scale: null,
      },
    };

    Object.entries(fighterSlots).forEach(([slotKey, slot]) => {
      const fighter = fighters[slot.current];
      slot.scale = fighter?.scale ?? 0.01;
    });

    const stageProfiles = {
      Presentación: {
        intensity: 0.35,
        noise: 0.45,
        ledColor: '#22d3ee',
        audio: 'sonidos/publico_intro.wav',
        crowdVisibility: 0.35,
        ringFocus: 1.25,
      },
      Combate: {
        intensity: 0.72,
        noise: 0.75,
        ledColor: '#f472b6',
        audio: 'sonidos/publico_enojado.wav',
        crowdVisibility: 0.9,
        ringFocus: 1,
      },
      Clímax: {
        intensity: 1,
        noise: 1,
        ledColor: '#f97316',
        audio: 'sonidos/publico_victoria.wav',
        crowdVisibility: 1.05,
        ringFocus: 1.1,
      },
    };

    let fightIntensity = stageProfiles.Presentación.intensity;
    let crowdNoiseLevel = stageProfiles.Presentación.noise;
    let stageName = 'Presentación';
    let fightEnded = false;

    function setShadows(object) {
      object.traverse?.((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
    }

    const textureCache = new Map();
    const NON_COLOR_SPACE = THREE.NoColorSpace || THREE.LinearSRGBColorSpace || THREE.SRGBColorSpace;

    function loadTexture(config) {
      if (!config?.url) return null;
      const key = JSON.stringify(config);
      if (textureCache.has(key)) return textureCache.get(key);
      const tex = textureLoader.load(config.url);
      tex.flipY = config.flipY ?? false;
      tex.colorSpace = config.colorSpace ?? (config.slot === 'map' ? THREE.SRGBColorSpace : NON_COLOR_SPACE);
      textureCache.set(key, tex);
      return tex;
    }

    function buildTextureSet(config = {}) {
      const set = {};
      Object.entries(config).forEach(([slot, conf]) => {
        if (!conf || slot.startsWith('__')) return;
        const opts = typeof conf === 'string' ? { url: conf } : conf;
        set[slot] = loadTexture({ ...opts, slot });
      });
      return set;
    }

    function applyTexturesToMaterial(material, textureSet) {
      if (!material || !textureSet) return;
      const apply = (mat) => {
        if (!mat) return;
        Object.entries(textureSet).forEach(([slot, tex]) => {
          if (!tex) return;
          if (!mat[slot]) {
            mat[slot] = tex;
          }
        });
        mat.needsUpdate = true;
      };
      if (Array.isArray(material)) material.forEach(apply);
      else apply(material);
    }

    function applyFighterTextures(model, fighterConfig) {
      if (!model || !fighterConfig?.textures) return;
      const textureSet = buildTextureSet(fighterConfig.textures);
      model.traverse?.((child) => {
        if (child.isMesh) {
          applyTexturesToMaterial(child.material, textureSet);
        }
      });
    }

    function findHandBone(model, side) {
      if (!model) return null;
      const target = side === 'left' ? 'lefthand' : 'righthand';
      let found = null;
      model.traverse((child) => {
        if (found || !child.isBone) return;
        const name = child.name?.toLowerCase?.() ?? '';
        if (name.includes(target)) {
          found = child;
        }
      });
      return found;
    }

    function disposePlayerGloves() {
      ['left', 'right'].forEach((side) => {
        const glove = playerGloves[side];
        if (glove?.parent) glove.parent.remove(glove);
        playerGloves[side] = null;
      });
    }

    async function ensureGlovePrototype() {
      if (glovePrototype) return glovePrototype;
      try {
        const glove = await objLoader.loadAsync(gloveConfig.url);
        const textureSet = buildTextureSet(gloveConfig.textures);
        glove.traverse?.((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            applyTexturesToMaterial(child.material, textureSet);
          }
        });
        const bbox = new THREE.Box3().setFromObject(glove);
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        glove.position.sub(center);
        glove.updateMatrixWorld(true);
        glovePrototype = glove;
        return glovePrototype;
      } catch (err) {
        console.warn('No se pudieron cargar los guantes', err);
        return null;
      }
    }

    function createGloveInstance(side) {
      if (!glovePrototype) return null;
      const instance = glovePrototype.clone(true);
      instance.traverse?.((child) => {
        if (child.isMesh) {
          if (Array.isArray(child.material)) {
            child.material = child.material.map((mat) => mat?.clone?.() ?? mat);
          } else if (child.material?.clone) {
            child.material = child.material.clone();
          }
        }
      });
      instance.scale.setScalar(gloveConfig.scale);
      const rotation = new THREE.Quaternion().setFromEuler(gloveConfig.baseRotation);
      if (side === 'left') {
        rotation.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, Math.PI, 0)));
      }
      instance.quaternion.copy(rotation);
      const offset = gloveConfig.offset.clone();
      if (side === 'left') offset.x *= -1;
      instance.position.copy(offset);
      return instance;
    }

    async function attachGlovesToPlayer(model) {
      disposePlayerGloves();
      if (!model) return;
      const prototype = await ensureGlovePrototype();
      if (!prototype) return;
      const leftHand = findHandBone(model, 'left');
      const rightHand = findHandBone(model, 'right');
      if (leftHand) {
        const glove = createGloveInstance('left');
        leftHand.add(glove);
        playerGloves.left = glove;
      }
      if (rightHand) {
        const glove = createGloveInstance('right');
        rightHand.add(glove);
        playerGloves.right = glove;
      }
    }

    async function loadRing() {
      const candidates = ['modelos/Ring.glb', 'modelos/Ring 2.glb', 'modelos/Ring 3.glb'];

      for (const url of candidates) {
        try {
          const gltf = await gltfLoader.loadAsync(url);
          const ring = gltf.scene;
          ring.name = 'RingBase';
          ring.rotation.y = Math.PI / 2;
          setShadows(ring);
          scene.add(ring);
          return;
        } catch (err) {
          console.warn('No se pudo cargar', url, err.message);
        }
      }

      console.warn('No se encontró ningún modelo de ring en las rutas esperadas');
    }

    async function loadFighter(url, position, target, scale = 0.01) {
      try {
        const model = await fbxLoader.loadAsync(url);
        model.scale.setScalar(scale);
        model.position.copy(position);
        if (target) {
          const lookTarget = target.clone();
          lookTarget.y = position.y;
          model.lookAt(lookTarget);
        }
        setShadows(model);

        const mixer = new THREE.AnimationMixer(model);
        if (model.animations?.length) {
          model.animations.forEach((clip) => mixer.clipAction(clip).play());
        }

        return { model, mixer };
      } catch (err) {
        console.warn('No se pudo cargar', url, err.message);
        return null;
      }
    }

    function disposeModel(model) {
      model.traverse?.((child) => {
        if (!child.isMesh) return;
        child.geometry?.dispose?.();
        const materials = Array.isArray(child.material) ? child.material : [child.material];
        materials.forEach((material) => material?.dispose?.());
      });
    }

    function getSlotTarget(slotKey) {
      const slot = fighterSlots[slotKey];
      if (!slot) return null;

      if (slot.target === 'player') {
        return fighterSlots.player?.position;
      }

      if (slot.target === 'rival') {
        return fighterSlots.rival?.position;
      }

      return new THREE.Vector3();
    }

    async function setFighter(slotKey, fighterKey) {
      const slot = fighterSlots[slotKey];
      const fighter = fighters[fighterKey];
      if (!slot || !fighter) return;

      slot.scale = fighter.scale ?? slot.scale ?? 0.01;

      const targetPosition = getSlotTarget(slotKey);

      slot.requestId += 1;
      const requestId = slot.requestId;

      const loaded = await loadFighter(fighter.url, slot.position, targetPosition, slot.scale);
      if (!loaded || requestId !== slot.requestId) {
        loaded?.model && disposeModel(loaded.model);
        return;
      }

      if (slot.model) {
        scene.remove(slot.model);
        disposeModel(slot.model);
        if (slotKey === 'player') disposePlayerGloves();
      }

      if (slot.mixer) {
        mixers.delete(slot.mixer);
      }

      slot.current = fighterKey;
      slot.model = loaded.model;
      slot.mixer = loaded.mixer;
      applyFighterTextures(slot.model, fighter);
      scene.add(loaded.model);
      if (loaded.mixer) {
        mixers.add(loaded.mixer);
      }

      if (slotKey === 'player') {
        attachGlovesToPlayer(slot.model);
      }

      applyPosition(slotKey);
      faceTarget(slotKey, slotKey === 'player' ? 'rival' : 'player');

      if (!slot.animations) slot.animations = {};
      preloadCoreAnimations(slotKey);
      resetFighterState(slotKey);

      if (slotKey === 'player' && playerScaleController) {
        params.escalaJugador = slot.scale;
        playerScaleController.setValue(slot.scale);
      }

      if (slotKey === 'rival' && rivalScaleController) {
        params.escalaRival = slot.scale;
        rivalScaleController.setValue(slot.scale);
      }
    }

    function resetFighterState(slotKey) {
      const state = fighterStates[slotKey];
      if (!state) return;
      state.health = state.maxHealth;
      state.blocking = false;
      state.dodging = false;
      state.down = false;
      state.knockdowns = 0;
      if (state.countdownTimer) {
        clearTimeout(state.countdownTimer);
        state.countdownTimer = null;
      }
      state.activeAction = null;
      updateLifeBar(slotKey);
    }

    function updateLifeBar(slotKey) {
      const state = fighterStates[slotKey];
      const bar = lifeBars[slotKey];
      if (!state || !bar) return;
      const pct = Math.max(0, Math.min(1, state.health / state.maxHealth));
      bar.style.width = `${pct * 100}%`;
    }

    const ringMovementLimit = ringRadius - 1.2;

    function clampToRingBounds(position) {
      const clamped = position.clone();
      const flatDistance = Math.hypot(clamped.x, clamped.z);
      if (flatDistance > ringMovementLimit) {
        const factor = ringMovementLimit / flatDistance;
        clamped.x *= factor;
        clamped.z *= factor;
      }
      return clamped;
    }

    function faceTarget(slotKey, targetKey) {
      const slot = fighterSlots[slotKey];
      const targetSlot = fighterSlots[targetKey];
      if (!slot?.model || !targetSlot?.position) return;
      const lookTarget = targetSlot.position.clone();
      lookTarget.y = slot.position.y;
      slot.model.lookAt(lookTarget);
    }

    function applyPosition(slotKey) {
      const slot = fighterSlots[slotKey];
      if (!slot?.model) return;
      slot.model.position.copy(slot.position);
    }

    function moveFighter(slotKey, direction, distance) {
      const slot = fighterSlots[slotKey];
      if (!slot) return;
      const movement = direction.clone().setY(0).normalize().multiplyScalar(distance);
      const nextPosition = clampToRingBounds(slot.position.clone().add(movement));
      nextPosition.y = slot.position.y;
      slot.position.copy(nextPosition);
      applyPosition(slotKey);
    }

    function getHorizontalDistance(slotA, slotB) {
      if (!slotA?.position || !slotB?.position) return Infinity;
      return Math.hypot(slotA.position.x - slotB.position.x, slotA.position.z - slotB.position.z);
    }

    function directionToTarget(slotKey, targetKey) {
      const slot = fighterSlots[slotKey];
      const target = fighterSlots[targetKey];
      if (!slot?.position || !target?.position) return new THREE.Vector3(1, 0, 0);
      return target.position.clone().sub(slot.position).setY(0).normalize();
    }

    const aiBehavior = {
      minRange: 1.05,
      idealRange: 1.5,
      maxRange: 2,
      approachStep: 0.7,
      retreatStep: 0.6,
    };

    async function adjustDistanceForAttack(slotKey, targetKey) {
      const slot = fighterSlots[slotKey];
      const target = fighterSlots[targetKey];
      if (!slot || !target) return 'idle';
      const distance = getHorizontalDistance(slot, target);
      const direction = directionToTarget(slotKey, targetKey);

      if (distance > aiBehavior.maxRange) {
        await playAnimation(slotKey, 'walk', true);
        moveFighter(slotKey, direction, Math.min(aiBehavior.approachStep, distance - aiBehavior.idealRange));
        faceTarget(slotKey, targetKey);
        return 'approach';
      }

      if (distance < aiBehavior.minRange) {
        await playAnimation(slotKey, 'walkBack', true);
        moveFighter(slotKey, direction.multiplyScalar(-1), Math.min(aiBehavior.retreatStep, aiBehavior.minRange - distance + 0.25));
        faceTarget(slotKey, targetKey);
        return 'retreat';
      }

      return 'ready';
    }

    async function loadClip(key) {
      const config = animationLibrary[key];
      if (!config) return null;
      if (animationCache.has(config.url)) return animationCache.get(config.url);

      try {
        const asset = await fbxLoader.loadAsync(config.url);
        const clip = asset.animations?.[0] ?? null;
        if (clip) {
          clip.resetDuration?.();
          animationCache.set(config.url, clip);
          return clip;
        }
      } catch (err) {
        console.warn('No se pudo cargar la animación', config.url, err.message);
      }

      return null;
    }

    async function preloadCoreAnimations(slotKey) {
      const slot = fighterSlots[slotKey];
      if (!slot) return;
      const keys = ['idle', 'rest', 'walk', 'walkBack', 'attackLight', 'attackHeavy', 'attackCombo', 'attackElbow', 'defend', 'dodge', 'damage', 'fall', 'getup'];
      keys.forEach((key) => loadClip(key));
      // Play a neutral idle to keep the mixer alive.
      playAnimation(slotKey, 'idle', true);
    }

    async function playAnimation(slotKey, key, fade = false) {
      const slot = fighterSlots[slotKey];
      if (!slot?.mixer) return null;
      const config = animationLibrary[key];
      const clip = await loadClip(key);
      if (!config || !clip) return null;

      slot.mixer.stopAllAction();
      const action = slot.mixer.clipAction(clip);
      action.loop = config.loop ?? THREE.LoopRepeat;
      action.clampWhenFinished = config.loop === THREE.LoopOnce;
      action.reset();
      if (fade) {
        action.fadeIn(0.2).play();
      } else {
        action.play();
      }
      return { action, config, clip };
    }

    const PARAM_STORAGE_KEY = 'ring_pov_gui_params';

    const params = {
      camara: 'POV',
      rival: 'tyson',
      escalaJugador: fighterSlots.player.scale,
      escalaRival: fighterSlots.rival.scale,
      alturaJugador: fighterSlots.player.position.y,
      alturaRival: fighterSlots.rival.position.y,
      pausarAnimaciones: false,
      luzDireccional: dirLight.intensity,
      hemi: hemiLight.intensity,
      espectadores: 1200,
      niebla: scene.fog.density,
      bloom: 1.2,
      bloomUmbral: 0.82,
      etapa: stageName,
      contraluz: true,
      lucesViga: true,
    };

    function loadStoredParams() {
      try {
        const raw = localStorage.getItem(PARAM_STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (err) {
        console.warn('No se pudo cargar la configuración previa', err);
        return null;
      }
    }

    function persistParams() {
      try {
        localStorage.setItem(PARAM_STORAGE_KEY, JSON.stringify(params));
        status.textContent = 'Configuración guardada ✔';
        setTimeout(updateStatusText, 1500);
      } catch (err) {
        console.warn('No se pudo guardar la configuración', err);
      }
    }

    fighterSlots.rival.current = params.rival;

    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, activeCamera);
    const unrealBloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), params.bloom, 0.9, params.bloomUmbral);
    unrealBloomPass.threshold = params.bloomUmbral;
    unrealBloomPass.strength = params.bloom;
    const filmPass = new FilmPass(0.22, 0.35, 648, false);
    const vignettePass = new ShaderPass(VignetteShader);
    vignettePass.uniforms['offset'].value = 1.1;
    vignettePass.uniforms['darkness'].value = 1.3;
    composer.addPass(renderPass);
    composer.addPass(unrealBloomPass);
    composer.addPass(filmPass);
    composer.addPass(vignettePass);

    function resize() {
      const width = window.innerWidth;
      const height = window.innerHeight - 66;
      renderer.setSize(width, height, false);
      composer.setSize(width, height);
      unrealBloomPass.setSize(width, height);
      [povCamera, orbitCamera].forEach((cam) => {
        cam.aspect = width / height;
        cam.updateProjectionMatrix();
      });
    }

    window.addEventListener('resize', resize);
    resize();

    const gui = new GUI({ width: 320, container: overlay });
    gui.domElement.style.pointerEvents = 'auto';
    const controllers = {};

    const saveButton = document.createElement('button');
    saveButton.textContent = 'Guardar configuración';
    saveButton.className = 'pill';
    saveButton.style.alignSelf = 'stretch';
    saveButton.addEventListener('click', persistParams);
    overlay.appendChild(saveButton);

    const rivalOptions = {
      Tyson: 'tyson',
      Principal: 'principal',
      MMA: 'mma',
      Bodybuilder: 'bodybuilder',
    };

    function applyCameraMode(mode) {
      params.camara = mode;
      const useOrbit = mode === 'Orbital';
      controls.enabled = useOrbit;
      activeCamera = useOrbit ? orbitCamera : povCamera;
      renderPass.camera = activeCamera;
      attachListener(activeCamera);
      if (!useOrbit) {
        povCamera.position.set(0, 1.9, 0.35);
        povCamera.lookAt(0, 1.7, -1);
        povControls.getObject().position.copy(povCamera.position);
        povControls.getObject().rotation.copy(povCamera.rotation);
      } else {
        povControls.unlock();
        resetPovMovement();
      }
      updateStatusText();
    }

    function toggleAnimations() {
      params.pausarAnimaciones = !params.pausarAnimaciones;
      pauseController.setValue(params.pausarAnimaciones);
      updateStatusText();
    }

    const cameraController = gui.add(params, 'camara', ['POV', 'Orbital']).name('Modo de cámara').onChange(applyCameraMode);
    controllers.camara = cameraController;

    let playerScaleController = null;
    let rivalScaleController = null;

    const rivalController = gui
      .add(params, 'rival', rivalOptions)
      .name('Rival')
      .onChange((value) => {
        setFighter('rival', value);
        updateStatusText();
      });
    controllers.rival = rivalController;

    playerScaleController = gui
      .add(params, 'escalaJugador', 0.005, 2, 0.001)
      .name('Escala jugador')
      .onChange((value) => {
        fighterSlots.player.scale = value;
        fighterSlots.player.model?.scale.setScalar(value);
      });
    controllers.escalaJugador = playerScaleController;

    controllers.alturaJugador = gui
      .add(params, 'alturaJugador', -1, 2, 0.01)
      .name('Altura jugador (Y)')
      .onChange((value) => {
        fighterSlots.player.position.y = value;
        applyPosition('player');
      });

    rivalScaleController = gui
      .add(params, 'escalaRival', 0.005, 2, 0.001)
      .name('Escala rival')
      .onChange((value) => {
        fighterSlots.rival.scale = value;
        fighterSlots.rival.model?.scale.setScalar(value);
      });
    controllers.escalaRival = rivalScaleController;

    controllers.alturaRival = gui
      .add(params, 'alturaRival', -1, 2, 0.01)
      .name('Altura rival (Y)')
      .onChange((value) => {
        fighterSlots.rival.position.y = value;
        applyPosition('rival');
      });

    const pauseController = gui.add(params, 'pausarAnimaciones').name('Pausar animaciones').onChange(() => {
      params.pausarAnimaciones = !!params.pausarAnimaciones;
      if (params.pausarAnimaciones) {
        clearAi('player');
        clearAi('rival');
      } else if (stageName === 'Combate') {
        scheduleAi('player');
        scheduleAi('rival');
      }
      updateStatusText();
    });
    controllers.etapa = gui.add(params, 'etapa', Object.keys(stageProfiles)).name('Etapa de pelea').onChange((value) => setStage(value));
    controllers.luzDireccional = gui.add(params, 'luzDireccional', 0, 2, 0.05).name('Luz direccional').onChange((v) => dirLight.intensity = v);
    controllers.hemi = gui.add(params, 'hemi', 0, 1.5, 0.05).name('Luz ambiente').onChange((v) => hemiLight.intensity = v);
    controllers.niebla = gui.add(params, 'niebla', 0, 0.25, 0.005).name('Densidad niebla').onChange((v) => scene.fog.density = v);
    controllers.bloomUmbral = gui.add(params, 'bloomUmbral', 0.4, 1.5, 0.01).name('Umbral bloom').onChange((v) => unrealBloomPass.threshold = v);
    controllers.bloom = gui.add(params, 'bloom', 0, 3, 0.05).name('Intensidad bloom').onChange((v) => unrealBloomPass.strength = v);
    controllers.contraluz = gui.add(params, 'contraluz').name('Contraluz público').onChange((value) => refreshBacklightIntensity(value));
    controllers.lucesViga = gui.add(params, 'lucesViga').name('Luces vigas superiores').onChange((value) => refreshRigBeamLights(value));
    controllers.espectadores = gui.add(params, 'espectadores', 400, 4000, 50).name('Espectadores').onChange(() => {
      rebuildSpectators();
      updateStatusText();
    });

    let status = document.createElement('div');
    status.className = 'pill';
    status.textContent = 'Cargando modelos…';
    overlay.appendChild(status);

    function applyStoredParams(saved) {
      if (!saved) return;
      if (saved.camara && saved.camara !== params.camara) {
        cameraController.setValue(saved.camara);
      }
      if (saved.rival) {
        rivalController.setValue(saved.rival);
      }
      ['escalaJugador', 'escalaRival', 'alturaJugador', 'alturaRival', 'luzDireccional', 'hemi', 'niebla', 'bloomUmbral', 'bloom',
        'espectadores'].forEach((key) => {
        if (typeof saved[key] === 'number' && params[key] !== saved[key]) {
          controllers[key]?.setValue(saved[key]);
        }
      });
      if (typeof saved.pausarAnimaciones === 'boolean') {
        pauseController.setValue(saved.pausarAnimaciones);
      }
      if (typeof saved.contraluz === 'boolean') {
        controllers.contraluz?.setValue(saved.contraluz);
      }
      if (typeof saved.lucesViga === 'boolean') {
        controllers.lucesViga?.setValue(saved.lucesViga);
      }
      if (saved.etapa && saved.etapa !== params.etapa) {
        setStage(saved.etapa);
        controllers.etapa?.setValue(saved.etapa);
      }
    }

    function updateStatusText() {
      const rivalLabel = fighters[params.rival]?.label ?? params.rival;
      status.textContent = `Listo • ${params.camara} • ${stageName} • Rival: ${rivalLabel} • Animaciones: ${params.pausarAnimaciones ? 'Pausadas' : 'Activas'} • ${params.espectadores} espectadores`;
    }

    Promise.all([
      loadRing(),
      setFighter('player', fighterSlots.player.current),
      setFighter('rival', params.rival),
    ]).finally(() => {
      const saved = loadStoredParams();
      applyStoredParams(saved);
      applyPresentationMode();
      updateStatusText();
    });

    const clock = new THREE.Clock();

    const spectatorGeometry = new THREE.CapsuleGeometry(0.12, 0.35, 8, 16);
    const spectatorMaterial = new THREE.MeshStandardMaterial({
      color: '#111827',
      roughness: 0.65,
      metalness: 0.05,
      vertexColors: true,
    });

    const phoneGeometry = new THREE.PlaneGeometry(0.08, 0.14);
    const phoneMaterial = new THREE.MeshStandardMaterial({
      color: '#9ddcff',
      emissive: '#bde5ff',
      emissiveIntensity: 4,
      transparent: true,
      opacity: 0.95,
      side: THREE.DoubleSide,
      roughness: 0.35,
      metalness: 0.05,
    });
    let phoneMesh = null;
    let phoneHolders = [];
    const phoneDummy = new THREE.Object3D();

    const crowdClusters = [
      { center: -Math.PI * 0.8, width: Math.PI / 2.4, hueShift: -0.06, luminosity: 0.72, saturation: 0.75 },
      { center: -Math.PI * 0.25, width: Math.PI / 2.6, hueShift: 0.04, luminosity: 1.08, saturation: 0.98 },
      { center: Math.PI * 0.2, width: Math.PI / 2.4, hueShift: -0.02, luminosity: 0.9, saturation: 0.85 },
      { center: Math.PI * 0.85, width: Math.PI / 2.1, hueShift: 0.07, luminosity: 1.2, saturation: 1.05 },
    ];
    const clusterLights = [];
    const clusterLightGroup = new THREE.Group();
    scene.add(clusterLightGroup);

    crowdClusters.forEach((cluster, index) => {
      const radius = 9.4;
      const angle = cluster.center;
      const position = new THREE.Vector3(Math.cos(angle) * radius, 2.6, Math.sin(angle) * radius);
      const target = position.clone().setLength(radius - 1.6);
      const color = new THREE.Color().setHSL(0.58 - index * 0.05, 0.48 + cluster.saturation * 0.15, 0.55);
      const light = new THREE.SpotLight(color, 0.8, 12, Math.max(Math.PI / 3, cluster.width), 1, 2);
      light.position.copy(position);
      light.target.position.copy(target.setY(0.8));
      light.castShadow = false;
      clusterLightGroup.add(light);
      clusterLightGroup.add(light.target);
      clusterLights.push(light);
      cluster.light = light;
    });

    const flashPool = [];
    let nextFlashTime = 4;

    const flashLightCount = 12;
    for (let i = 0; i < flashLightCount; i++) {
      const light = new THREE.PointLight('#dce9ff', 0, 12, 2.2);
      light.castShadow = false;
      light.intensity = 0;
      flashPool.push({ light, active: false, duration: 0.25, timeLeft: 0, baseIntensity: 0 });
      scene.add(light);
    }

    let spectatorsMesh = null;
    let spectatorData = [];
    const spectatorDummy = new THREE.Object3D();
    const spectatorColor = new THREE.Color();

    const listener = new THREE.AudioListener();
    const crowdAudio = new THREE.Audio(listener);
    const bellAudio = new THREE.Audio(listener);
    const impactAudio = new THREE.Audio(listener);
    const fallAudio = new THREE.Audio(listener);
    const audioLoader = new THREE.AudioLoader();
    povCamera.add(listener);

    const loadedBuffers = new Map();

    function playSound(url, audio, volume = 1, loop = false) {
      if (!audio) return;
      const start = (buffer) => {
        audio.stop();
        audio.setBuffer(buffer);
        audio.setLoop(loop);
        audio.setVolume(volume);
        audio.play();
      };

      if (loadedBuffers.has(url)) {
        start(loadedBuffers.get(url));
        return;
      }

      audioLoader.load(url, (buffer) => {
        loadedBuffers.set(url, buffer);
        start(buffer);
      });
    }

    function attachListener(camera) {
      listener.removeFromParent();
      camera.add(listener);
    }

    function playCrowdAudio(stageKey) {
      const config = stageProfiles[stageKey];
      if (!config?.audio) return;
      const url = config.audio;
      const volume = 0.45 + config.intensity * 0.45;

      const playBuffer = (buffer) => {
        if (crowdAudio.isPlaying) {
          crowdAudio.stop();
        }
        crowdAudio.setBuffer(buffer);
        crowdAudio.setLoop(true);
        crowdAudio.setVolume(volume);
        crowdAudio.play();
      };

      if (loadedBuffers.has(url)) {
        playBuffer(loadedBuffers.get(url));
        return;
      }

      audioLoader.load(url, (buffer) => {
        loadedBuffers.set(url, buffer);
        playBuffer(buffer);
      });
    }

    function playBell() {
      const url = 'sonidos/campana.mp3';
      const volume = 0.9;

      const start = (buffer) => {
        bellAudio.stop();
        bellAudio.setBuffer(buffer);
        bellAudio.setLoop(false);
        bellAudio.setVolume(volume);
        bellAudio.play();
      };

      if (loadedBuffers.has(url)) {
        start(loadedBuffers.get(url));
        return;
      }

      audioLoader.load(url, (buffer) => {
        loadedBuffers.set(url, buffer);
        start(buffer);
      });
    }

    function declareVictory(winnerKey, reason = 'Finalización') {
      if (fightEnded) return;
      fightEnded = true;
      params.pausarAnimaciones = true;
      pauseController?.setValue(true);
      Object.keys(fighterStates).forEach((slotKey) => {
        clearAi(slotKey);
        fighterStates[slotKey].blocking = false;
        fighterStates[slotKey].dodging = false;
        if (fighterStates[slotKey].countdownTimer) {
          clearTimeout(fighterStates[slotKey].countdownTimer);
          fighterStates[slotKey].countdownTimer = null;
        }
      });
      stageName = 'Clímax';
      params.etapa = 'Clímax';
      const label = winnerKey === 'player' ? 'Jugador' : 'Rival';
      status.textContent = `${label} gana • ${reason}`;
      playAnimation(winnerKey, 'rest', true);
    }

    function clearAi(slotKey) {
      const state = fighterStates[slotKey];
      if (state?.aiTimer) {
        clearTimeout(state.aiTimer);
        state.aiTimer = null;
      }
    }

    function applyPresentationMode() {
      fightEnded = false;
      Object.keys(fighterStates).forEach((slotKey) => {
        const state = fighterStates[slotKey];
        state.mode = 'Presentación';
        clearAi(slotKey);
        if (state.countdownTimer) {
          clearTimeout(state.countdownTimer);
          state.countdownTimer = null;
        }
        state.health = state.maxHealth;
        state.knockdowns = 0;
        updateLifeBar(slotKey);
        playAnimation(slotKey, 'rest', true);
      });
    }

    function evaluateCollision(attackerKey, attackKey) {
      const attacker = fighterSlots[attackerKey];
      const targetKey = attackerKey === 'player' ? 'rival' : 'player';
      const targetSlot = fighterSlots[targetKey];
      const targetState = fighterStates[targetKey];
      const attackConfig = animationLibrary[attackKey];
      if (!attacker?.model || !targetSlot?.model || !attackConfig || !targetState) return;

      const attackerBox = new THREE.Box3().setFromObject(attacker.model);
      const targetBox = new THREE.Box3().setFromObject(targetSlot.model);
      if (!attackerBox.intersectsBox(targetBox)) return;
      if (targetState.blocking || targetState.dodging || targetState.down) return;

      const damage = attackConfig.damage ?? 10;
      targetState.health = Math.max(0, targetState.health - damage);
      updateLifeBar(targetKey);
      playSound('sonidos/golpe_4.mp3', impactAudio, 0.6 + fightIntensity * 0.3);

      playAnimation(targetKey, 'damage', true);

      if (targetState.health <= 0) {
        triggerFall(targetKey, true);
      } else if (targetState.health <= targetState.maxHealth * 0.35 && !targetState.down) {
        triggerFall(targetKey);
      }
    }

    async function triggerFall(slotKey, isKnockout = false) {
      const state = fighterStates[slotKey];
      if (!state || state.down) return;
      const opponentKey = slotKey === 'player' ? 'rival' : 'player';
      state.down = true;
      state.knockdowns = (state.knockdowns ?? 0) + 1;
      clearAi(slotKey);
      playSound('sonidos/impacto_grave.wav', fallAudio, 0.9);
      const fallAction = await playAnimation(slotKey, 'fall', true);
      const duration = fallAction?.clip?.duration ?? 1.6;

      if (state.knockdowns >= 3) {
        declareVictory(opponentKey, '3 caídas');
      }

      if (state.countdownTimer) {
        clearTimeout(state.countdownTimer);
      }

      const countdownMs = 10000;
      state.countdownTimer = setTimeout(() => {
        declareVictory(opponentKey, 'Cuenta de 10');
      }, countdownMs);

      setTimeout(async () => {
        if (fightEnded) return;
        if (state.countdownTimer) {
          clearTimeout(state.countdownTimer);
          state.countdownTimer = null;
        }

        if (state.knockdowns >= 3 || isKnockout) {
          declareVictory(opponentKey, isKnockout ? 'KO' : '3 caídas');
          return;
        }

        await playAnimation(slotKey, 'getup', true);
        state.health = Math.max(state.maxHealth * 0.6, state.health || state.maxHealth * 0.6);
        updateLifeBar(slotKey);
        state.down = false;
        if (stageName === 'Combate' && !fightEnded) {
          scheduleAi(slotKey);
        }
      }, Math.min(countdownMs - 1500, duration * 1000 + 2200));
    }

    function scheduleAi(slotKey) {
      const state = fighterStates[slotKey];
      if (!state || stageName !== 'Combate' || params.pausarAnimaciones || fightEnded) return;
      clearAi(slotKey);

      const delay = 480 + Math.random() * 820;
      state.aiTimer = setTimeout(async () => {
        if (state.down || stageName !== 'Combate' || fightEnded) return;
        const targetKey = slotKey === 'player' ? 'rival' : 'player';
        const targetState = fighterStates[targetKey];
        faceTarget(slotKey, targetKey);

        const adjustment = await adjustDistanceForAttack(slotKey, targetKey);
        const distance = getHorizontalDistance(fighterSlots[slotKey], fighterSlots[targetKey]);

        if (adjustment !== 'ready') {
          state.blocking = false;
          state.dodging = false;
          playAnimation(slotKey, 'idle', true);
          scheduleAi(slotKey);
          return;
        }

        let actionKey = 'attackLight';
        if (distance < aiBehavior.minRange + 0.15) {
          actionKey = Math.random() > 0.5 ? 'attackCombo' : 'attackHeavy';
        } else if (distance > aiBehavior.idealRange) {
          actionKey = Math.random() > 0.4 ? 'attackHeavy' : 'attackCombo';
        }

        if (targetState?.activeAction?.startsWith('attack') && Math.random() > 0.45) {
          actionKey = Math.random() > 0.5 ? 'defend' : 'dodge';
        } else if (Math.random() > 0.82) {
          actionKey = Math.random() > 0.5 ? 'defend' : 'dodge';
        }

        state.blocking = actionKey === 'defend';
        state.dodging = actionKey === 'dodge';
        state.activeAction = actionKey;

        const action = await playAnimation(slotKey, actionKey, true);
        const impactTime = Math.min(0.6, (action?.clip?.duration ?? 1) * 0.5);
        if (actionKey.startsWith('attack')) {
          setTimeout(() => evaluateCollision(slotKey, actionKey), impactTime * 1000);
          setTimeout(() => {
            if (fightEnded) return;
            playAnimation(slotKey, 'walkBack', true);
            moveFighter(slotKey, directionToTarget(slotKey, targetKey).multiplyScalar(-1), aiBehavior.retreatStep * 0.6);
            faceTarget(slotKey, targetKey);
          }, impactTime * 1000 + 200);
        }

        const resetTime = (action?.clip?.duration ?? 1) * 1000;
        setTimeout(() => {
          state.blocking = false;
          state.dodging = false;
          state.activeAction = null;
          if (!state.down && stageName === 'Combate' && !fightEnded) {
            playAnimation(slotKey, 'idle', true);
            scheduleAi(slotKey);
          }
        }, resetTime + 250);
      }, delay);
    }

    function applyCombatMode() {
      fightEnded = false;
      Object.keys(fighterStates).forEach((slotKey) => {
        const state = fighterStates[slotKey];
        state.mode = 'Combate';
        if (state.countdownTimer) {
          clearTimeout(state.countdownTimer);
          state.countdownTimer = null;
        }
        state.knockdowns = 0;
        playAnimation(slotKey, 'idle', true);
        scheduleAi(slotKey);
      });
    }

    function setStage(nextStage) {
      const config = stageProfiles[nextStage];
      if (!config) return;
      const startingCombat = stageName !== 'Combate' && nextStage === 'Combate';
      stageName = nextStage;
      params.etapa = nextStage;
      fightIntensity = config.intensity;
      crowdNoiseLevel = config.noise;
      ledBaseColor.set(config.ledColor);
      updateAtmosphere(0);
      playCrowdAudio(nextStage);
      if (startingCombat) {
        playBell();
      }
      if (stageName === 'Combate') {
        applyCombatMode();
      } else {
        applyPresentationMode();
      }
      refreshSpectatorColors();
      updateStatusText();
    }

    function updateAtmosphere(time) {
      const stageConfig = stageProfiles[stageName] ?? stageProfiles.Presentación;
      const hue = THREE.MathUtils.lerp(0.62, 0.02, fightIntensity);
      const saturation = 0.7 + fightIntensity * 0.25;
      const lightness = 0.55 + fightIntensity * 0.15;
      const lightColor = new THREE.Color().setHSL(hue, saturation, lightness);
      const pulse = Math.sin(time * (1.4 + fightIntensity)) * 0.05;
      const breath = Math.sin(time * 0.8) * 0.06;
      const ringFocus = stageConfig.ringFocus ?? 1;

      ambient.color.copy(lightColor);
      hemiLight.color.copy(lightColor);
      ambient.intensity = 0.12 + fightIntensity * 0.4 + pulse * 0.5;
      hemiLight.intensity = params.hemi + fightIntensity * 0.35 + pulse * 0.6;

      spotGroup.children.forEach((child) => {
        if (child.isLight) {
          child.color.lerp(lightColor, 0.35);
          child.intensity = (2.1 + fightIntensity * 1.9) * ringFocus + Math.sin(time * 2 + child.position.x) * 0.12 + breath;
        }
      });

      rigLights.forEach((light, index) => {
        light.color.lerp(lightColor, 0.25);
        light.intensity = (1.1 + fightIntensity * 1.6) * ringFocus + Math.sin(time * 1.6 + index) * 0.12 + breath * 0.6;
      });

      rimLights.forEach((light, index) => {
        light.color.lerp(lightColor, 0.18);
        light.intensity = (1 + fightIntensity * 1.1) * ringFocus + Math.sin(time * 1.3 + index) * 0.08 + breath * 0.4;
      });

      fillLights.forEach((light) => {
        light.color.lerp(new THREE.Color('#bcd7ff'), 0.4);
        light.intensity = 0.35 + fightIntensity * 0.45 + breath * 0.5;
      });
    }

    function updateCrowdLights(time) {
      const stageConfig = stageProfiles[stageName] ?? stageProfiles.Presentación;
      const crowdVisibility = stageConfig.crowdVisibility ?? 1;
      const presentationDim = stageName === 'Presentación' ? 0.55 : 1;

      clusterLights.forEach((light, index) => {
        const cluster = crowdClusters[index];
        const breathing = Math.sin(time * 0.8 + index) * 0.18;
        const base = (cluster?.luminosity ?? 1) * crowdVisibility * presentationDim;
        light.intensity = THREE.MathUtils.clamp(base + fightIntensity * 0.35 + breathing, 0.2, 2.8);
        light.color.setHSL(0.55 + (cluster?.hueShift ?? 0), 0.5 + (cluster?.saturation ?? 1) * 0.2, 0.45 + fightIntensity * 0.2);
      });
    }

    function updateJumbotrons(time) {
      const stageConfig = stageProfiles[stageName] ?? stageProfiles.Presentación;
      const crowdVisibility = stageConfig.crowdVisibility ?? 1;
      const screenBoost = stageName === 'Presentación' ? 1.6 : 1;

      jumbotrons.forEach((panel, index) => {
        const hue = 0.58 - fightIntensity * 0.25 + index * 0.07;
        const wave = Math.sin(time * 1.6 + index) * 0.15 + Math.sin(time * 3.1 + index) * 0.05;
        const emissive = new THREE.Color().setHSL(hue, 0.8, 0.5 + wave * 0.2);
        panel.material.emissive.copy(emissive);
        panel.material.color.copy(emissive.clone().multiplyScalar(0.55));
        panel.material.emissiveIntensity = 3.2 * screenBoost + fightIntensity * 2.4 + wave * 2 + crowdVisibility * 1.4;
      });
    }

    function triggerFlashBurst(multiplier = 1) {
      const burstCount = Math.floor(3 + Math.random() * 4 * multiplier);

      for (let i = 0; i < burstCount; i++) {
        const slot = flashPool.find((flash) => !flash.active || flash.timeLeft <= 0);
        if (!slot) break;

        const cluster = crowdClusters[Math.floor(Math.random() * crowdClusters.length)];
        const angle = cluster.center + (Math.random() - 0.5) * cluster.width * 0.6;
        const radius = 9 + Math.random() * 1.6;
        const height = 1.4 + Math.random() * 1.2;

        slot.light.position.set(Math.cos(angle) * radius, height, Math.sin(angle) * radius);
        slot.light.color.setHSL(0.6 - Math.random() * 0.1, 0.55 + Math.random() * 0.15, 0.9);
        slot.baseIntensity = 8 + fightIntensity * 10 * multiplier;
        slot.duration = 0.22 + Math.random() * 0.18;
        slot.timeLeft = slot.duration;
        slot.active = true;
      }
    }

    function updateFlashes(delta, time) {
      const cadence = stageName === 'Clímax' ? 3.5 : stageName === 'Combate' ? 5 : 7.5;
      if (time > nextFlashTime) {
        triggerFlashBurst(0.8 + fightIntensity * 0.8 + (stageName === 'Clímax' ? 0.6 : 0));
        nextFlashTime = time + THREE.MathUtils.randFloat(cadence * 0.5, cadence * 1.1);
      }

      flashPool.forEach((flash) => {
        if (!flash.active) return;
        flash.timeLeft -= delta;
        const t = Math.max(flash.timeLeft, 0) / flash.duration;
        const falloff = Math.pow(t, 1.6);
        flash.light.intensity = flash.baseIntensity * falloff;
        flash.light.distance = 5 + fightIntensity * 6;
        flash.light.color.offsetHSL(0, 0, -0.01 * delta);

        if (flash.timeLeft <= 0) {
          flash.active = false;
          flash.light.intensity = 0;
        }
      });
    }

    function updateLedPanels(noise, time) {
      const stageConfig = stageProfiles[stageName] ?? stageProfiles.Presentación;
      const vivid = THREE.MathUtils.clamp(noise, 0, 1);
      const crowdVisibility = stageConfig.crowdVisibility ?? 1;
      const reactiveColor = new THREE.Color().setHSL(0.56 - vivid * 0.38, 0.9, 0.55 + vivid * 0.25);
      const emissiveColor = ledBaseColor.clone().lerp(reactiveColor, 0.6);
      const presentationBoost = stageName === 'Presentación' ? 1.25 : 1;

      ledPanels.forEach((panel, index) => {
        const flicker = Math.sin(time * 3 + index) * 0.08 + Math.random() * 0.02;
        const level = THREE.MathUtils.clamp(1 + vivid * 2.4 + flicker, 0.6, 3.8) * crowdVisibility * presentationBoost;
        panel.material.emissive.copy(emissiveColor);
        panel.material.emissiveIntensity = level;
        panel.scale.y = 1 + vivid * 0.25 * crowdVisibility + Math.sin(time * 5 + index) * 0.04;
      });
    }

    function updatePovMovement(delta) {
      if (params.camara !== 'POV' || !povControls.isLocked) return;

      const distance = POV_MOVE_SPEED * delta;
      if (povMoveState.forward) povControls.moveForward(distance);
      if (povMoveState.backward) povControls.moveForward(-distance);
      if (povMoveState.left) povControls.moveRight(-distance);
      if (povMoveState.right) povControls.moveRight(distance);
    }

    updateAtmosphere(0);

    let audioPrimed = false;
    function resumeCrowdAudio() {
      if (audioPrimed) return;
      audioPrimed = true;
      listener.context.resume?.();
      playCrowdAudio(stageName);
    }
    window.addEventListener('pointerdown', resumeCrowdAudio, { once: true });

    renderer.domElement.addEventListener('click', () => {
      if (params.camara === 'POV' && !povControls.isLocked) {
        povControls.lock();
      }
    });

    function handleMoveKey(key, pressed, event) {
      let handled = true;
      switch (key) {
        case 'w':
        case 'arrowup':
          povMoveState.forward = pressed;
          break;
        case 's':
        case 'arrowdown':
          povMoveState.backward = pressed;
          break;
        case 'a':
        case 'arrowleft':
          povMoveState.left = pressed;
          break;
        case 'd':
        case 'arrowright':
          povMoveState.right = pressed;
          break;
        default:
          handled = false;
          break;
      }

      if (handled && params.camara === 'POV') {
        event?.preventDefault?.();
      }

      return handled;
    }

    function buildSpectatorPalette(baseColorHex) {
      const base = new THREE.Color(baseColorHex ?? '#22d3ee');
      const hsl = { h: 0, s: 0, l: 0 };
      base.getHSL(hsl);

      const createVariant = (dh, ds, dl, satMul = 1, lightMul = 1) => new THREE.Color().setHSL(
        (hsl.h + dh + 1) % 1,
        THREE.MathUtils.clamp(hsl.s * satMul + ds, 0, 1),
        THREE.MathUtils.clamp(hsl.l * lightMul + dl, 0, 1),
      );

      return [
        base.clone(),
        createVariant(0.02, 0.05, 0.04, 1.05, 1),
        createVariant(-0.04, -0.08, -0.02, 0.85, 1),
        createVariant(0.5, -0.1, 0.12, 0.55, 1),
      ];
    }

    function getClusterIndex(angle) {
      const wrapped = Math.atan2(Math.sin(angle), Math.cos(angle));
      for (let i = 0; i < crowdClusters.length; i++) {
        const cluster = crowdClusters[i];
        const halfWidth = cluster.width / 2;
        const delta = Math.atan2(Math.sin(wrapped - cluster.center), Math.cos(wrapped - cluster.center));
        if (Math.abs(delta) <= halfWidth) return i;
      }
      return 0;
    }

    function refreshSpectatorColors() {
      if (!spectatorsMesh) return;

      const palette = buildSpectatorPalette(stageProfiles[stageName]?.ledColor ?? ledBaseColor.getStyle());
      const intensityShift = (fightIntensity - 0.5) * 0.08;
      const stageConfig = stageProfiles[stageName] ?? stageProfiles.Presentación;
      const crowdVisibility = stageConfig?.crowdVisibility ?? 1;
      const presentationDim = stageName === 'Presentación' ? 0.68 : 1;

      spectatorData.forEach((data, index) => {
        const base = palette[data.ringIndex % palette.length];
        const cluster = crowdClusters[data.clusterId] ?? crowdClusters[0];
        const hsl = { h: 0, s: 0, l: 0 };
        base.getHSL(hsl);

        const hue = (hsl.h + intensityShift + data.hueJitter + cluster.hueShift + 1) % 1;
        const saturation = THREE.MathUtils.clamp(
          hsl.s * cluster.saturation * (0.85 + fightIntensity * 0.25) * (0.7 + crowdVisibility * 0.4),
          0,
          1,
        );
        const lightness = THREE.MathUtils.clamp(
          hsl.l
            * (0.82 + data.colorNoise * 0.28)
            * (0.65 + crowdVisibility * 0.45)
            * cluster.luminosity
            * presentationDim
            + fightIntensity * 0.05 * crowdVisibility,
          0,
          1,
        );

        spectatorColor.setHSL(hue, saturation, lightness);
        spectatorsMesh.setColorAt(index, spectatorColor);
      });

      spectatorsMesh.instanceColor.needsUpdate = true;
    }

    function rebuildSpectators() {
      if (spectatorsMesh) {
        scene.remove(spectatorsMesh);
        spectatorsMesh.dispose?.();
      }

      const total = Math.max(400, Math.min(4000, Math.floor(params.espectadores)));
      spectatorData = [];
      spectatorsMesh = new THREE.InstancedMesh(spectatorGeometry, spectatorMaterial, total);
      spectatorsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      spectatorsMesh.receiveShadow = true;
      spectatorsMesh.castShadow = true;

      const baseRadius = 7.5;
      const ringSpacing = 0.9;
      const radialJitter = 0.15;
      const angleJitterStrength = 0.3;
      const densityStep = 0.55;

      let remaining = total;
      let ringIndex = 0;
      let instanceId = 0;

      while (remaining > 0) {
        const radius = baseRadius + ringSpacing * ringIndex;
        const idealCount = Math.max(12, Math.round((2 * Math.PI * radius) / densityStep));
        const ringCount = Math.min(idealCount, remaining);
        const angleStep = (Math.PI * 2) / ringCount;

        for (let i = 0; i < ringCount; i++) {
          const jitter = (Math.random() - 0.5) * angleStep * angleJitterStrength;
          const angle = i * angleStep + jitter;
          const clusterId = getClusterIndex(angle);
          const offsetRadius = radius + (Math.random() - 0.5) * radialJitter;

          const x = Math.cos(angle) * offsetRadius;
          const z = Math.sin(angle) * offsetRadius;
          const baseY = 0.2 + Math.random() * 0.32;
          const rotationY = angle + Math.PI + (Math.random() - 0.5) * 0.35;
          const amplitude = 0.02 + Math.random() * 0.1;
          const speed = 0.8 + Math.random() * 1.1;
          const phase = Math.random() * Math.PI * 2;
          const rotAmplitude = 0.015 + Math.random() * 0.05;
          const rotSpeed = 0.45 + Math.random() * 0.9;
          const rotPhase = Math.random() * Math.PI * 2;
          const hueJitter = (Math.random() - 0.5) * 0.06;
          const colorNoise = Math.random();
          const widthScale = 0.9 + Math.random() * 0.15;
          const heightScale = 0.94 + Math.random() * 0.18;

          spectatorData.push({
            position: new THREE.Vector3(x, baseY, z),
            rotationY,
            amplitude,
            speed,
            phase,
            rotAmplitude,
            rotSpeed,
            rotPhase,
            ringIndex,
            hueJitter,
            colorNoise,
            clusterId,
            scale: new THREE.Vector3(widthScale, heightScale, widthScale),
          });

          spectatorDummy.position.set(x, baseY, z);
          spectatorDummy.rotation.set(0, rotationY, 0);
          spectatorDummy.scale.set(widthScale, heightScale, widthScale);
          spectatorDummy.updateMatrix();
          spectatorsMesh.setMatrixAt(instanceId, spectatorDummy.matrix);
          instanceId++;
        }

        remaining -= ringCount;
        ringIndex++;
      }

      const lastRadius = baseRadius + ringSpacing * Math.max(0, ringIndex - 1);
      spectatorOuterRadius = lastRadius + 1.8;
      updateBacklightPositions();

      refreshSpectatorColors();
      scene.add(spectatorsMesh);

      rebuildPhones();
    }

    function rebuildPhones() {
      if (phoneMesh) {
        scene.remove(phoneMesh);
        phoneMesh.dispose?.();
      }

      const desiredPhones = Math.max(10, Math.min(50, Math.floor((spectatorData.length || 0) * 0.018)));
      phoneHolders = [];
      if (!desiredPhones) return;

      const availableIndices = spectatorData.map((_, index) => index);
      while (phoneHolders.length < desiredPhones && availableIndices.length > 0) {
        const pick = Math.floor(Math.random() * availableIndices.length);
        const index = availableIndices.splice(pick, 1)[0];
        const cluster = crowdClusters[spectatorData[index]?.clusterId ?? 0];
        if (Math.random() > (cluster?.luminosity ?? 1) * 0.85) continue;

        phoneHolders.push({
          index,
          heightJitter: (Math.random() - 0.5) * 0.06,
          sideOffset: (Math.random() - 0.5) * 0.08,
          twist: (Math.random() - 0.5) * 0.35,
        });
      }

      if (!phoneHolders.length) return;

      phoneMesh = new THREE.InstancedMesh(phoneGeometry, phoneMaterial, phoneHolders.length);
      phoneMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      phoneMesh.frustumCulled = false;
      scene.add(phoneMesh);
    }

    function updatePhones(time) {
      if (!phoneMesh) return;

      const screenBoost = stageName === 'Presentación' ? 1.6 : 1;
      phoneMaterial.emissiveIntensity = 3 + fightIntensity * 2.2 + screenBoost;

      phoneHolders.forEach((holder, index) => {
        const data = spectatorData[holder.index];
        if (!data) return;
        const forward = new THREE.Vector3(Math.sin(data.rotationY), 0, Math.cos(data.rotationY));

        phoneDummy.position.copy(data.position);
        phoneDummy.position.y += 0.28 + holder.heightJitter;
        phoneDummy.position.addScaledVector(forward, 0.08);
        phoneDummy.position.x += holder.sideOffset;
        phoneDummy.rotation.set(-0.42, data.rotationY + holder.twist, 0);
        phoneDummy.updateMatrix();
        phoneMesh.setMatrixAt(index, phoneDummy.matrix);
      });

      phoneMesh.instanceMatrix.needsUpdate = true;
    }

    rebuildSpectators();
    refreshBacklightIntensity(params.contraluz);
    refreshRigBeamLights(params.lucesViga);

    window.addEventListener('keydown', (event) => {
      if (event.repeat) return;
      const activeTag = document.activeElement?.tagName?.toLowerCase();
      if (activeTag === 'input' || activeTag === 'textarea') return;

      const key = event.key.toLowerCase();
      if (handleMoveKey(key, true, event)) return;

      if (key === 'c') {
        const nextMode = params.camara === 'POV' ? 'Orbital' : 'POV';
        cameraController.setValue(nextMode);
        applyCameraMode(nextMode);
      } else if (key === 'p') {
        toggleAnimations();
      } else if (key === 'r') {
        rebuildSpectators();
        updateStatusText();
      }
    });

    window.addEventListener('keyup', (event) => {
      handleMoveKey(event.key.toLowerCase(), false, event);
    });

    function render() {
      requestAnimationFrame(render);
      const delta = clock.getDelta();
      const time = clock.elapsedTime;

      const stageConfig = stageProfiles[stageName] ?? stageProfiles.Presentación;
      const rhythmicPulse = (Math.sin(time * (1.1 + fightIntensity * 0.4)) + 1) * 0.12;
      const slowWave = (Math.sin(time * 0.35) + 1) * 0.08;
      const targetNoise = THREE.MathUtils.clamp(stageConfig.noise + rhythmicPulse + slowWave, 0.25, 1.05);
      crowdNoiseLevel = THREE.MathUtils.lerp(crowdNoiseLevel, targetNoise, 0.04);

      if (!params.pausarAnimaciones) {
        mixers.forEach((mixer) => mixer.update(delta));
      }

      if (spectatorsMesh) {
        spectatorData.forEach((data, index) => {
          spectatorDummy.position.copy(data.position);
          const lift = data.amplitude * (0.6 + crowdNoiseLevel * 0.8);
          const sway = data.rotAmplitude * (0.6 + crowdNoiseLevel * 0.7);
          spectatorDummy.position.y = data.position.y + Math.sin(time * data.speed + data.phase) * lift;
          spectatorDummy.rotation.set(0, data.rotationY + Math.sin(time * data.rotSpeed + data.rotPhase) * sway, 0);
          spectatorDummy.scale.copy(data.scale);
          spectatorDummy.updateMatrix();
          spectatorsMesh.setMatrixAt(index, spectatorDummy.matrix);
        });
        spectatorsMesh.instanceMatrix.needsUpdate = true;
      }

      updatePhones(time);
      updateLedPanels(crowdNoiseLevel, time);
      updateJumbotrons(time);
      updateCrowdLights(time);
      updateFlashes(delta, time);
      updatePovMovement(delta);
      updateAtmosphere(time);
      controls.update();
      renderPass.camera = activeCamera;
      composer.render();
    }

    render();
  </script>
</body>
</html>
