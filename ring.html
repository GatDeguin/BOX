<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ring POV – Three.js</title>
  <link rel="icon" href="data:," />
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at 20% 20%, #0b0f1d 0%, #05060a 55%);
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 12px 18px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(6px);
      background: rgba(10, 12, 24, 0.75);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    header h1 {
      font-size: 1.1rem;
      letter-spacing: 0.02em;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      font-size: 0.8rem;
    }

    .tag span {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22d3ee;
      box-shadow: 0 0 10px rgba(34, 211, 238, 0.8);
    }

    main {
      flex: 1;
      position: relative;
    }

    canvas {
      width: 100%;
      height: calc(100vh - 66px);
      display: block;
    }

    #overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
      pointer-events: none;
    }

    .pill {
      padding: 6px 12px;
      background: rgba(17, 24, 39, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 999px;
      font-size: 0.8rem;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.35);
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <header>
    <h1>Ring POV • Three.js</h1>
    <div class="tag"><span></span> Carga: Ring.glb + FBX</div>
  </header>
  <main>
    <div id="overlay"></div>
    <canvas id="scene"></canvas>
  </main>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { FilmPass } from 'three/examples/jsm/postprocessing/FilmPass.js';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
    import { VignetteShader } from 'three/examples/jsm/shaders/VignetteShader.js';

    const canvas = document.getElementById('scene');
    const overlay = document.getElementById('overlay');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#030712');
    scene.fog = new THREE.FogExp2('#0b1b2f', 0.05);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.8));

    const povCamera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight - 66), 0.1, 100);
    povCamera.position.set(0, 1.6, 0.35);
    povCamera.lookAt(0, 1.4, -1);

    const orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight - 66), 0.1, 200);
    orbitCamera.position.set(6, 4.5, 6);
    orbitCamera.lookAt(0, 1, 0);

    let activeCamera = povCamera;
    const controls = new OrbitControls(orbitCamera, renderer.domElement);
    controls.enableDamping = true;
    controls.enabled = false;
    controls.target.set(0, 1, 0);

    const hemiLight = new THREE.HemisphereLight('#dbeafe', '#0f172a', 0.35);
    hemiLight.position.set(0, 8, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight('#bcd7ff', 0.55);
    dirLight.position.set(4, 8, 2);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 30;
    dirLight.shadow.camera.left = -10;
    dirLight.shadow.camera.right = 10;
    dirLight.shadow.camera.top = 10;
    dirLight.shadow.camera.bottom = -10;
    scene.add(dirLight);

    const spotGroup = new THREE.Group();
    const spotConfig = [
      { position: new THREE.Vector3(0, 8, 0), angle: 0.5 },
      { position: new THREE.Vector3(4, 7.5, 2), angle: 0.45 },
      { position: new THREE.Vector3(-4, 7.2, -2), angle: 0.45 },
      { position: new THREE.Vector3(2, 7.6, -4), angle: 0.45 },
    ];

    spotConfig.forEach(({ position, angle }) => {
      const spot = new THREE.SpotLight('#dff3ff', 2.8, 18, angle, 0.55, 1.5);
      spot.position.copy(position);
      spot.target.position.set(0, 1.2, 0);
      spot.castShadow = true;
      spot.shadow.mapSize.set(1024, 1024);
      spot.shadow.bias = -0.0004;
      spot.penumbra = 0.65;
      spotGroup.add(spot);
      spotGroup.add(spot.target);
    });
    scene.add(spotGroup);

    const ambient = new THREE.AmbientLight('#a5b4fc', 0.16);
    scene.add(ambient);

    const mixers = [];
    const loaderManager = new THREE.LoadingManager();

    const gltfLoader = new GLTFLoader(loaderManager);
    const fbxLoader = new FBXLoader(loaderManager);

    function setShadows(object) {
      object.traverse?.((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
    }

    async function loadRing() {
      const candidates = ['modelos/Ring.glb', 'modelos/Ring 2.glb'];
      for (const url of candidates) {
        try {
          const gltf = await gltfLoader.loadAsync(url);
          const ring = gltf.scene;
          ring.name = 'RingBase';
          ring.rotation.y = Math.PI / 2;
          setShadows(ring);
          scene.add(ring);
          return;
        } catch (err) {
          console.warn('No se pudo cargar', url, err.message);
        }
      }
      console.warn('No se encontró ningún modelo Ring.glb/Ring 2.glb');
    }

    async function loadFighter(url, position, flip = false) {
      try {
        const model = await fbxLoader.loadAsync(url);
        model.scale.setScalar(0.01);
        model.position.copy(position);
        model.rotation.y = flip ? Math.PI / 4 : -Math.PI / 4;
        setShadows(model);
        scene.add(model);

        if (model.animations?.length) {
          const mixer = new THREE.AnimationMixer(model);
          model.animations.forEach((clip) => mixer.clipAction(clip).play());
          mixers.push(mixer);
        }
      } catch (err) {
        console.warn('No se pudo cargar', url, err.message);
      }
    }

    const params = {
      camara: 'POV',
      pausarAnimaciones: false,
      luzDireccional: dirLight.intensity,
      hemi: hemiLight.intensity,
      espectadores: 1200,
      niebla: scene.fog.density,
      bloom: 1.2,
      bloomUmbral: 0.82,
    };

    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, activeCamera);
    const unrealBloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), params.bloom, 0.9, params.bloomUmbral);
    unrealBloomPass.threshold = params.bloomUmbral;
    unrealBloomPass.strength = params.bloom;
    const filmPass = new FilmPass(0.22, 0.35, 648, false);
    const vignettePass = new ShaderPass(VignetteShader);
    vignettePass.uniforms['offset'].value = 1.1;
    vignettePass.uniforms['darkness'].value = 1.3;
    composer.addPass(renderPass);
    composer.addPass(unrealBloomPass);
    composer.addPass(filmPass);
    composer.addPass(vignettePass);

    function resize() {
      const width = window.innerWidth;
      const height = window.innerHeight - 66;
      renderer.setSize(width, height, false);
      composer.setSize(width, height);
      unrealBloomPass.setSize(width, height);
      [povCamera, orbitCamera].forEach((cam) => {
        cam.aspect = width / height;
        cam.updateProjectionMatrix();
      });
    }

    window.addEventListener('resize', resize);
    resize();

    const gui = new GUI({ width: 320, container: overlay });
    gui.domElement.style.pointerEvents = 'auto';

    gui.add(params, 'camara', ['POV', 'Orbital']).name('Modo de cámara').onChange((value) => {
      const useOrbit = value === 'Orbital';
      controls.enabled = useOrbit;
      activeCamera = useOrbit ? orbitCamera : povCamera;
      renderPass.camera = activeCamera;
      if (!useOrbit) {
        povCamera.position.set(0, 1.6, 0.35);
        povCamera.lookAt(0, 1.4, -1);
      }
    });

    gui.add(params, 'pausarAnimaciones').name('Pausar animaciones');
    gui.add(params, 'luzDireccional', 0, 2, 0.05).name('Luz direccional').onChange((v) => dirLight.intensity = v);
    gui.add(params, 'hemi', 0, 1.5, 0.05).name('Luz ambiente').onChange((v) => hemiLight.intensity = v);
    gui.add(params, 'niebla', 0, 0.25, 0.005).name('Densidad niebla').onChange((v) => scene.fog.density = v);
    gui.add(params, 'bloomUmbral', 0.4, 1.5, 0.01).name('Umbral bloom').onChange((v) => unrealBloomPass.threshold = v);
    gui.add(params, 'bloom', 0, 3, 0.05).name('Intensidad bloom').onChange((v) => unrealBloomPass.strength = v);
    gui.add(params, 'espectadores', 400, 4000, 50).name('Espectadores').onChange(() => rebuildSpectators());

    const status = document.createElement('div');
    status.className = 'pill';
    status.textContent = 'Cargando modelos…';
    overlay.appendChild(status);

    Promise.all([
      loadRing(),
      loadFighter('modelos/Principal.fbx', new THREE.Vector3(2.2, 0, 2.2), true),
      loadFighter('modelos/Tyson.fbx', new THREE.Vector3(-2.2, 0, -2.2)),
    ]).finally(() => {
      status.textContent = 'Listo • GUI para ajustar vista y animaciones';
    });

    const clock = new THREE.Clock();

    const spectatorGeometry = new THREE.CapsuleGeometry(0.12, 0.35, 8, 16);
    const spectatorMaterial = new THREE.MeshStandardMaterial({
      color: '#111827',
      roughness: 0.65,
      metalness: 0.05,
    });

    let spectatorsMesh = null;
    let spectatorData = [];
    const spectatorDummy = new THREE.Object3D();

    function rebuildSpectators() {
      if (spectatorsMesh) {
        scene.remove(spectatorsMesh);
        spectatorsMesh.dispose?.();
      }

      const total = Math.max(400, Math.min(4000, Math.floor(params.espectadores)));
      spectatorData = [];
      spectatorsMesh = new THREE.InstancedMesh(spectatorGeometry, spectatorMaterial, total);
      spectatorsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      spectatorsMesh.receiveShadow = true;
      spectatorsMesh.castShadow = true;

      const baseRadius = 5.2;
      const ringSpacing = 0.75;
      const radialJitter = 0.25;
      const angleJitterStrength = 0.3;
      const densityStep = 0.55;

      let remaining = total;
      let ringIndex = 0;
      let instanceId = 0;

      while (remaining > 0) {
        const radius = baseRadius + ringSpacing * ringIndex;
        const idealCount = Math.max(12, Math.round((2 * Math.PI * radius) / densityStep));
        const ringCount = Math.min(idealCount, remaining);
        const angleStep = (Math.PI * 2) / ringCount;

        for (let i = 0; i < ringCount; i++) {
          const jitter = (Math.random() - 0.5) * angleStep * angleJitterStrength;
          const angle = i * angleStep + jitter;
          const offsetRadius = radius + (Math.random() - 0.5) * radialJitter;

          const x = Math.cos(angle) * offsetRadius;
          const z = Math.sin(angle) * offsetRadius;
          const baseY = 0.05 + Math.random() * 0.35;
          const rotationY = angle + Math.PI + (Math.random() - 0.5) * 0.35;
          const amplitude = 0.02 + Math.random() * 0.1;
          const speed = 0.8 + Math.random() * 1.1;
          const phase = Math.random() * Math.PI * 2;

          spectatorData.push({ position: new THREE.Vector3(x, baseY, z), rotationY, amplitude, speed, phase });

          spectatorDummy.position.set(x, baseY, z);
          spectatorDummy.rotation.set(0, rotationY, 0);
          spectatorDummy.updateMatrix();
          spectatorsMesh.setMatrixAt(instanceId, spectatorDummy.matrix);
          instanceId++;
        }

        remaining -= ringCount;
        ringIndex++;
      }

      scene.add(spectatorsMesh);
    }

    rebuildSpectators();

    function render() {
      requestAnimationFrame(render);
      const delta = clock.getDelta();
      if (!params.pausarAnimaciones) {
        mixers.forEach((mixer) => mixer.update(delta));
      }

      if (spectatorsMesh) {
        const time = clock.elapsedTime;
        spectatorData.forEach((data, index) => {
          spectatorDummy.position.copy(data.position);
          spectatorDummy.position.y = data.position.y + Math.sin(time * data.speed + data.phase) * data.amplitude;
          spectatorDummy.rotation.set(0, data.rotationY, 0);
          spectatorDummy.updateMatrix();
          spectatorsMesh.setMatrixAt(index, spectatorDummy.matrix);
        });
        spectatorsMesh.instanceMatrix.needsUpdate = true;
      }
      controls.update();
      renderPass.camera = activeCamera;
      composer.render();
    }

    render();
  </script>
</body>
</html>
