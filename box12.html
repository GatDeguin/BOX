<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gym Box 12 - Tyson Legacy (POV + Cine)</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2064%2064'%20fill='none'%3E%3Crect%20width='64'%20height='64'%20rx='12'%20fill='%23020203'/%3E%3Cpath%20d='M18%2036c0-6.6%205.4-12%2012-12h4c6.6%200%2012%205.4%2012%2012v6c0%203.3-2.7%206-6%206H24c-3.3%200-6-2.7-6-6z'%20fill='%23f97316'/%3E%3Cpath%20d='M24%2032c0-2.2%201.8-4%204-4h8c2.2%200%204%201.8%204%204v4c0%202.2-1.8%204-4%204h-8c-2.2%200-4-1.8-4-4z'%20fill='%23fffbf0'/%3E%3Ccircle%20cx='32'%20cy='28'%20r='4'%20fill='%2334d399'/%3E%3C/svg%3E">

    <!-- MediaPipe Pose (globals) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #090204;
            user-select: none;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0,0,0,0.9);
            z-index: 10;
            opacity: 1;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            visibility: visible;
        }
        #info.hidden {
            opacity: 0;
            visibility: hidden;
        }
        .instruction {
            background: radial-gradient(circle at top, rgba(200,200,220,0.1), rgba(5,5,8,0.9));
            padding: 14px 36px;
            border-radius: 4px;
            border-bottom: 2px solid rgba(239, 68, 68, 0.6);
            display: inline-flex;
            flex-direction: column;
            backdrop-filter: blur(8px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        canvas {
            cursor: crosshair;
        }
        #muteBtn {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 20;
        }
        #viewBtn {
            position: absolute;
            top: 16px;
            right: 110px;
            z-index: 20;
        }
        #cineBtn {
            position: absolute;
            top: 16px;
            right: 298px;
            z-index: 20;
        }
        #webcamBtn {
            position: absolute;
            top: 16px;
            right: 204px;
            z-index: 20;
        }
        #presetBtn {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 20;
        }

        #mobileControls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 25;
            align-items: flex-end;
        }

        .mobile-card {
            background: radial-gradient(circle at top, rgba(200,200,220,0.08), rgba(5,5,8,0.9));
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            color: #e2e8f0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            min-width: 240px;
        }

        .mobile-card h4 {
            margin: 0 0 6px 0;
            font-size: 14px;
            letter-spacing: 0.05em;
            color: #f8fafc;
        }

        .mobile-actions {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
        }

        .punch-btn {
            width: 100%;
            justify-content: center;
        }

        .mobile-hint {
            display: block;
            margin-top: 6px;
            font-size: 11px;
            color: #cbd5f5;
            opacity: 0.9;
        }

        /* Webcam + overlay pose */
        #input_video {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 220px;
            border-radius: 12px;
            transform: scaleX(-1);
            z-index: 30;
            box-shadow: 0 8px 30px rgba(0,0,0,0.9);
            background: #000;
        }
        #pose_canvas {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 220px;
            pointer-events: none;
            transform: scaleX(-1);
            z-index: 31;
        }

        .webcam-label {
            position: fixed;
            bottom: 12px;
            right: 16px;
            transform: translateY(100%);
            font-size: 10px;
            color: #cbd5f5;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            text-shadow: 0 2px 6px rgba(0,0,0,0.9);
            z-index: 32;
            pointer-events: none;
        }

        /* Panel debug */
        #debugPanel {
            position: absolute;
            bottom: 16px;
            left: 16px;
            min-width: 220px;
            max-width: 420px;
            width: calc(100% - 32px);
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            background: rgba(10, 12, 18, 0.82);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 12px 14px;
            color: #dbeafe;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            font-size: 12px;
            box-shadow: 0 18px 50px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            z-index: 35;
            box-sizing: border-box;
        }

        #debugPanel.collapsed {
            padding-bottom: 10px;
        }

        #debugPanel.collapsed #debugContent {
            display: none;
        }

        #debugPanel .debug-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 6px;
        }

        #debugPanel .debug-title {
            font-size: 11px;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: #f8fafc;
            opacity: 0.85;
            margin: 0;
        }

        #debugToggleBtn {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: #e2e8f0;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
        }

        #debugToggleBtn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        #debugToggleBtn:active {
            transform: translateY(1px);
        }

        .debug-button {
            width: 100%;
            text-align: center;
            font-size: 11px;
            padding: 6px 10px;
        }

        #debugPanel .debug-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            padding: 4px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.08);
        }

        #debugPanel .debug-row:last-child {
            border-bottom: none;
        }

        #debugPanel .control-row {
            display: grid;
            grid-template-columns: 1fr 2fr 0.8fr;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.08);
        }

        #debugPanel .control-row:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            #info { padding: 0 12px; }
            .instruction { width: calc(100% - 24px); box-sizing: border-box; }
            .pill-button { font-size: 14px; padding: 10px 12px; }
            #presetBtn { top: 12px; left: 12px; }
            #muteBtn { top: 12px; right: 12px; }
            #webcamBtn { top: 12px; right: 120px; }
            #viewBtn { top: 12px; right: 228px; }
            #cineBtn { top: 12px; right: 336px; }
            #debugPanel { max-height: 45vh; font-size: 11px; }
            #input_video, #pose_canvas { width: 160px; }
            #mobileControls { left: 12px; right: 12px; align-items: stretch; }
            .mobile-card { width: 100%; }
        }

        #debugPanel .control-row input[type="range"] {
            width: 100%;
        }

        #debugPanel .label {
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #94a3b8;
            font-weight: 600;
            font-size: 11px;
        }

        #debugPanel .value {
            font-weight: 700;
            color: #e2e8f0;
            text-align: right;
        }

        #debugPanel .section-label {
            grid-column: 1 / -1;
            font-size: 10px;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: #cbd5e1;
            opacity: 0.85;
            padding-top: 4px;
        }

        #debugPanel .color-input {
            width: 100%;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            height: 28px;
            cursor: pointer;
        }

        /* Tipograf√≠a del encabezado */
        .info-title {
            font-size: 1.5rem;
            font-weight: 900;
            margin-bottom: 0.25rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: #ffe7d6;
        }

        .info-subtitle {
            font-size: 10px;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            font-weight: 700;
            color: #9ca3af;
        }

        /* Botones estilo p√≠ldora */
        .pill-button {
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 9999px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition: transform 0.12s ease, background-color 0.12s ease, border-color 0.12s ease;
        }

        .pill-button:hover {
            transform: translateY(-1px);
            border-color: rgba(239, 68, 68, 0.65);
        }

        .pill-button:active {
            transform: translateY(0);
            background: rgba(0, 0, 0, 0.82);
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>

    <div id="info">
        <div class="instruction">
            <h1 class="info-title">
                Box 12 ‚Ä¢ Tyson Legacy POV
            </h1>
            <p class="info-subtitle">
                Modo cine + combos cl√°sicos de Tyson ‚Ä¢ Golpes encadenados al saco
            </p>
        </div>
    </div>

    <!-- Bot√≥n de preset d√≠a/noche -->
    <button id="presetBtn" class="pill-button">
        üåô Noche
    </button>

    <!-- Bot√≥n de mute -->
    <button id="muteBtn" class="pill-button">
        üîä ON
    </button>

    <!-- Bot√≥n de webcam -->
    <button id="webcamBtn" class="pill-button">
        üì∑ Webcam OFF
    </button>

    <!-- Bot√≥n de vista en 3ra persona -->
    <button id="viewBtn" class="pill-button">
        üëÅÔ∏è 3ra Persona
    </button>

    <!-- Bot√≥n de c√°mara cinem√°tica -->
    <button id="cineBtn" class="pill-button">
        üé• Cine OFF
    </button>

    <div id="mobileControls">
        <div class="mobile-card">
            <h4>Modo m√≥vil ligero</h4>
            <div class="mobile-actions">
                <button class="pill-button punch-btn" data-hand="left">üëä Izquierda</button>
                <button class="pill-button punch-btn" data-hand="right">üí• Derecha</button>
            </div>
            <small class="mobile-hint">Toca para golpear el saco sin webcam ni mouse.</small>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Webcam + pose overlay -->
    <video id="input_video" playsinline muted></video>
    <canvas id="pose_canvas"></canvas>
    <div class="webcam-label">Webcam desactivada</div>

    <!-- Debug info -->
    <div id="debugPanel">
        <div class="debug-header">
            <div class="debug-title">Debug</div>
            <button id="debugToggleBtn" aria-label="Alternar panel debug">‚è∑</button>
        </div>
        <div id="debugContent">
            <div class="debug-row">
                <button id="freeCamBtn" class="pill-button debug-button">üõ∞Ô∏è C√°mara libre OFF</button>
            </div>
            <div class="debug-row">
                <span class="label">Movimiento</span>
                <span class="value">WASD + Shift</span>
            </div>
            <div class="debug-row">
                <span class="label">Animaci√≥n</span>
                <span class="value" id="debugAnimation">‚Äî</span>
            </div>
            <div class="debug-row">
                <span class="label">Categor√≠a</span>
                <span class="value" id="debugCategory">‚Äî</span>
            </div>
            <div class="debug-row">
                <span class="label">Sonido</span>
                <span class="value" id="debugSound">‚Äî</span>
            </div>
            <div class="control-row">
                <span class="label">Masa</span>
                <input id="bagMass" type="range" min="20" max="120" step="1" value="72" />
                <span class="value" id="bagMassVal">72 kg</span>
            </div>
            <div class="control-row">
                <span class="label">Lin. damping</span>
                <input id="bagLinearDamping" type="range" min="0" max="1" step="0.01" value="0.58" />
                <span class="value" id="bagLinearDampingVal">0.58</span>
            </div>
            <div class="control-row">
                <span class="label">Ang. damping</span>
                <input id="bagAngularDamping" type="range" min="0" max="1" step="0.01" value="0.8" />
                <span class="value" id="bagAngularDampingVal">0.80</span>
            </div>
            <div class="control-row">
                <span class="label">Masa mano izq.</span>
                <input id="leftHandMass" type="range" min="1" max="10" step="0.1" value="4.5" />
                <span class="value" id="leftHandMassVal">4.5 kg</span>
            </div>
            <div class="control-row">
                <span class="label">√Årea contacto izq.</span>
                <input id="leftHandArea" type="range" min="0.5" max="2.0" step="0.05" value="1" />
                <span class="value" id="leftHandAreaVal">1.00x</span>
            </div>
            <div class="control-row">
                <span class="label">Masa mano der.</span>
                <input id="rightHandMass" type="range" min="1" max="10" step="0.1" value="5.5" />
                <span class="value" id="rightHandMassVal">5.5 kg</span>
            </div>
            <div class="control-row">
                <span class="label">√Årea contacto der.</span>
                <input id="rightHandArea" type="range" min="0.5" max="2.0" step="0.05" value="1" />
                <span class="value" id="rightHandAreaVal">1.00x</span>
            </div>
            <div class="control-row">
                <span class="section-label">Luces - Intensidad</span>
            </div>
            <div class="control-row">
                <span class="label">Key</span>
                <input id="keyIntensity" type="range" min="0" max="25" step="0.05" value="8.8" />
                <span class="value" id="keyIntensityVal">8.80</span>
            </div>
            <div class="control-row">
                <span class="label">Fill</span>
                <input id="fillIntensity" type="range" min="0" max="8" step="0.05" value="1.5" />
                <span class="value" id="fillIntensityVal">1.50</span>
            </div>
            <div class="control-row">
                <span class="label">Rim</span>
                <input id="rimIntensity" type="range" min="0" max="5" step="0.05" value="1.1" />
                <span class="value" id="rimIntensityVal">1.10</span>
            </div>
            <div class="control-row">
                <span class="label">Ring</span>
                <input id="ringIntensity" type="range" min="0" max="8" step="0.05" value="1.5" />
                <span class="value" id="ringIntensityVal">1.50</span>
            </div>
            <div class="control-row">
                <span class="label">Ring Spot</span>
                <input id="ringSpotIntensity" type="range" min="0" max="10" step="0.05" value="3.3" />
                <span class="value" id="ringSpotIntensityVal">3.30</span>
            </div>
            <div class="control-row">
                <span class="label">Cinema Back</span>
                <input id="cinemaBackIntensity" type="range" min="0" max="5" step="0.05" value="0.22" />
                <span class="value" id="cinemaBackIntensityVal">0.22</span>
            </div>
            <div class="control-row">
                <span class="label">Puerta</span>
                <input id="doorIntensity" type="range" min="0" max="30" step="0.1" value="18.5" />
                <span class="value" id="doorIntensityVal">18.50</span>
            </div>
            <div class="control-row">
                <span class="label">Fluorescente</span>
                <input id="fluorescentIntensity" type="range" min="0" max="15" step="0.1" value="7.5" />
                <span class="value" id="fluorescentIntensityVal">7.50</span>
            </div>
            <div class="control-row">
                <span class="label">Ambiente</span>
                <input id="ambientIntensity" type="range" min="0" max="3" step="0.01" value="0.85" />
                <span class="value" id="ambientIntensityVal">0.85</span>
            </div>
            <div class="control-row">
                <span class="section-label">Luces - Color</span>
            </div>
            <div class="control-row">
                <span class="label">Key</span>
                <input id="keyColor" type="color" class="color-input" value="#ffaa77" />
                <span class="value" id="keyColorVal">#ffaa77</span>
            </div>
            <div class="control-row">
                <span class="label">Fill</span>
                <input id="fillColor" type="color" class="color-input" value="#6c7cff" />
                <span class="value" id="fillColorVal">#6c7cff</span>
            </div>
            <div class="control-row">
                <span class="label">Rim</span>
                <input id="rimColor" type="color" class="color-input" value="#4a8dff" />
                <span class="value" id="rimColorVal">#4a8dff</span>
            </div>
            <div class="control-row">
                <span class="label">Ring</span>
                <input id="ringColor" type="color" class="color-input" value="#ffdd88" />
                <span class="value" id="ringColorVal">#ffdd88</span>
            </div>
            <div class="control-row">
                <span class="label">Ring Spot</span>
                <input id="ringSpotColor" type="color" class="color-input" value="#ffe2b0" />
                <span class="value" id="ringSpotColorVal">#ffe2b0</span>
            </div>
            <div class="control-row">
                <span class="label">Cinema Back</span>
                <input id="cinemaBackColor" type="color" class="color-input" value="#1a2846" />
                <span class="value" id="cinemaBackColorVal">#1a2846</span>
            </div>
            <div class="control-row">
                <span class="label">Puerta</span>
                <input id="doorColor" type="color" class="color-input" value="#4488ff" />
                <span class="value" id="doorColorVal">#4488ff</span>
            </div>
            <div class="control-row">
                <span class="label">Fluorescente</span>
                <input id="fluorescentColor" type="color" class="color-input" value="#f0f6ff" />
                <span class="value" id="fluorescentColorVal">#f0f6ff</span>
            </div>
            <div class="control-row">
                <span class="label">Ambiente cielo</span>
                <input id="ambientSkyColor" type="color" class="color-input" value="#3a3f60" />
                <span class="value" id="ambientSkyColorVal">#3a3f60</span>
            </div>
            <div class="control-row">
                <span class="label">Ambiente suelo</span>
                <input id="ambientGroundColor" type="color" class="color-input" value="#000000" />
                <span class="value" id="ambientGroundColorVal">#000000</span>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { BagSimulation } from './src/bag/BagSimulation.js';

        const infoBanner = document.getElementById('info');
        if (infoBanner) {
            setTimeout(() => infoBanner.classList.add('hidden'), 2000);
        }

        // --- UTILIDAD DE RUIDO ---
        class SimplexNoise {
            constructor() {
                this.grad3 = [
                    [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                    [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                    [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
                ];
                this.p = [];
                for (let i=0; i<256; i++) this.p[i] = Math.floor(256*Math.random());
                this.perm = [];
                for (let i=0; i<512; i++) this.perm[i] = this.p[i & 255];
            }
            dot(g,x,y){ return g[0]*x + g[1]*y; }
            noise2D(xin,yin){
                let n0,n1,n2;
                const F2 = 0.5*(Math.sqrt(3)-1);
                const s = (xin+yin)*F2;
                const i = Math.floor(xin+s);
                const j = Math.floor(yin+s);
                const G2 = (3-Math.sqrt(3))/6;
                const t = (i+j)*G2;
                const X0=i-t, Y0=j-t;
                const x0=xin-X0, y0=yin-Y0;
                let i1,j1;
                if(x0>y0){ i1=1; j1=0; } else { i1=0; j1=1; }
                const x1=x0-i1+G2, y1=y0-j1+G2;
                const x2=x0-1+2*G2, y2=y0-1+2*G2;
                const ii=i&255, jj=j&255;
                const gi0=this.perm[ii+this.perm[jj]]%12;
                const gi1=this.perm[ii+i1+this.perm[jj+j1]]%12;
                const gi2=this.perm[ii+1+this.perm[jj+1]]%12;
                let t0=.5-x0*x0-y0*y0;
                if(t0<0) n0=0; else { t0*=t0; n0=t0*t0*this.dot(this.grad3[gi0],x0,y0); }
                let t1=.5-x1*x1-y1*y1;
                if(t1<0) n1=0; else { t1*=t1; n1=t1*t1*this.dot(this.grad3[gi1],x1,y1); }
                let t2=.5-x2*x2-y2*y2;
                if(t2<0) n2=0; else { t2*=t2; n2=t2*t2*this.dot(this.grad3[gi2],x2,y2); }
                return 70*(n0+n1+n2);
            }
        }

        // --- CONFIGURACI√ìN ---
        const visualConfig = {
            bag: {
                color: 0x3a0c0c,
                roughness: 0.42,
                metalness: 0.1,
                deformationAmount: 1.9,
                bulgeAmount: 0.74,
                elasticity: 0.26,
                damping: 0.78,
                maxVertexSpeed: 5.9,
                noiseFactor: 0.05,
                punchForce: 95,
                mass: 72,
                linearDamping: 0.58,
                angularDamping: 0.8
            }
        };

        const fixedVisualStep = 1 / 60;
        let lastVisualStep = fixedVisualStep;

        const punchConfig = {
            left: {
                effectiveMass: 4.6,
                contactArea: 1.16
            },
            right: {
                effectiveMass: 5.6,
                contactArea: 1.16
            }
        };

        const audioConfig = {
            enabled: true,
            volume: 0.8,
            reverb: {
                enabled: true,
                decay: 1.4,
                mix: 0.35
            }
        };

        // Posici√≥n base del boxeador respecto al saco (aj√∫stalo si quer√©s)
        const BOXER_BASE_X = -0.5;  // izquierda/derecha (0 = alineado al saco)
        const BOXER_BASE_Z = 2.0;   // delante/detr√°s   (0 = mismo plano del saco)
        const MIN_BAG_DISTANCE = 1.35;
        const FIST_FORWARD_OFFSET = 0.12;

        const tysonBasePosition = new THREE.Vector3(BOXER_BASE_X, 0, BOXER_BASE_Z);
        const tysonTargetPosition = tysonBasePosition.clone();

        // Si lo pones en true, vuelven los golpes con el mouse (modo debug)
        let DEBUG_MOUSE_PUNCH = false;

        // Mezcla de animaciones autom√°ticas vs. mocap (webcam):
        // - Pon√© AUTO_ANIMATION_ENABLED en false para desactivar el combo autom√°tico y dejar solo mocap.
        // - Pon√© ENABLE_MOCAP_BLEND en false para correr las animaciones sin capturar webcam/pose.
        const AUTO_ANIMATION_ENABLED = true;
        const isMobile = window.innerWidth < 768 || /Mobi|Android/i.test(navigator.userAgent);
        const ENABLE_MOCAP_BLEND = !isMobile;
        const DUST_ENABLED = false;
        const CLOCK_MODE = 'system'; // 'system' | 'session'

        const MOBILE_SIMPLE_MODE = isMobile;

        const RING_MODEL_URL = 'modelos/Ring 2.glb';
        const RING_POSITION = new THREE.Vector3(20.1, 0, 2.0);
        const RING_CEILING_HEIGHT = 5.6;

        const POSTER_TEXTURE_PATHS = [
            'texturas/poster1.png',
            'texturas/poster2.png',
            'texturas/poster3.png',
            'texturas/poster4.png',
            'texturas/poster5.png',
            'texturas/poster6.png',
            'texturas/poster7.png',
            'texturas/poster8.png',
            'texturas/poster9.png',
            'texturas/poster10.png',
            'texturas/poster11.png',
            'texturas/poster12.png',
            'texturas/poster13.png'
        ];
        const POSTER_VARIATIONS = 13;

        const gltfLoader = new GLTFLoader();
        const posterTextureLoader = new THREE.TextureLoader();

        // --- VARIABLES GLOBALES ESCENA ---
        let scene, camera, renderer, controls, composer;
        let world;
        const collisionGroups = {
            static: 1,
            chain: 1 << 1,
            bag: 1 << 2,
            fist: 1 << 3
        };
        const physicsTuning = {
            baseFixedTimeStep: 1 / 60,
            minFixedTimeStep: 1 / 75,
            maxFixedTimeStep: 1 / 45,
            minSubSteps: 2,
            maxSubSteps: 6,
            stepTimeBudgetMs: 3.0,
            stepTimeComfortMs: 1.4,
            smoothing: 0.9
        };
        let fixedTimeStep = physicsTuning.baseFixedTimeStep;
        let maxSubSteps = physicsTuning.maxSubSteps;
        let smoothedStepTime = physicsTuning.stepTimeComfortMs;
        const maxDelta = 0.1;
        let accumulator = 0;
        let lastTime;

        const BAG_GEOMETRY_DETAIL = MOBILE_SIMPLE_MODE
            ? { radialSegments: 28, heightSegments: 12 }
            : { radialSegments: 48, heightSegments: 24 };

        const BAG_LIGHT_OFFSET = new THREE.Vector3(0, 1.35, 0.65);
        const BAG_LIGHT_BASE_POSITION = new THREE.Vector3(0, 2, 0);

        function applyMobileSimplifications() {
            if (!MOBILE_SIMPLE_MODE) return;

            physicsTuning.baseFixedTimeStep = 1 / 50;
            physicsTuning.maxSubSteps = 4;
            physicsTuning.stepTimeBudgetMs = 2.0;
            physicsTuning.stepTimeComfortMs = 1.0;
            fixedTimeStep = physicsTuning.baseFixedTimeStep;
            maxSubSteps = physicsTuning.maxSubSteps;
            smoothedStepTime = physicsTuning.stepTimeComfortMs;

            visualConfig.bag.mass = 58;
            visualConfig.bag.deformationAmount = 1.5;
            visualConfig.bag.bulgeAmount = 0.66;
            visualConfig.bag.punchForce = 78;
            visualConfig.bag.linearDamping = 0.64;
            visualConfig.bag.angularDamping = 0.86;

            punchConfig.left.contactArea = 1.0;
            punchConfig.right.contactArea = 1.0;
            DEBUG_MOUSE_PUNCH = true;

            const debugPanel = document.getElementById('debugPanel');
            if (debugPanel) {
                debugPanel.classList.add('collapsed');
            }
        }

        let bagSimulation;
        let bagBody, bagMesh, fanMesh, clockHandHour, clockHandMin, clockHandSec;
        let leftFistBody, rightFistBody, fistMaterial;
        let bagVisualOffset = new THREE.Vector3();
        let chains = [];
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const clock = new THREE.Clock();
        let noiseGen;

        let volumetricMesh;
        let doorGodrayMesh;
        let windowGodrayMesh;
        let keyLight, fillLight, bagLight, ringLight, rimLight, ambientLight;
        let bagLightTarget;
        let cinemaBackLight;
        let ringSpotLights = [];
        let accentLights = [];
        let ringReflectorFixtures = [];
        let doorLight;
        let fluorescentLights = [];
        let fluorescentGlowCards = [];
        let dustSystem, dustVelocities = [], dustOffsets = [];
        let uiSparks = [];
        let spriteTexture;
        let bloomPass;
        let bokehPass;
        const trainingAreaLights = [];

        const lightBases = {
            key: 8.8,
            fill: 1.5,
            bag: 2.4,
            rim: 1.1,
            ring: 2.1,
            ringSpot: 4.2,
            accent: 1.35,
            cinemaBack: 0.22,
            door: 18.5,
            fluorescent: 7.5
        };

        const lightingPresets = {
            night: {
                keyColor: 0xffaa77,
                keyBase: 8.8,
                fillColor: 0x6c7cff,
                fillBase: 1.5,
                rimColor: 0x4a8dff,
                rimBase: 1.25,
                ringColor: 0xffdd88,
                ringBase: 2.35,
                ringSpotColor: 0xffe2b0,
                ringSpotBase: 4.85,
                trainingSetColor: 0xffa347,
                accentColor: 0x79a8ff,
                accentBase: 1.45,
                bagLightColor: 0xffb17a,
                bagLightBase: 2.4,
                cinemaBackColor: 0x1a2846,
                cinemaBackBase: 0.22,
                doorColor: 0x4488ff,
                doorBase: 19.5,
                fluorescentColor: 0xf0f6ff,
                fluorescentBase: 8.0,
                ambientSky: 0x3a3f60,
                ambientGround: 0x000000,
                ambientBase: 0.85,
                fogColor: 0x0a0c12,
                fogDensity: 0.038,
                background: 0x08090f,
                volumetricHue: 0.09,
                bagPhysics: {
                    mass: 60,
                    linearDamping: 0.6,
                    angularDamping: 0.8
                }
            },
            sunset: {
                keyColor: 0xffc189,
                keyBase: 9.2,
                fillColor: 0x7fa0ff,
                fillBase: 1.45,
                rimColor: 0xff9966,
                rimBase: 1.1,
                ringColor: 0xffe1aa,
                ringBase: 1.85,
                ringSpotColor: 0xffdcb0,
                ringSpotBase: 4.05,
                trainingSetColor: 0x6db7ff,
                accentColor: 0xffc19b,
                accentBase: 1.25,
                bagLightColor: 0xffc58f,
                bagLightBase: 2.1,
                cinemaBackColor: 0x2c1b10,
                cinemaBackBase: 0.18,
                doorColor: 0xffa85a,
                doorBase: 12.0,
                fluorescentColor: 0xfff2da,
                fluorescentBase: 5.2,
                ambientSky: 0xffd6b8,
                ambientGround: 0x110800,
                ambientBase: 0.9,
                fogColor: 0x130b06,
                fogDensity: 0.048,
                background: 0x130b06,
                volumetricHue: 0.07,
                bagPhysics: {
                    mass: 52,
                    linearDamping: 0.55,
                    angularDamping: 0.78
                }
            }
        };

        let currentPreset = 'night';
        let baseFogDensity = lightingPresets[currentPreset].fogDensity;
        let volumetricBaseHue = lightingPresets[currentPreset].volumetricHue;
        let ambientBaseIntensity = lightingPresets[currentPreset].ambientBase;

        // Golpes y respiraci√≥n de luz
        const IMPACT_FLASH_DURATION = 0.12;
        let punchActivity = 0;
        let impactFlashTime = 0;
        let impactFlashStrength = 0;

        // Audio
        let audioContext, masterGain, reverbNode, reverbWetGain, reverbDryGain;
        let audioInitialized = false;
        const audioBuffers = new Map();
        let audioUnlockHandlers = [];
        const audioFiles = {
            impacts: [
                'sonidos/golpe_1.mp3',
                'sonidos/golpe_2.mp3',
                'sonidos/golpe_3.mp3',
                'sonidos/golpe_4.mp3',
                'sonidos/golpe_5.mp3',
                'sonidos/golpe_7.mp3',
                'sonidos/golpe_8.mp3',
                'sonidos/golpe_9.mp3',
                'sonidos/golpe_10.mp3'
            ],
            heavyImpact: 'sonidos/impacto_grave.wav',
            bell: 'sonidos/campana.mp3',
            countdown: 'sonidos/cuenta_atras.wav',
            breath: 'sonidos/respira.wav',
            crowd: 'sonidos/publico_enojado.wav',
            shouts: [
                'sonidos/grito_1.wav',
                'sonidos/grito_2.wav',
                'sonidos/grito_3.wav'
            ]
        };

        let animationDirector = null;
        let currentAnimationEntry = null;
        let currentAnimationCategory = null;
        let walkSignalsRegistered = false;

        const WALK_INTERRUPT_EVENT = 'box9:interrupt-walk';
        const WALK_NEW_ACTION_EVENT = 'box9:new-action';

        // Debug state
        const debugState = {
            animation: 'Cargando...',
            category: '‚Äî',
            sound: 'En espera'
        };

        const debugElements = {
            animation: document.getElementById('debugAnimation'),
            category: document.getElementById('debugCategory'),
            sound: document.getElementById('debugSound')
        };

        const debugPanelElements = {
            panel: document.getElementById('debugPanel'),
            content: document.getElementById('debugContent'),
            toggle: document.getElementById('debugToggleBtn')
        };

        function refreshDebugPanel() {
            if (!debugElements.animation || !debugElements.category || !debugElements.sound) return;
            debugElements.animation.textContent = debugState.animation || '‚Äî';
            debugElements.category.textContent = debugState.category || '‚Äî';
            debugElements.sound.textContent = debugState.sound || '‚Äî';
        }

        function registerWalkInterruptSignals() {
            if (walkSignalsRegistered) return;
            walkSignalsRegistered = true;

            window.addEventListener(WALK_INTERRUPT_EVENT, () => {
                if (animationDirector) animationDirector.requestWalkInterrupt('signal');
            });

            window.addEventListener(WALK_NEW_ACTION_EVENT, () => {
                if (animationDirector) animationDirector.notifyIncomingAction();
            });
        }

        function formatAnimationLabel(entry) {
            if (!entry) return '‚Äî';
            if (entry.file) return entry.file.split('/').pop().replace(/\.fbx$/i, '');
            if (entry.name) return entry.name;
            const clip = entry.action?.getClip?.();
            return clip?.name || '‚Äî';
        }

        function updateDebugAnimation(entry) {
            debugState.animation = formatAnimationLabel(entry);
            debugState.category = entry?.category || getClipCategory(entry?.name) || '‚Äî';
            refreshDebugPanel();
        }

        function updateDebugSound(name) {
            const cleanName = (() => {
                if (!name) return '‚Äî';
                if (name.startsWith('impact:')) {
                    return name
                        .replace('impact:', '')
                        .split('/')
                        .pop()
                        ?.replace(/\.[a-z0-9]+$/i, '') || 'Impacto';
                }
                if (name.startsWith('shout:')) {
                    return 'Grito ' + (parseInt(name.split(':')[1], 10) + 1 || 1);
                }
                return name;
            })();

            debugState.sound = cleanName;
            refreshDebugPanel();
        }

        refreshDebugPanel();

        function setupDebugPanelToggle() {
            const { panel, content, toggle } = debugPanelElements;
            if (!panel || !content || !toggle) return;

            const updateLabel = () => {
                const collapsed = panel.classList.contains('collapsed');
                toggle.textContent = collapsed ? '‚èµ' : '‚è∑';
                toggle.setAttribute('aria-expanded', (!collapsed).toString());
            };

            toggle.addEventListener('click', () => {
                panel.classList.toggle('collapsed');
                updateLabel();
            });

            updateLabel();
        }

        const bagControlElements = {
            mass: document.getElementById('bagMass'),
            massValue: document.getElementById('bagMassVal'),
            linearDamping: document.getElementById('bagLinearDamping'),
            linearDampingValue: document.getElementById('bagLinearDampingVal'),
            angularDamping: document.getElementById('bagAngularDamping'),
            angularDampingValue: document.getElementById('bagAngularDampingVal')
        };

        const punchControlElements = {
            leftMass: document.getElementById('leftHandMass'),
            leftMassValue: document.getElementById('leftHandMassVal'),
            rightMass: document.getElementById('rightHandMass'),
            rightMassValue: document.getElementById('rightHandMassVal'),
            leftArea: document.getElementById('leftHandArea'),
            leftAreaValue: document.getElementById('leftHandAreaVal'),
            rightArea: document.getElementById('rightHandArea'),
            rightAreaValue: document.getElementById('rightHandAreaVal')
        };

        const lightingControlElements = {
            key: {
                intensity: document.getElementById('keyIntensity'),
                intensityValue: document.getElementById('keyIntensityVal'),
                color: document.getElementById('keyColor'),
                colorValue: document.getElementById('keyColorVal')
            },
            fill: {
                intensity: document.getElementById('fillIntensity'),
                intensityValue: document.getElementById('fillIntensityVal'),
                color: document.getElementById('fillColor'),
                colorValue: document.getElementById('fillColorVal')
            },
            rim: {
                intensity: document.getElementById('rimIntensity'),
                intensityValue: document.getElementById('rimIntensityVal'),
                color: document.getElementById('rimColor'),
                colorValue: document.getElementById('rimColorVal')
            },
            ring: {
                intensity: document.getElementById('ringIntensity'),
                intensityValue: document.getElementById('ringIntensityVal'),
                color: document.getElementById('ringColor'),
                colorValue: document.getElementById('ringColorVal')
            },
            ringSpot: {
                intensity: document.getElementById('ringSpotIntensity'),
                intensityValue: document.getElementById('ringSpotIntensityVal'),
                color: document.getElementById('ringSpotColor'),
                colorValue: document.getElementById('ringSpotColorVal')
            },
            cinemaBack: {
                intensity: document.getElementById('cinemaBackIntensity'),
                intensityValue: document.getElementById('cinemaBackIntensityVal'),
                color: document.getElementById('cinemaBackColor'),
                colorValue: document.getElementById('cinemaBackColorVal')
            },
            door: {
                intensity: document.getElementById('doorIntensity'),
                intensityValue: document.getElementById('doorIntensityVal'),
                color: document.getElementById('doorColor'),
                colorValue: document.getElementById('doorColorVal')
            },
            fluorescent: {
                intensity: document.getElementById('fluorescentIntensity'),
                intensityValue: document.getElementById('fluorescentIntensityVal'),
                color: document.getElementById('fluorescentColor'),
                colorValue: document.getElementById('fluorescentColorVal')
            },
            ambient: {
                intensity: document.getElementById('ambientIntensity'),
                intensityValue: document.getElementById('ambientIntensityVal'),
                skyColor: document.getElementById('ambientSkyColor'),
                skyColorValue: document.getElementById('ambientSkyColorVal'),
                groundColor: document.getElementById('ambientGroundColor'),
                groundColorValue: document.getElementById('ambientGroundColorVal')
            }
        };

        function formatDampingValue(value) {
            return parseFloat(value).toFixed(2);
        }

        function syncBagControlsFromConfig() {
            if (!bagControlElements.mass) return;
            bagControlElements.mass.value = visualConfig.bag.mass;
            bagControlElements.massValue.textContent = `${visualConfig.bag.mass.toFixed(0)} kg`;
            bagControlElements.linearDamping.value = visualConfig.bag.linearDamping;
            bagControlElements.linearDampingValue.textContent = formatDampingValue(visualConfig.bag.linearDamping);
            bagControlElements.angularDamping.value = visualConfig.bag.angularDamping;
            bagControlElements.angularDampingValue.textContent = formatDampingValue(visualConfig.bag.angularDamping);
        }

        function formatAreaMultiplier(value) {
            return `${parseFloat(value).toFixed(2)}x`;
        }

        function numberToHexString(value) {
            return `#${value.toString(16).padStart(6, '0')}`;
        }

        function parseColorInput(value) {
            return parseInt(value.replace('#', ''), 16);
        }

        function syncPunchControlsFromConfig() {
            if (!punchControlElements.leftMass) return;

            punchControlElements.leftMass.value = punchConfig.left.effectiveMass;
            punchControlElements.leftMassValue.textContent = `${punchConfig.left.effectiveMass.toFixed(1)} kg`;
            punchControlElements.rightMass.value = punchConfig.right.effectiveMass;
            punchControlElements.rightMassValue.textContent = `${punchConfig.right.effectiveMass.toFixed(1)} kg`;

            punchControlElements.leftArea.value = punchConfig.left.contactArea;
            punchControlElements.leftAreaValue.textContent = formatAreaMultiplier(punchConfig.left.contactArea);
            punchControlElements.rightArea.value = punchConfig.right.contactArea;
            punchControlElements.rightAreaValue.textContent = formatAreaMultiplier(punchConfig.right.contactArea);
        }

        function applyBagControlsToConfig() {
            if (!bagControlElements.mass) return;
            visualConfig.bag.mass = parseFloat(bagControlElements.mass.value);
            visualConfig.bag.linearDamping = parseFloat(bagControlElements.linearDamping.value);
            visualConfig.bag.angularDamping = parseFloat(bagControlElements.angularDamping.value);
            syncBagControlsFromConfig();
            applyBagPhysicsToBody();
        }

        function applyPunchControlsToConfig() {
            if (!punchControlElements.leftMass) return;

            punchConfig.left.effectiveMass = parseFloat(punchControlElements.leftMass.value);
            punchConfig.right.effectiveMass = parseFloat(punchControlElements.rightMass.value);
            punchConfig.left.contactArea = parseFloat(punchControlElements.leftArea.value);
            punchConfig.right.contactArea = parseFloat(punchControlElements.rightArea.value);

            syncPunchControlsFromConfig();
        }

        function setupBagControls() {
            if (!bagControlElements.mass) return;
            syncBagControlsFromConfig();
            const handler = () => applyBagControlsToConfig();
            ['mass', 'linearDamping', 'angularDamping'].forEach(key => {
                const el = bagControlElements[key];
                if (el) {
                    el.addEventListener('input', handler);
                }
            });
        }

        function setupPunchControls() {
            if (!punchControlElements.leftMass) return;
            syncPunchControlsFromConfig();
            const handler = () => applyPunchControlsToConfig();
            ['leftMass', 'rightMass', 'leftArea', 'rightArea'].forEach(key => {
                const el = punchControlElements[key];
                if (el) {
                    el.addEventListener('input', handler);
                }
            });
        }

        function updateRingFixtureMaterials(color) {
            if (!ringReflectorFixtures.length) return;
            ringReflectorFixtures.forEach(fixture => {
                fixture.traverse((child) => {
                    if (child.isMesh && child.material && child.material.isMeshBasicMaterial) {
                        child.material.color.setHex(color);
                    }
                });
            });
        }

        function applyRingIntensityBases() {
            const ringBase = Math.max(0, lightBases.ring);
            const ringSpotBase = Math.max(0, lightBases.ringSpot);

            if (ringLight) {
                ringLight.intensity = ringBase;
            }

            if (ringSpotLights.length) {
                ringSpotLights.forEach((spot) => {
                    spot.intensity = ringSpotBase;
                });
            }

            if (ringReflectorFixtures.length) {
                const glowStrength = THREE.MathUtils.clamp(0.35 + (ringSpotBase / 6.5), 0.35, 1.1);
                ringReflectorFixtures.forEach((fixture) => {
                    fixture.traverse((child) => {
                        if (child.isMesh && child.material && child.material.isMeshBasicMaterial) {
                            child.material.opacity = glowStrength;
                            child.material.needsUpdate = true;
                        }
                    });
                });
            }
        }

        function applyLightingColorsToScene(preset) {
            if (keyLight) keyLight.color.setHex(preset.keyColor);
            if (fillLight) fillLight.color.setHex(preset.fillColor);
            if (bagLight) bagLight.color.setHex(preset.bagLightColor || preset.keyColor);
            if (rimLight) rimLight.color.setHex(preset.rimColor);
            if (ringLight) ringLight.color.setHex(preset.ringColor);
            if (cinemaBackLight) cinemaBackLight.color.setHex(preset.cinemaBackColor);
            if (ringSpotLights.length) ringSpotLights.forEach(s => s.color.setHex(preset.ringSpotColor));
            if (accentLights.length) accentLights.forEach(l => l.color.setHex(preset.accentColor));
            if (trainingAreaLights.length) {
                trainingAreaLights.forEach(({ light, colorKey }) => {
                    const color = preset[colorKey] ?? preset.accentColor;
                    light.color.setHex(color);
                });
            }
            updateRingFixtureMaterials(preset.ringSpotColor);

            if (ambientLight) {
                ambientLight.color.setHex(preset.ambientSky);
                ambientLight.groundColor.setHex(preset.ambientGround);
                ambientLight.intensity = ambientBaseIntensity;
            }

            if (doorLight) doorLight.color.setHex(preset.doorColor);
            if (fluorescentLights.length) {
                fluorescentLights.forEach(l => l.color.setHex(preset.fluorescentColor));
            }

            if (doorGodrayMesh && doorGodrayMesh.material.uniforms && doorGodrayMesh.material.uniforms.uColor) {
                doorGodrayMesh.material.uniforms.uColor.value.setHex(preset.doorColor);
            }
            if (windowGodrayMesh && windowGodrayMesh.material.uniforms && windowGodrayMesh.material.uniforms.uColor) {
                windowGodrayMesh.material.uniforms.uColor.value.setHex(preset.doorColor);
            }
        }

        function syncLightingControlsFromState() {
            const preset = lightingPresets[currentPreset];
            if (!preset || !lightingControlElements.key || !lightingControlElements.key.intensity) return;

            const intensityEntries = [
                { key: 'key', value: lightBases.key, decimals: 2 },
                { key: 'fill', value: lightBases.fill, decimals: 2 },
                { key: 'rim', value: lightBases.rim, decimals: 2 },
                { key: 'ring', value: lightBases.ring, decimals: 2 },
                { key: 'ringSpot', value: lightBases.ringSpot, decimals: 2 },
                { key: 'cinemaBack', value: lightBases.cinemaBack, decimals: 2 },
                { key: 'door', value: lightBases.door, decimals: 2 },
                { key: 'fluorescent', value: lightBases.fluorescent, decimals: 2 },
                { key: 'ambient', value: ambientBaseIntensity, decimals: 2 }
            ];

            intensityEntries.forEach(({ key, value, decimals }) => {
                const controls = lightingControlElements[key];
                if (!controls || !controls.intensity) return;
                controls.intensity.value = value;
                if (controls.intensityValue) {
                    controls.intensityValue.textContent = parseFloat(value).toFixed(decimals);
                }
            });

            const colorEntries = [
                { key: 'key', value: preset.keyColor },
                { key: 'fill', value: preset.fillColor },
                { key: 'rim', value: preset.rimColor },
                { key: 'ring', value: preset.ringColor },
                { key: 'ringSpot', value: preset.ringSpotColor },
                { key: 'cinemaBack', value: preset.cinemaBackColor },
                { key: 'door', value: preset.doorColor },
                { key: 'fluorescent', value: preset.fluorescentColor }
            ];

            colorEntries.forEach(({ key, value }) => {
                const controls = lightingControlElements[key];
                if (!controls || !controls.color) return;
                const hex = numberToHexString(value);
                controls.color.value = hex;
                if (controls.colorValue) controls.colorValue.textContent = hex;
            });

            if (lightingControlElements.ambient) {
                const ambientControls = lightingControlElements.ambient;
                const skyHex = numberToHexString(preset.ambientSky);
                const groundHex = numberToHexString(preset.ambientGround);
                if (ambientControls.skyColor) ambientControls.skyColor.value = skyHex;
                if (ambientControls.skyColorValue) ambientControls.skyColorValue.textContent = skyHex;
                if (ambientControls.groundColor) ambientControls.groundColor.value = groundHex;
                if (ambientControls.groundColorValue) ambientControls.groundColorValue.textContent = groundHex;
            }
        }

        function applyLightingControlsFromUI() {
            const preset = lightingPresets[currentPreset];
            if (!preset || !lightingControlElements.key || !lightingControlElements.key.intensity) return;

            lightBases.key = parseFloat(lightingControlElements.key.intensity.value);
            lightBases.fill = parseFloat(lightingControlElements.fill.intensity.value);
            lightBases.rim = parseFloat(lightingControlElements.rim.intensity.value);
            lightBases.ring = parseFloat(lightingControlElements.ring.intensity.value);
            lightBases.ringSpot = parseFloat(lightingControlElements.ringSpot.intensity.value);
            lightBases.cinemaBack = parseFloat(lightingControlElements.cinemaBack.intensity.value);
            lightBases.door = parseFloat(lightingControlElements.door.intensity.value);
            lightBases.fluorescent = parseFloat(lightingControlElements.fluorescent.intensity.value);
            ambientBaseIntensity = parseFloat(lightingControlElements.ambient.intensity.value);

            preset.keyBase = lightBases.key;
            preset.fillBase = lightBases.fill;
            preset.rimBase = lightBases.rim;
            preset.ringBase = lightBases.ring;
            preset.ringSpotBase = lightBases.ringSpot;
            preset.cinemaBackBase = lightBases.cinemaBack;
            preset.doorBase = lightBases.door;
            preset.fluorescentBase = lightBases.fluorescent;
            preset.ambientBase = ambientBaseIntensity;

            preset.keyColor = parseColorInput(lightingControlElements.key.color.value);
            preset.fillColor = parseColorInput(lightingControlElements.fill.color.value);
            preset.rimColor = parseColorInput(lightingControlElements.rim.color.value);
            preset.ringColor = parseColorInput(lightingControlElements.ring.color.value);
            preset.ringSpotColor = parseColorInput(lightingControlElements.ringSpot.color.value);
            preset.cinemaBackColor = parseColorInput(lightingControlElements.cinemaBack.color.value);
            preset.doorColor = parseColorInput(lightingControlElements.door.color.value);
            preset.fluorescentColor = parseColorInput(lightingControlElements.fluorescent.color.value);
            if (lightingControlElements.ambient) {
                const ambientControls = lightingControlElements.ambient;
                if (ambientControls.skyColor) preset.ambientSky = parseColorInput(ambientControls.skyColor.value);
                if (ambientControls.groundColor) preset.ambientGround = parseColorInput(ambientControls.groundColor.value);
            }

            applyRingIntensityBases();
            applyLightingColorsToScene(preset);
            syncLightingControlsFromState();
        }

        function setupLightingControls() {
            if (!lightingControlElements.key || !lightingControlElements.key.intensity) return;

            syncLightingControlsFromState();

            const intensityInputs = [
                lightingControlElements.key.intensity,
                lightingControlElements.fill.intensity,
                lightingControlElements.rim.intensity,
                lightingControlElements.ring.intensity,
                lightingControlElements.ringSpot.intensity,
                lightingControlElements.cinemaBack.intensity,
                lightingControlElements.door.intensity,
                lightingControlElements.fluorescent.intensity,
                lightingControlElements.ambient.intensity
            ];

            const colorInputs = [
                lightingControlElements.key.color,
                lightingControlElements.fill.color,
                lightingControlElements.rim.color,
                lightingControlElements.ring.color,
                lightingControlElements.ringSpot.color,
                lightingControlElements.cinemaBack.color,
                lightingControlElements.door.color,
                lightingControlElements.fluorescent.color,
                lightingControlElements.ambient.skyColor,
                lightingControlElements.ambient.groundColor
            ];

            const handler = () => applyLightingControlsFromUI();

            [...intensityInputs, ...colorInputs].forEach(el => {
                if (el) el.addEventListener('input', handler);
            });
        }

        function applyPresetBagSettings(name) {
            const preset = lightingPresets[name];
            if (!preset || !preset.bagPhysics) return;

            const { bagPhysics } = preset;
            if (typeof bagPhysics.mass === 'number') visualConfig.bag.mass = bagPhysics.mass;
            if (typeof bagPhysics.linearDamping === 'number') visualConfig.bag.linearDamping = bagPhysics.linearDamping;
            if (typeof bagPhysics.angularDamping === 'number') visualConfig.bag.angularDamping = bagPhysics.angularDamping;

            syncBagControlsFromConfig();
            applyBagPhysicsToBody();
        }

        // Head bob
        const baseTarget = new THREE.Vector3(-0.6, 1.7, 0);
        const targetBase = baseTarget.clone();

        // Modos de c√°mara
        const defaultCameraPosition = new THREE.Vector3(0, 1.75, 2.2);
        const thirdPersonCameraOffset = new THREE.Vector3(0.0, 1.35, -4.5);
        const thirdPersonTargetOffset = new THREE.Vector3(0.0, 0.15, -0.4);
        const povCameraOffset = new THREE.Vector3(0.0, 0.02, 0.18);
        const povTargetOffset = new THREE.Vector3(0.0, -0.01, 0.38);
        const cinematicPaths = buildCinematicPaths();
        const cinematicFxTargets = { bloom: 1.1, aperture: 0.00028, maxBlur: 0.024 };
        const defaultFxTargets = { bloom: 0.6, aperture: 0.00015, maxBlur: 0.015 };
        let cinematicPathIndex = 0;
        let cinematicSegmentIndex = 0;
        let cinematicSegmentTime = 0;
        let cinematicCameraActive = false;
        let thirdPersonActive = true;
        let freeCameraActive = false;
        let lastManualThirdPerson = true;
        const freeCamVelocity = new THREE.Vector3();
        const freeCamForward = new THREE.Vector3();
        const freeCamSide = new THREE.Vector3();
        const freeCamMoveState = { forward: false, back: false, left: false, right: false, fast: false };
        const freeCamSettings = { speed: 3.5, boost: 2.2 };

        // Reutilizaci√≥n de vectores para deformaci√≥n
        const tempV = new THREE.Vector3();
        const tempDisp = new THREE.Vector3();
        const bagLightAnchor = new THREE.Vector3();
        const bagLightTargetPos = new THREE.Vector3();

        function buildCinematicPaths() {
            const boxerFocus = baseTarget.clone();
            const ringCenter = RING_POSITION.clone();

            const nearBag = (x, y, z, duration, targetOffset = new THREE.Vector3()) => ({
                pos: boxerFocus.clone().add(new THREE.Vector3(x, y, z)),
                target: boxerFocus.clone().add(targetOffset),
                duration
            });

            const ringPass = (offset, height, duration, lookAtBoxer = false) => ({
                pos: ringCenter.clone().add(new THREE.Vector3(offset.x, height, offset.z)),
                target: lookAtBoxer ? boxerFocus.clone() : ringCenter.clone(),
                duration
            });

            return [
                [
                    nearBag(-0.2, 1.2, 3.6, 3.2),
                    nearBag(2.2, 1.6, 1.3, 3.0, new THREE.Vector3(0.2, 0, -0.6)),
                    nearBag(-2.2, 1.0, 0.6, 3.0, new THREE.Vector3(-0.4, -0.1, 0.3)),
                    ringPass(new THREE.Vector3(-7.0, 0, -1.2), 2.35, 4.2, true),
                    ringPass(new THREE.Vector3(0, 0, -7.0), 2.3, 3.2),
                    ringPass(new THREE.Vector3(7.2, 0, 0.8), 2.6, 4.0, true),
                    ringPass(new THREE.Vector3(0, 0, 0), 2.05, 3.2, true),
                    nearBag(-0.8, 1.9, -2.6, 4.0)
                ],
                [
                    nearBag(-0.8, 1.9, -2.6, 3.4, new THREE.Vector3(0.15, 0.15, 0)),
                    nearBag(-1.6, 1.0, -1.8, 2.8),
                    ringPass(new THREE.Vector3(0, 0, 6.8), 1.9, 3.4, true),
                    ringPass(new THREE.Vector3(-6.8, 0, 0), 2.5, 3.6),
                    ringPass(new THREE.Vector3(6.8, 0, 0), 2.5, 3.6, true),
                    ringPass(new THREE.Vector3(0, 0, 0), 1.6, 3.2, true),
                    nearBag(-0.2, 1.2, 3.6, 3.2, new THREE.Vector3(0, 0.1, 0.25))
                ]
            ];
        }

        function getSpriteTexture() {
            if (spriteTexture) return spriteTexture;
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,230,170,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            spriteTexture = new THREE.CanvasTexture(canvas);
            spriteTexture.needsUpdate = true;
            return spriteTexture;
        }

        function spawnUiSpark(clientX, clientY, strength = 0.4) {
            if (!scene || !camera) return;
            const ndc = new THREE.Vector3(
                (clientX / window.innerWidth) * 2 - 1,
                -(clientY / window.innerHeight) * 2 + 1,
                0.2
            );
            ndc.unproject(camera);
            const dir = ndc.sub(camera.position).normalize();
            const pos = camera.position.clone().add(dir.clone().multiplyScalar(1.2));
            const hue = 0.08 + Math.random() * 0.08;
            const sparkColor = new THREE.Color().setHSL(hue, 0.8, 0.62 + strength * 0.1);
            const mat = new THREE.SpriteMaterial({
                map: getSpriteTexture(),
                color: sparkColor,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(mat);
            sprite.position.copy(pos);
            sprite.scale.setScalar(0.25 + strength * 0.25);
            scene.add(sprite);
            uiSparks.push({
                sprite,
                life: 0.36,
                maxLife: 0.36,
                velocity: dir.multiplyScalar(0.6 * (0.65 + strength)).add(new THREE.Vector3(0, 0.2 + strength * 0.2, 0)),
                spin: (Math.random() - 0.5) * 6.5
            });
        }

        function updateUiSparks(dt) {
            if (!uiSparks.length) return;
            for (let i = uiSparks.length - 1; i >= 0; i--) {
                const s = uiSparks[i];
                s.life -= dt;
                if (s.life <= 0 || !s.sprite) {
                    if (s.sprite) scene.remove(s.sprite);
                    uiSparks.splice(i, 1);
                    continue;
                }
                const fade = Math.pow(s.life / (s.maxLife || 0.36), 1.5);
                s.sprite.material.opacity = fade;
                s.sprite.material.rotation += s.spin * dt;
                s.sprite.position.addScaledVector(s.velocity, dt);
                s.sprite.scale.multiplyScalar(1.0 + dt * 1.8);
            }
        }

        function createDustParticles() {
            if (!DUST_ENABLED) return;
            if (!scene) return;
            const count = 520;
            const positions = new Float32Array(count * 3);
            dustVelocities = new Array(count);
            dustOffsets = new Array(count);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                positions[idx] = (Math.random() - 0.5) * 6.5;
                positions[idx + 1] = 0.08 + Math.random() * 1.4;
                positions[idx + 2] = (Math.random() - 0.5) * 6.5;
                dustVelocities[i] = 0.32 + Math.random() * 0.42;
                dustOffsets[i] = Math.random() * 50;
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                map: getSpriteTexture(),
                size: 0.05,
                color: 0xffffff,
                transparent: true,
                opacity: 0.25,
                depthWrite: false,
                sizeAttenuation: true,
                blending: THREE.NormalBlending
            });
            dustSystem = new THREE.Points(geometry, material);
            dustSystem.frustumCulled = false;
            scene.add(dustSystem);
        }

        function updateDust(elapsed, dt) {
            if (!DUST_ENABLED) return;
            if (!dustSystem || !dustSystem.geometry.attributes.position) return;
            if (dustSystem.material) {
                dustSystem.material.opacity = 0.22 + Math.sin(elapsed * 0.4) * 0.06;
            }
            const posAttr = dustSystem.geometry.attributes.position;
            for (let i = 0; i < posAttr.count; i++) {
                const idx = i * 3;
                let x = posAttr.array[idx];
                let y = posAttr.array[idx + 1];
                let z = posAttr.array[idx + 2];
                const sway = noiseGen ? (noiseGen.noise2D(elapsed * 0.12, dustOffsets[i]) * 0.5 + 0.5) : 0.5;
                const swirl = elapsed * 0.08 + dustOffsets[i] * 0.15;
                x += (sway - 0.5) * dt * 0.38 + Math.cos(swirl) * dt * 0.12;
                z += Math.sin(elapsed * 0.6 + dustOffsets[i]) * dt * 0.2 + Math.sin(swirl) * dt * 0.12;
                y += dustVelocities[i] * dt;
                if (y > 2.8) {
                    y = 0.05 + Math.random() * 0.4;
                    x = (Math.random() - 0.5) * 6.5;
                    z = (Math.random() - 0.5) * 6.5;
                }
                posAttr.array[idx] = x;
                posAttr.array[idx + 1] = y;
                posAttr.array[idx + 2] = z;
            }
            posAttr.needsUpdate = true;
        }

        // Shake de c√°mara
        let shakeTime = 0;
        const shakeDuration = 0.15;
        let shakeStrength = 0;
        const shakeOffset = new THREE.Vector3();

        // ============================
        //  TYSON + MEDIAPIPE (MOCAP)
        // ============================
        const MODEL_URL = 'modelos/Tyson.fbx';
        // Textura base del modelo de Tyson (corregimos la ruta inexistente)
        const TYSON_TEXTURE_URL = 'texturas/Tyson.jpeg';

        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('pose_canvas');
        const canvasCtx = canvasElement ? canvasElement.getContext('2d') : null;
        const webcamInfoLabel = document.querySelector('.webcam-label');
        const webcamToggleBtn = document.getElementById('webcamBtn');

        if (!ENABLE_MOCAP_BLEND) {
            if (videoElement) videoElement.style.display = 'none';
            if (canvasElement) canvasElement.style.display = 'none';
            if (webcamToggleBtn) webcamToggleBtn.style.display = 'none';
        }

        let poseInstance = null;
        let cameraMP = null;
        let capturing = false;
        let lastPoseLandmarks = null;
        let smoothedLandmarks = null;
        let mocapStarted = false;
        let mocapInitialRootPosition = null;
        let mocapInitialRootQuaternion = null;
        let mocapInitialHipsPosition = null;
        let mocapInitialHipsQuaternion = null;

        function updateWebcamUiState(active) {
            if (videoElement) videoElement.style.display = active ? 'block' : 'none';
            if (canvasElement) canvasElement.style.display = active ? 'block' : 'none';
            if (webcamToggleBtn) {
                webcamToggleBtn.textContent = active ? 'üì∑ Webcam ON' : 'üì∑ Webcam OFF';
            }
            if (webcamInfoLabel) {
                webcamInfoLabel.textContent = active
                    ? 'Webcam activa: seguimiento de pose en vivo'
                    : 'Webcam desactivada';
            }
        }

        const POSE_LM = {
            NOSE: 0,
            LEFT_EYE_INNER: 1,
            LEFT_EYE: 2,
            LEFT_EYE_OUTER: 3,
            RIGHT_EYE_INNER: 4,
            RIGHT_EYE: 5,
            RIGHT_EYE_OUTER: 6,
            LEFT_EAR: 7,
            RIGHT_EAR: 8,
            MOUTH_LEFT: 9,
            MOUTH_RIGHT: 10,
            LEFT_SHOULDER: 11,
            RIGHT_SHOULDER: 12,
            LEFT_ELBOW: 13,
            RIGHT_ELBOW: 14,
            LEFT_WRIST: 15,
            RIGHT_WRIST: 16,
            LEFT_PINKY: 17,
            RIGHT_PINKY: 18,
            LEFT_INDEX: 19,
            RIGHT_INDEX: 20,
            LEFT_THUMB: 21,
            RIGHT_THUMB: 22,
            LEFT_HIP: 23,
            RIGHT_HIP: 24,
            LEFT_KNEE: 25,
            RIGHT_KNEE: 26,
            LEFT_ANKLE: 27,
            RIGHT_ANKLE: 28,
            LEFT_HEEL: 29,
            RIGHT_HEEL: 30,
            LEFT_FOOT_INDEX: 31,
            RIGHT_FOOT_INDEX: 32,
        };

        function lerp(a, b, t) { return a + (b - a) * t; }

        function lerpLandmark(prev, curr, factor) {
            if (!prev) return curr;
            return {
                x: lerp(prev.x, curr.x, factor),
                y: lerp(prev.y, curr.y, factor),
                z: lerp(prev.z ?? 0, curr.z ?? 0, factor),
                visibility: lerp(prev.visibility ?? 1, curr.visibility ?? 1, factor),
            };
        }

        // Tyson 3D
        let tysonRoot = null;
        let skeleton = null;
        const bonesByName = {};
        const headBoneCandidates = ['HeadTop_End', 'Head', 'LeftEye', 'RightEye'];
        let headBone = null;
        let mixer = null;
        const tysonTexture = new THREE.TextureLoader().load(TYSON_TEXTURE_URL);
        tysonTexture.colorSpace = THREE.SRGBColorSpace;
        tysonTexture.flipY = false;

        const MODEL_FORWARD = new THREE.Vector3(0, 0, 1);
        const tysonFloorBox = new THREE.Box3();

        const tmpVecA = new THREE.Vector3();
        const tmpVecB = new THREE.Vector3();
        const tmpDir  = new THREE.Vector3();
        const tmpQuatA = new THREE.Quaternion();

        function lmToVec3(lm) {
            if (!lm) return null;
            const x = (lm.x - 0.5) * 2;
            const y = (lm.y - 0.5) * -2;
            const z = -(lm.z ?? 0) * 2;
            return new THREE.Vector3(x, y, z);
        }

        function getBone(name) {
            return (
                bonesByName[name] ||
                bonesByName[name.toLowerCase()] ||
                bonesByName['mixamorig' + name]
            );
        }

        function getHeadBone() {
            if (headBone && headBone.parent) return headBone;
            headBone = null;
            for (const candidate of headBoneCandidates) {
                const bone = getBone(candidate);
                if (bone) {
                    headBone = bone;
                    break;
                }
            }
            return headBone;
        }

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function loadPosterTexture(url) {
            return new Promise((resolve) => {
                const texture = posterTextureLoader.load(
                    encodeURI(url),
                    () => resolve(texture),
                    undefined,
                    () => resolve(null)
                );
                texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.colorSpace = THREE.SRGBColorSpace;
            });
        }

        function clonePosterTexture(texture) {
            const clone = texture.clone();
            clone.wrapS = texture.wrapS;
            clone.wrapT = texture.wrapT;
            clone.colorSpace = texture.colorSpace;
            clone.needsUpdate = true;
            return clone;
        }

        async function loadPosterPool(fallbackPoster, coverPoster) {
            const textures = await Promise.all(POSTER_TEXTURE_PATHS.map((path) => loadPosterTexture(path)));
            const available = textures.filter(Boolean);

            if (!available.length) {
                const minimalPool = [fallbackPoster, fallbackPoster, fallbackPoster];
                if (coverPoster) minimalPool.push(coverPoster);
                return minimalPool;
            }

            const posterQuota = Math.max(POSTER_VARIATIONS - 1, 1);
            const pool = available.slice(0, posterQuota);
            while (pool.length < posterQuota) {
                const source = available[pool.length % available.length];
                pool.push(clonePosterTexture(source));
            }

            pool.push(coverPoster || fallbackPoster);
            return pool.slice(0, POSTER_VARIATIONS);
        }

        function selectPosterSet(posterPool, fallbackPoster) {
            const pool = posterPool && posterPool.length ? shuffleArray([...posterPool]) : [];
            if (!pool.length) return [fallbackPoster, fallbackPoster, fallbackPoster];

            while (pool.length < 3) {
                pool.push(pool[pool.length % pool.length]);
            }

            return pool.slice(0, 3);
        }

        const BIND = {};
        const BIND_PAIRS = [
            ['Hips',   'Spine'],
            ['Spine',  'Spine1'],
            ['Spine1', 'Spine2'],
            ['Spine2', 'Neck'],
            ['Neck',   'Head'],
            ['Head',   'HeadTop_End'],
            ['LeftShoulder',  'LeftArm'],
            ['RightShoulder', 'RightArm'],
            ['LeftArm',      'LeftForeArm'],
            ['LeftForeArm',  'LeftHand'],
            ['RightArm',     'RightForeArm'],
            ['RightForeArm', 'RightHand'],
            ['LeftUpLeg',   'LeftLeg'],
            ['LeftLeg',     'LeftFoot'],
            ['RightUpLeg',  'RightLeg'],
            ['RightLeg',    'RightFoot'],
        ];

        function captureBindInfo() {
            for (const k of Object.keys(BIND)) delete BIND[k];
            if (!tysonRoot) return;

            scene.updateMatrixWorld(true);

            for (const [aName, bName] of BIND_PAIRS) {
                const A = getBone(aName);
                const B = getBone(bName);
                if (!A || !B) continue;

                const aPos = new THREE.Vector3().setFromMatrixPosition(A.matrixWorld);
                const bPos = new THREE.Vector3().setFromMatrixPosition(B.matrixWorld);

                const dirWorld = bPos.clone().sub(aPos).normalize();
                const rotWorld = new THREE.Quaternion().setFromRotationMatrix(
                    new THREE.Matrix4().extractRotation(A.matrixWorld)
                );
                BIND[aName] = { dir: dirWorld, wq: rotWorld };
            }
        }

        function worldQuatToLocal(bone, targetWorldQuat) {
            const parentWorld = bone.parent
                ? bone.parent.getWorldQuaternion(new THREE.Quaternion())
                : new THREE.Quaternion();
            const parentWorldInv = parentWorld.clone().invert();
            return parentWorldInv.multiply(targetWorldQuat);
        }

        function orientBoneFromDirection(boneName, dirWorld, slerp = 0.35) {
            const bone = getBone(boneName);
            if (!skeleton || !bone || !dirWorld) return;

            const info = BIND[boneName];
            if (!info) return;

            const targetDir = dirWorld.clone().normalize();
            if (targetDir.lengthSq() < 1e-6) return;

            const qDelta = new THREE.Quaternion().setFromUnitVectors(info.dir, targetDir);
            const targetWorld = info.wq.clone().premultiply(qDelta);
            const targetLocal = worldQuatToLocal(bone, targetWorld);

            bone.quaternion.slerp(targetLocal, slerp);
        }

        function orientBoneFromLandmarks(boneName, lmStartIdx, lmEndIdx, slerp = 0.35) {
            const bone = getBone(boneName);
            if (!skeleton || !bone || !smoothedLandmarks) return;

            const lmStart = smoothedLandmarks[lmStartIdx];
            const lmEnd   = smoothedLandmarks[lmEndIdx];
            if (!lmStart || !lmEnd) return;
            if ((lmStart.visibility ?? 0) < 0.4 || (lmEnd.visibility ?? 0) < 0.4) return;

            const info = BIND[boneName];
            if (!info) return;

            const vStart = lmToVec3(lmStart);
            const vEnd   = lmToVec3(lmEnd);
            const dir    = vEnd.clone().sub(vStart).normalize();
            if (dir.lengthSq() < 1e-6) return;

            const qDelta = new THREE.Quaternion().setFromUnitVectors(info.dir, dir);
            const targetWorld = info.wq.clone().premultiply(qDelta);
            const targetLocal = worldQuatToLocal(bone, targetWorld);

            bone.quaternion.slerp(targetLocal, slerp);
        }

        function captureMocapInitialPose() {
            mocapInitialRootPosition = null;
            mocapInitialRootQuaternion = null;
            mocapInitialHipsPosition = null;
            mocapInitialHipsQuaternion = null;

            if (!tysonRoot) return;

            tysonRoot.updateMatrixWorld(true);
            mocapInitialRootPosition = tysonRoot.position.clone();
            mocapInitialRootQuaternion = tysonRoot.quaternion.clone();

            const hips = getBone('Hips') || getBone('hips');
            if (hips) {
                hips.updateMatrixWorld(true);
                mocapInitialHipsPosition = hips.position.clone();
                mocapInitialHipsQuaternion = hips.getWorldQuaternion(new THREE.Quaternion());
            }
        }

        function updateModelFromPose(landmarks) {
            if (!ENABLE_MOCAP_BLEND) return;
            if (!landmarks || !skeleton) return;

            const lmLS   = landmarks[POSE_LM.LEFT_SHOULDER];
            const lmRS   = landmarks[POSE_LM.RIGHT_SHOULDER];
            const lmLH   = landmarks[POSE_LM.LEFT_HIP];
            const lmRH   = landmarks[POSE_LM.RIGHT_HIP];
            const lmNose = landmarks[POSE_LM.NOSE];

            const hips = getBone('Hips') || getBone('hips');

            if (hips && lmLS && lmRS && lmLH && lmRH) {
                const vLS = lmToVec3(lmLS);
                const vRS = lmToVec3(lmRS);
                const vLH = lmToVec3(lmLH);
                const vRH = lmToVec3(lmRH);

                const vShoulderMid = tmpVecA.copy(vLS).add(vRS).multiplyScalar(0.5);
                const vHipMid      = tmpVecB.copy(vLH).add(vRH).multiplyScalar(0.5);

                const torsoDir = tmpDir.copy(vShoulderMid).sub(vHipMid).normalize();

                const infoHips = BIND['Hips'];
                if (infoHips) {
                    const qDelta = new THREE.Quaternion().setFromUnitVectors(infoHips.dir, torsoDir);
                    const hipsWorldReference = (mocapInitialHipsQuaternion || infoHips.wq).clone();
                    const targetWorld = hipsWorldReference.premultiply(qDelta);
                    const targetLocal = worldQuatToLocal(hips, targetWorld);
                    hips.quaternion.slerp(targetLocal, 0.25);
                }

                const hipsReferencePosition = mocapInitialHipsPosition
                    ? mocapInitialHipsPosition
                    : (mocapInitialRootPosition || tysonRoot?.position || tysonBasePosition);

                hips.position.lerp(
                    new THREE.Vector3(
                        hipsReferencePosition.x,
                        vHipMid.y * 0.4 + 1.0,
                        hipsReferencePosition.z
                    ),
                    0.15
                );

                orientBoneFromDirection('Spine',  torsoDir, 0.35);
                orientBoneFromDirection('Spine1', torsoDir, 0.35);
                orientBoneFromDirection('Spine2', torsoDir, 0.35);

                if (lmNose) {
                    const vNose   = lmToVec3(lmNose);
                    const headDir = vNose.clone().sub(vShoulderMid).normalize();
                    orientBoneFromDirection('Neck', headDir, 0.45);
                    orientBoneFromDirection('Head', headDir, 0.55);
                }
            }

            // Brazos
            orientBoneFromLandmarks('LeftArm',     POSE_LM.LEFT_SHOULDER,  POSE_LM.LEFT_ELBOW);
            orientBoneFromLandmarks('LeftForeArm', POSE_LM.LEFT_ELBOW,     POSE_LM.LEFT_WRIST);
            orientBoneFromLandmarks('RightArm',    POSE_LM.RIGHT_SHOULDER, POSE_LM.RIGHT_ELBOW);
            orientBoneFromLandmarks('RightForeArm',POSE_LM.RIGHT_ELBOW,    POSE_LM.RIGHT_WRIST);

            // Piernas
            orientBoneFromLandmarks('LeftUpLeg',   POSE_LM.LEFT_HIP,       POSE_LM.LEFT_KNEE);
            orientBoneFromLandmarks('LeftLeg',     POSE_LM.LEFT_KNEE,      POSE_LM.LEFT_ANKLE);
            orientBoneFromLandmarks('RightUpLeg',  POSE_LM.RIGHT_HIP,      POSE_LM.RIGHT_KNEE);
            orientBoneFromLandmarks('RightLeg',    POSE_LM.RIGHT_KNEE,     POSE_LM.RIGHT_ANKLE);
        }

        function orientTysonTowardBag(force = false) {
            if (!tysonRoot || !bagMesh) return;

            tmpVecA.copy(bagMesh.position).sub(tysonRoot.position);
            tmpVecA.y = 0;

            if (tmpVecA.lengthSq() < 1e-6) return;

            const targetQuat = tmpQuatA.setFromUnitVectors(
                MODEL_FORWARD,
                tmpVecA.normalize()
            );

            if (force) {
                tysonRoot.quaternion.copy(targetQuat);
            } else {
                const blend = currentAnimationCategory === 'attack' ? 0.35 : 0.15;
                tysonRoot.quaternion.slerp(targetQuat, blend);
            }
        }

        function resetTysonTargetToBase() {
            tysonTargetPosition.copy(tysonBasePosition);
        }

        function setTysonWalkTargetAroundBag() {
            const pivot = bagMesh ? bagMesh.position : tysonBasePosition;
            const minRadius = MIN_BAG_DISTANCE + 0.25;
            const radius = minRadius + Math.random() * 1.1;
            const angle = Math.random() * Math.PI * 2;
            const target = new THREE.Vector3(
                pivot.x + Math.cos(angle) * radius,
                0,
                pivot.z + Math.sin(angle) * radius
            );

            tysonTargetPosition.lerp(target, 0.7);
        }

        function enforceTysonDistanceToBag() {
            if (!tysonRoot || !bagMesh) return 0;

            const bagPos = bagMesh.position;
            const currentPos = tysonRoot.position;
            tmpVecA.copy(currentPos).sub(bagPos);

            let distance = tmpVecA.length();
            if (distance < MIN_BAG_DISTANCE) {
                if (distance < 1e-4) {
                    tmpVecA.set(0, 0, 1);
                }
                const safePos = bagPos.clone().add(tmpVecA.normalize().multiplyScalar(MIN_BAG_DISTANCE));
                tysonTargetPosition.lerp(safePos, 0.75);
                tysonRoot.position.lerp(safePos, 0.4);
                distance = MIN_BAG_DISTANCE;
            }

            return distance;
        }

        function handleCategoryTransitions(category) {
            if (category === 'walk') {
                setTysonWalkTargetAroundBag();
            } else if (category === 'rest') {
                resetTysonTargetToBase();
            } else if (category === 'attack') {
                orientTysonTowardBag(true);
            }
        }

        const SKINNING_WARNING_PREFIX = 'THREE.FBXLoader: Vertex has more than 4 skinning weights';

        function suppressSkinningWarnings() {
            const originalWarn = console.warn;
            let logged = false;

            console.warn = (...args) => {
                const [message] = args;
                const isSkinningWarning = typeof message === 'string' && message.startsWith(SKINNING_WARNING_PREFIX);

                if (isSkinningWarning) {
                    if (!logged) {
                        originalWarn(
                            'THREE.FBXLoader: se detectaron v√©rtices con m√°s de 4 pesos de skinning; se limitar√°n a los cuatro m√°s fuertes.'
                        );
                        logged = true;
                    }
                    return;
                }

                originalWarn(...args);
            };

            return () => {
                console.warn = originalWarn;
            };
        }

        function normalizeSkinWeights(object3d) {
            object3d.traverse((child) => {
                const skinWeight = child.geometry?.attributes?.skinWeight;
                if (!child.isSkinnedMesh || !skinWeight) return;

                for (let i = 0; i < skinWeight.count; i++) {
                    const x = skinWeight.getX(i);
                    const y = skinWeight.getY(i);
                    const z = skinWeight.getZ(i);
                    const w = skinWeight.getW(i);
                    const total = x + y + z + w;

                    if (total > 0) {
                        skinWeight.setXYZW(i, x / total, y / total, z / total, w / total);
                    } else {
                        skinWeight.setXYZW(i, 0, 0, 0, 0);
                    }
                }

                skinWeight.needsUpdate = true;
            });
        }

        function loadTysonModel() {
            const loader = new FBXLoader();
            const restoreWarnings = suppressSkinningWarnings();
            loader.load(
                MODEL_URL,
                (asset) => {
                    restoreWarnings();
                    tysonRoot = asset;

                    normalizeSkinWeights(tysonRoot);

                    tysonRoot.traverse((obj) => {
                        if (obj.isMesh) {
                            obj.castShadow = true;
                            obj.frustumCulled = false;

                            const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
                            materials.forEach((mat) => {
                                if (!mat) return;
                                if (!mat.map) {
                                    mat.map = tysonTexture;
                                }
                                mat.needsUpdate = true;
                            });
                        }
                        if (obj.isSkinnedMesh) skeleton = obj.skeleton;
                        if (obj.isBone) {
                            bonesByName[obj.name] = obj;
                            const cleaned = obj.name
                                .replace(/^mixamorig[:_ ]?/i, '')
                                .replace(/^mixamorig/i, '');
                            if (cleaned && cleaned !== obj.name) {
                                bonesByName[cleaned] = obj;
                                bonesByName[cleaned.toLowerCase()] = obj;
                            }
                            bonesByName[obj.name.toLowerCase()] = obj;
                        }
                    });

                    const bbox = new THREE.Box3().setFromObject(tysonRoot);
                    const size = new THREE.Vector3();
                    const center = new THREE.Vector3();
                    bbox.getSize(size);
                    bbox.getCenter(center);

                    const targetHeight = 3.6;
                    const scale = targetHeight / size.y;
                    tysonRoot.scale.setScalar(scale);

                    bbox.setFromObject(tysonRoot);
                    bbox.getCenter(center);

                    tysonRoot.position.x += -center.x + BOXER_BASE_X;
                    tysonRoot.position.z += -center.z + BOXER_BASE_Z;
                    tysonRoot.position.y += -bbox.min.y;

                    orientTysonTowardBag(true);

                    scene.add(tysonRoot);
                    scene.updateMatrixWorld(true);
                    captureBindInfo();

                    mixer = new THREE.AnimationMixer(tysonRoot);
                    loadTysonAnimations();

                    console.log('Tyson cargado. Huesos:', Object.keys(bonesByName));
                },
                undefined,
                (err) => {
                    restoreWarnings();
                    console.error('Error cargando Tyson:', err);
                }
            );
        }

        const BLOCKED_ANIMATION_SUBSTRINGS = [
            'animaciones/da√±o/',
            'animaciones/dano/',
            'animaciones/damage/'
        ];

        const BLOCKED_ANIMATION_NAMES = ['taking punch'];

        const ANIMATION_LIBRARY = [
            { file: 'animaciones/ataque/Boxing.fbx', loop: 'repeat', category: 'attack' },
            { file: 'animaciones/ataque/Lead Jab.fbx', loop: 'once', category: 'attack' },
            { file: 'animaciones/ataque/Hook.fbx', loop: 'once', category: 'attack' },
            { file: 'animaciones/ataque/Jab Cross.fbx', loop: 'once', category: 'attack' },
            { file: 'animaciones/ataque/Illegal Elbow Punch.fbx', loop: 'once', category: 'attack' },
            { file: 'animaciones/ataque/Punching Bag.fbx', loop: 'repeat', category: 'attack' },
            { file: 'animaciones/movimiento/Walking.fbx', loop: 'repeat', category: 'walk' },
            { file: 'animaciones/movimiento/Walk back.fbx', loop: 'repeat', category: 'walk' },
            { file: 'animaciones/descanso/Arm Stretching.fbx', loop: 'repeat', category: 'rest' },
            { file: 'animaciones/descanso/Action Idle To Fight Idle.fbx', loop: 'once', category: 'rest' },
            { file: 'animaciones/descanso/Pointing Forward.fbx', loop: 'once', category: 'rest' }
        ];

        const ANIMATION_RULES = {
            crossFade: { in: 0.2, out: 0.25 },
            autoDelayMs: () => 500 + Math.random() * 800,
            rest: {
                initialDelayMs: () => 2000 + Math.random() * 2500,
                cadenceMs: () => 6000 + Math.random() * 4500
            }
        };

        function sanitizeClipRootMotion(clip) {
            if (!clip || !Array.isArray(clip.tracks)) return clip;

            const filteredTracks = clip.tracks.filter((track) => {
                const name = track.name?.toLowerCase?.() || '';
                return !name.includes('hips.position');
            });

            if (filteredTracks.length === clip.tracks.length) return clip;

            const sanitized = clip.clone();
            sanitized.tracks = filteredTracks;
            sanitized.resetDuration();
            return sanitized;
        }

        function isAnimationAllowed(file = '') {
            return !BLOCKED_ANIMATION_SUBSTRINGS.some((pattern) => file.includes(pattern));
        }

        function getClipCategory(name = '') {
            if (typeof name !== 'string') return null;
            if (name.includes('animaciones/ataque/')) return 'attack';
            if (name.includes('animaciones/defensa/')) return 'defense';
            if (name.includes('animaciones/descanso/')) return 'rest';
            return null;
        }

        function extractImpactCueTimes(clip) {
            const eventTimes = [];
            const motionPeakTimes = [];
            const referenceTimes = [];

            const isHandTrack = (name) => {
                const lower = name?.toLowerCase?.() || '';
                return (lower.includes('righthand') || lower.includes('lefthand')) &&
                    (lower.includes('position') || lower.includes('rotation') || lower.includes('quaternion'));
            };

            const isEventTrack = (track) => {
                const name = track.name?.toLowerCase?.() || '';
                return name.includes('event') || name.includes('impact');
            };

            const pickMotionPeakTime = (track) => {
                if (!track.times || track.times.length < 2) return null;
                if (track.ValueTypeName === 'vector') {
                    let best = { speed: 0, time: null };
                    for (let i = 0; i < track.times.length - 1; i++) {
                        const dt = track.times[i + 1] - track.times[i];
                        if (dt <= 0) continue;
                        const baseIndex = i * 3;
                        const dx = track.values[baseIndex + 3] - track.values[baseIndex];
                        const dy = track.values[baseIndex + 4] - track.values[baseIndex + 1];
                        const dz = track.values[baseIndex + 5] - track.values[baseIndex + 2];
                        const speed = Math.sqrt(dx * dx + dy * dy + dz * dz) / dt;
                        if (speed > best.speed) best = { speed, time: track.times[i + 1] };
                    }
                    return best.time;
                }

                if (track.ValueTypeName === 'quaternion') {
                    let best = { speed: 0, time: null };
                    const qa = new THREE.Quaternion();
                    const qb = new THREE.Quaternion();
                    for (let i = 0; i < track.times.length - 1; i++) {
                        const dt = track.times[i + 1] - track.times[i];
                        if (dt <= 0) continue;
                        const ia = i * 4;
                        const ib = ia + 4;
                        qa.set(track.values[ia], track.values[ia + 1], track.values[ia + 2], track.values[ia + 3]);
                        qb.set(track.values[ib], track.values[ib + 1], track.values[ib + 2], track.values[ib + 3]);
                        const angle = qa.angleTo(qb);
                        const speed = angle / dt;
                        if (speed > best.speed) best = { speed, time: track.times[i + 1] };
                    }
                    return best.time;
                }

                return null;
            };

            clip.tracks.forEach((track) => {
                const name = track.name?.toLowerCase?.() || '';
                const relevantEventTrack = isEventTrack(track);
                const relevantHandTrack = isHandTrack(name);
                if (!relevantEventTrack && !relevantHandTrack) return;

                if (relevantEventTrack) {
                    if (track.times && track.times.length) {
                        const values = track.values || [];
                        track.times.forEach((t, idx) => {
                            const value = values[idx] ?? values[0];
                            if (typeof value !== 'string' || value.toLowerCase().includes('impact')) {
                                eventTimes.push(t);
                                referenceTimes.push(t);
                            }
                        });
                    }
                    return;
                }

                const peakTime = pickMotionPeakTime(track);
                if (peakTime != null) {
                    motionPeakTimes.push(peakTime);
                    referenceTimes.push(peakTime);
                }
            });

            const baseTimes = eventTimes.length ? eventTimes : motionPeakTimes;

            baseTimes.sort((a, b) => a - b);
            const uniqueTimes = baseTimes.filter((t, i) => i === 0 || Math.abs(t - baseTimes[i - 1]) > 1e-3);
            const minWindow = clip.duration * 0.2;
            const maxWindow = clip.duration * 0.95;
            const filtered = uniqueTimes.filter((t) => t >= minWindow && t <= maxWindow);

            const spaced = [];
            filtered.forEach((t) => {
                if (spaced.every((p) => Math.abs(p - t) > 0.25)) spaced.push(t);
            });

            const cueTimes = spaced.length ? spaced.slice(0, 3) : [clip.duration * 0.6];
            return { cueTimes, referenceTimes: referenceTimes.length ? referenceTimes : cueTimes };
        }

        function validateImpactCueTimes(cueTimes, clip, referenceTimes) {
            const tolerance = Math.max(1 / 30, clip.duration * 0.01);
            const withinClip = cueTimes.filter((t) => t >= 0 && t <= clip.duration);
            const aligned = withinClip.filter((t) => referenceTimes.some((ref) => Math.abs(ref - t) <= tolerance));
            return aligned.length ? aligned : withinClip;
        }

        class AnimationSoundDirector {
            constructor({ mixer }) {
                this.mixer = mixer;
                this.loader = new FBXLoader();
                this.actions = [];
                this.queue = [];
                this.activeAction = null;
                this.activeEntry = null;
                this.cues = [];
                this.restBreathing = false;
                this.actionTimeState = null;
                this.lastStuckWarning = { action: null, time: 0 };
                this.lastProgressTimestamp = 0;
                this.entryStartTimestamp = 0;
                this.entryExpectedDurationMs = 0;
                this.walkStepCount = 0;
                this.walkLoopAtLastCheck = 0;
                this.walkStartTimestamp = 0;
                this.walkStepDurationMs = 800;
                this.pendingWalkInterrupt = false;
                this.recentAttackHistory = [];
            }

            async loadLibrary(definitions = ANIMATION_LIBRARY) {
                const allowed = definitions.filter(({ file }) => {
                    const ok = isAnimationAllowed(file);
                    if (!ok) console.warn('Animaci√≥n bloqueada por configuraci√≥n:', file);
                    return ok;
                });

                const tasks = allowed.map((def) => this.loadClip(def));
                await Promise.all(tasks);
                this.prepareQueue();
            }

            loadClip(definition) {
                return new Promise((resolve) => {
                    const restoreWarnings = suppressSkinningWarnings();
                    this.loader.load(
                        definition.file,
                        (anim) => {
                            restoreWarnings();
                            if (anim.animations && anim.animations.length > 0 && this.mixer) {
                                const clip = sanitizeClipRootMotion(anim.animations[0]);
                                const clipId = (definition.file || clip.name || '').toLowerCase();
                                const isNameBlocked = BLOCKED_ANIMATION_NAMES.some((pattern) =>
                                    clipId.includes(pattern)
                                );

                                if (isNameBlocked) {
                                    console.warn('Animaci√≥n bloqueada por nombre:', definition.file);
                                    resolve();
                                    return;
                                }

                                const action = this.mixer.clipAction(clip);
                                const isLoop = definition.loop === 'repeat';
                                action.loop = isLoop ? THREE.LoopRepeat : THREE.LoopOnce;
                                action.clampWhenFinished = !isLoop;
                                action.enabled = true;
                                this.actions.push({ ...definition, action });
                            }
                            resolve();
                        },
                        undefined,
                        (err) => {
                            restoreWarnings();
                            console.error('No se pudo cargar animaci√≥n', definition.file, err);
                            resolve();
                        }
                    );
                });
            }

            startAutoPlaylist() {
                if (!AUTO_ANIMATION_ENABLED || this.actions.length === 0) return;
                initAudioContext();
                this.playNext();
            }

            prepareQueue() {
                this.queue = this.generateAttackCombo();
            }

            playNext() {
                if (!this.mixer || this.actions.length === 0) return;
                if (this.queue.length === 0) this.prepareQueue();
                const next = this.queue.shift();
                if (!next) return;

                this.stopAutoAdvance();
                this.clearAudioCues();
                this.stopRestBreathing();
                this.resetCueState();

                if (this.activeAction && this.activeAction !== next.action) {
                    this.activeAction.fadeOut(ANIMATION_RULES.crossFade.out);
                }

                next.action.reset();
                next.action.fadeIn(ANIMATION_RULES.crossFade.in);
                next.action.play();
                this.activeAction = next.action;
                this.activeEntry = next;
                this.resetCueState();
                this.lastProgressTimestamp = performance.now?.() || Date.now();
                this.entryStartTimestamp = this.lastProgressTimestamp;
                const clipDurationMs = (next.action.getClip?.()?.duration || 0) * 1000;
                const bufferMs = Math.max((ANIMATION_RULES.autoDelayMs?.() || 0) * 1.5, 800);
                this.entryExpectedDurationMs = clipDurationMs + bufferMs;
                currentAnimationEntry = next;
                currentAnimationCategory = next.category || getClipCategory(next.name);
                this.onEntryStarted(next);

                updateDebugAnimation(next);
                handleCategoryTransitions(currentAnimationCategory);
                this.handleAudioFor(next);
                this.scheduleAutoAdvance(next);
            }

            generateAttackCombo() {
                const attacks = this.actions.filter(({ category }) => category === 'attack');
                const restPool = this.actions.filter(({ category }) => category === 'rest');
                const walks = this.actions.filter(({ category }) => category === 'walk');

                if (!attacks.length) return [];

                const desiredHits = [3, 4, 5, 6][Math.floor(Math.random() * 4)];
                const sequence = [];
                let lastAttack = null;
                const bagDistance = this.getDistanceToBag();
                const recentSet = new Set(this.recentAttackHistory);
                const farFromBag = bagDistance !== null && bagDistance > MIN_BAG_DISTANCE + 0.45;

                const pickAttack = () => {
                    const weightedPool = attacks
                        .map((entry) => ({
                            entry,
                            weight: this.weightAttackEntry(entry, { lastAttack, recentSet, bagDistance })
                        }))
                        .filter(({ weight }) => weight > 0);

                    if (!weightedPool.length) return attacks[0];
                    return this.pickWeightedEntry(weightedPool);
                };

                for (let i = 0; i < desiredHits; i++) {
                    const attack = pickAttack();
                    sequence.push(attack);
                    lastAttack = attack;
                    this.rememberAttack(attack);

                    const walkBias = farFromBag ? 0.25 : 0.55;
                    const shouldWalk = i < desiredHits - 1 && walks.length > 0 && Math.random() > walkBias;
                    if (shouldWalk) {
                        const walk = walks[Math.floor(Math.random() * walks.length)];
                        sequence.push(walk);
                    }
                }

                const tailWalkBias = farFromBag ? 0.35 : 0.65;
                if (walks.length && Math.random() > tailWalkBias) {
                    sequence.push(walks[Math.floor(Math.random() * walks.length)]);
                }

                if (restPool.length) {
                    const rest = restPool[Math.floor(Math.random() * restPool.length)];
                    sequence.push(rest);
                }

                return sequence;
            }

            pickWeightedEntry(weightedPool) {
                const total = weightedPool.reduce((sum, { weight }) => sum + weight, 0);
                if (total <= 0) return weightedPool[0]?.entry || null;

                let roll = Math.random() * total;
                for (const { entry, weight } of weightedPool) {
                    roll -= weight;
                    if (roll <= 0) return entry;
                }

                return weightedPool[weightedPool.length - 1]?.entry || null;
            }

            weightAttackEntry(entry, { lastAttack, recentSet, bagDistance }) {
                let weight = 1;
                const id = (entry.file || entry.name || '').toLowerCase();
                const isLongRange = id.includes('jab') || id.includes('cross') || id.includes('lead');
                const isCloseRange =
                    id.includes('hook') || id.includes('upper') || id.includes('punching bag') || id.includes('elbow');

                if (bagDistance !== null) {
                    if (bagDistance > MIN_BAG_DISTANCE + 0.4 && isLongRange) weight += 0.8;
                    if (bagDistance < MIN_BAG_DISTANCE + 0.2 && isCloseRange) weight += 0.8;
                    if (bagDistance > MIN_BAG_DISTANCE + 0.6 && isCloseRange) weight *= 0.7;
                }

                if (lastAttack === entry) weight *= 0.45;
                if (recentSet.has(entry)) weight *= 0.65;

                return Math.max(weight, 0.15);
            }

            rememberAttack(entry) {
                this.recentAttackHistory.push(entry);
                const maxHistory = 4;
                if (this.recentAttackHistory.length > maxHistory) {
                    this.recentAttackHistory.splice(0, this.recentAttackHistory.length - maxHistory);
                }
            }

            getDistanceToBag() {
                if (!tysonRoot || !bagMesh) return null;
                tmpVecA.copy(tysonRoot.position).sub(bagMesh.position);
                tmpVecA.y = 0;
                return tmpVecA.length();
            }

            notifyIncomingAction() {
                this.requestWalkInterrupt('incoming-action');
            }

            requestWalkInterrupt(reason = 'external') {
                this.pendingWalkInterrupt = true;
                this.processWalkInterrupts();
            }

            estimateWalkStepDuration(entry) {
                const clip = entry?.action?.getClip?.();
                const clipMs = clip?.duration ? clip.duration * 1000 : 0;
                const estimate = clipMs ? clipMs * 0.6 : 800;
                return Math.min(1200, Math.max(320, estimate));
            }

            onEntryStarted(entry) {
                if (!entry) return;
                if (entry.category === 'walk') {
                    this.walkStartTimestamp = performance.now?.() || Date.now();
                    this.walkLoopAtLastCheck = 0;
                    this.walkStepCount = 0;
                    this.walkStepDurationMs = this.estimateWalkStepDuration(entry);
                } else {
                    this.pendingWalkInterrupt = false;
                }
            }

            processWalkInterrupts() {
                if (!this.activeEntry || this.activeEntry.category !== 'walk') {
                    if (this.activeEntry && this.activeEntry.category !== 'walk') {
                        this.pendingWalkInterrupt = false;
                    }
                    this.walkStepCount = 0;
                    this.walkLoopAtLastCheck = 0;
                    return;
                }

                const now = performance.now?.() || Date.now();
                const loop = this.actionTimeState?.loop || 0;
                if (loop !== this.walkLoopAtLastCheck) {
                    this.walkStepCount += loop - this.walkLoopAtLastCheck;
                    this.walkLoopAtLastCheck = loop;
                }

                if (!this.walkStartTimestamp) this.walkStartTimestamp = now;
                const elapsed = now - this.walkStartTimestamp;
                const firstStepDone = this.walkStepCount > 0 || elapsed >= this.walkStepDurationMs;

                if (this.pendingWalkInterrupt && firstStepDone) {
                    this.pendingWalkInterrupt = false;
                    this.cutCurrentWalk();
                }
            }

            handleAudioFor(entry) {
                const category = entry.category || getClipCategory(entry.name);
                this.handleRestBreathing(category);

                if (category === 'attack') {
                    this.scheduleAttackAudio(entry);
                } else if (category === 'defense') {
                    this.scheduleDefenseAudio(entry);
                }
            }

            scheduleAutoAdvance(entry) {
                const duration = entry.action.getClip()?.duration || 3;
                this.queueMixerCue('auto-advance', entry, duration + ANIMATION_RULES.autoDelayMs() / 1000, () => {
                    this.playNext();
                });
            }

            stopAutoAdvance() {
                this.removeCues('auto-advance');
            }

            cutCurrentWalk() {
                if (!this.activeEntry || this.activeEntry.category !== 'walk') return;

                this.stopAutoAdvance();
                this.clearAudioCues();
                if (this.activeAction) {
                    this.activeAction.fadeOut(0.12);
                }
                this.playNext();
            }

            cutWalkIfTooClose(distance) {
                if (!distance || distance > MIN_BAG_DISTANCE + 0.05) return;
                this.cutCurrentWalk();
            }

            scheduleAttackAudio(entry) {
                const clip = entry.action?.getClip?.();
                if (!clip || !(typeof entry.name === 'string' && entry.name.includes('animaciones/ataque/'))) return;

                const { cueTimes, referenceTimes } = extractImpactCueTimes(clip);
                const validatedCueTimes = validateImpactCueTimes(cueTimes, clip, referenceTimes);
                const shoutCueIndex = Math.random() > 0.4 ? Math.floor(Math.random() * validatedCueTimes.length) : -1;

                validatedCueTimes.forEach((timeSec, idx) => {
                    this.queueAudioCue(entry, timeSec, () => {
                        if (!audioInitialized) return;
                        playImpactSound(visualConfig.bag.punchForce);
                        if (idx === shoutCueIndex) playShout();
                    }, { repeatEachLoop: true });
                });
            }

            scheduleDefenseAudio(entry) {
                const clip = entry.action?.getClip?.();
                if (!clip) return;

                const { cueTimes, referenceTimes } = extractImpactCueTimes(clip);
                const validatedCueTimes = validateImpactCueTimes(cueTimes, clip, referenceTimes);
                const pickTime = validatedCueTimes.length ? validatedCueTimes[0] : clip.duration * 0.45;

                this.queueAudioCue(entry, pickTime, () => {
                    if (!audioInitialized) return;
                    playImpactSound(visualConfig.bag.punchForce * 0.6);
                    if (Math.random() > 0.6) playBreath();
                }, { repeatEachLoop: true });
            }

            handleRestBreathing(category) {
                if (category === 'rest') {
                    this.restBreathing = true;
                    this.scheduleRestBreath(this.activeEntry, ANIMATION_RULES.rest.initialDelayMs());
                } else {
                    this.stopRestBreathing();
                }
            }

            scheduleRestBreath(entry, delayMs) {
                if (!this.restBreathing) return;
                this.removeCues('rest-breath');
                this.queueActionCue('rest-breath', entry, delayMs / 1000, () => {
                    if (!this.restBreathing) return;
                    if (audioInitialized) playBreath();
                    this.scheduleRestBreath(entry, ANIMATION_RULES.rest.cadenceMs());
                });
            }

            stopRestBreathing() {
                this.restBreathing = false;
                this.removeCues('rest-breath');
            }

            queueAudioCue(entry, timeSec, cb, options = {}) {
                this.queueActionCue('audio', entry, timeSec, cb, options);
            }

            clearAudioCues() {
                this.removeCues('audio');
            }

            queueActionCue(tag, entry, clipTime, cb, { repeatEachLoop = false } = {}) {
                if (!this.mixer || !entry?.action || entry.action !== this.activeAction) return;
                const clipDuration = entry.action.getClip?.()?.duration || 0;
                const requiredLoop = clipDuration > 0 ? Math.floor(clipTime / clipDuration) : 0;
                const normalizedTime = clipDuration > 0 ? clipTime % clipDuration : clipTime;
                this.cues.push({
                    tag,
                    action: entry.action,
                    mode: 'action',
                    targetTime: normalizedTime,
                    requiredLoop,
                    repeatEachLoop,
                    lastLoopFired: requiredLoop - 1,
                    callback: () => {
                        if (this.activeEntry !== entry) return;
                        cb();
                    }
                });
            }

            queueMixerCue(tag, entry, delaySeconds, cb) {
                if (!this.mixer || !entry?.action || entry.action !== this.activeAction) return;
                this.cues.push({
                    tag,
                    action: entry.action,
                    mode: 'mixer',
                    targetTime: this.mixer.time + delaySeconds,
                    callback: () => {
                        if (this.activeEntry !== entry) return;
                        cb();
                    }
                });
            }

            removeCues(tag = null) {
                if (tag === null) {
                    this.cues = [];
                    return;
                }
                this.cues = this.cues.filter((cue) => cue.tag !== tag);
            }

            resetCueState() {
                this.removeCues();
                if (this.activeAction) {
                    this.actionTimeState = {
                        action: this.activeAction,
                        time: this.activeAction.time,
                        prevTime: this.activeAction.time,
                        loop: 0
                    };
                    this.lastProgressTimestamp = performance.now?.() || Date.now();
                } else {
                    this.actionTimeState = null;
                }
            }

            processActionTime() {
                if (!this.activeAction) {
                    this.actionTimeState = null;
                    return;
                }

                const currentTime = this.activeAction.time;
                if (!this.actionTimeState || this.actionTimeState.action !== this.activeAction) {
                    this.actionTimeState = { action: this.activeAction, time: currentTime, prevTime: currentTime, loop: 0 };
                    this.lastProgressTimestamp = performance.now?.() || Date.now();
                    return;
                }

                const prevTime = this.actionTimeState.time;
                const looped = currentTime + 1e-4 < prevTime;
                const nextLoop = looped ? this.actionTimeState.loop + 1 : this.actionTimeState.loop;
                if (Math.abs(currentTime - prevTime) > 1e-4) {
                    this.lastProgressTimestamp = performance.now?.() || Date.now();
                }
                this.actionTimeState = { action: this.activeAction, time: currentTime, prevTime, loop: nextLoop };
            }

            processCues() {
                if (!this.mixer || !this.activeAction || !this.actionTimeState) {
                    this.removeCues();
                    return;
                }

                const mixerTime = this.mixer.time;
                const { time, prevTime, loop } = this.actionTimeState;

                this.cues = this.cues.filter((cue) => {
                    if (cue.action !== this.activeAction) return false;

                    if (cue.mode === 'mixer') {
                        if (mixerTime >= cue.targetTime) {
                            cue.callback();
                            return false;
                        }
                        return true;
                    }

                    const loopedBack = time + 1e-4 < prevTime;
                    const isOnEligibleLoop = loop >= (cue.requiredLoop ?? 0);
                    const crossed =
                        isOnEligibleLoop &&
                        ((time >= cue.targetTime && prevTime < cue.targetTime) ||
                            (loop > cue.lastLoopFired && time >= cue.targetTime));

                    if (isOnEligibleLoop && (crossed || (loopedBack && time >= cue.targetTime))) {
                        cue.lastLoopFired = loop;
                        cue.callback();
                        if (cue.repeatEachLoop) {
                            return true;
                        }
                        return false;
                    }

                    return true;
                });
            }

            update() {
                this.processActionTime();
                this.processCues();
                this.processWalkInterrupts();
                this.ensureNotStuck();
            }

            ensureNotStuck() {
                if (!AUTO_ANIMATION_ENABLED || !this.activeAction || !this.activeEntry) return;

                const clip = this.activeAction.getClip?.();
                const duration = clip?.duration ?? 0;
                const hasDuration = duration > 0;
                const nearEnd = hasDuration && this.activeAction.time >= duration - 1e-3;

                const now = performance.now?.() || Date.now();
                const sameAction = this.lastStuckWarning.action === this.activeAction;
                const elapsed = now - this.lastStuckWarning.time;
                const cooldownMs = 1500;
                const stalledFor = now - this.lastProgressTimestamp;
                const progressStalled = stalledFor > 800;
                const elapsedSinceStart = now - (this.entryStartTimestamp || now);
                const overExpectedDuration =
                    this.entryExpectedDurationMs > 0 && elapsedSinceStart > this.entryExpectedDurationMs;

                if (nearEnd) {
                    this.playNext();
                    return;
                }

                if (overExpectedDuration) {
                    console.warn('Animaci√≥n excedi√≥ el tiempo esperado, avanzando.');
                    this.lastStuckWarning = { action: this.activeAction, time: now };
                    this.playNext();
                    return;
                }

                if (!hasDuration || !progressStalled) return;

                if (sameAction && elapsed < cooldownMs) {
                    return;
                }

                console.warn('Detecci√≥n de animaci√≥n trabada, saltando a la siguiente.');
                this.lastStuckWarning = { action: this.activeAction, time: now };
                this.playNext();
            }
        }

        function loadTysonAnimations() {
            if (!tysonRoot) return;

            animationDirector = new AnimationSoundDirector({ mixer });
            registerWalkInterruptSignals();
            animationDirector.loadLibrary().then(() => {
                animationDirector.startAutoPlaylist();
            });
        }

        function keepTysonFeetOnFloor() {
            if (!tysonRoot) return;
            tysonRoot.updateMatrixWorld(true);

            // Usar solo los huesos de los pies para evitar que las manos
            // (cuando golpean hacia abajo) eleven todo el modelo al
            // calcular el contacto con el suelo.
            const footBones = [
                'LeftFoot', 'RightFoot',
                'LeftToeBase', 'RightToeBase',
                'LeftToe_End', 'RightToe_End'
            ];

            let minFootY = Infinity;
            footBones.forEach((name) => {
                const bone = getBone(name);
                if (!bone) return;
                const pos = new THREE.Vector3().setFromMatrixPosition(bone.matrixWorld);
                minFootY = Math.min(minFootY, pos.y);
            });

            if (!isFinite(minFootY)) {
                // Fallback: usar la bounding box completa si no se
                // localizaron los huesos esperados.
                tysonFloorBox.setFromObject(tysonRoot);
                minFootY = tysonFloorBox.min.y;
            }

            const correction = -minFootY;

            if (Math.abs(correction) > 1e-4) {
                tysonRoot.position.y += correction;
            }

            // Evitar que el root se desplace hacia adelante entre animaciones
            tysonRoot.position.x = lerp(tysonRoot.position.x, tysonTargetPosition.x, 0.25);
            tysonRoot.position.z = lerp(tysonRoot.position.z, tysonTargetPosition.z, 0.25);
            tysonRoot.updateMatrixWorld(true);
        }

        // --- MediaPipe Pose ---
        function resizeCanvasToVideo() {
            if (!videoElement || !canvasElement) return;
            const rect = videoElement.getBoundingClientRect();
            if (!rect.width || !rect.height) return;
            canvasElement.width = rect.width * window.devicePixelRatio;
            canvasElement.height = rect.height * window.devicePixelRatio;
            canvasElement.style.width = rect.width + 'px';
            canvasElement.style.height = rect.height + 'px';
        }

        if (videoElement) {
            videoElement.onloadedmetadata = () => resizeCanvasToVideo();
            window.addEventListener('resize', () => {
                if (videoElement.videoWidth > 0) resizeCanvasToVideo();
            });
        }

        function onResultsPose(results) {
            if (!ENABLE_MOCAP_BLEND) return;
            if (canvasCtx && canvasElement) {
                canvasCtx.save();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

                const width = canvasElement.width;
                const height = canvasElement.height;

                if (results.image) {
                    canvasCtx.drawImage(results.image, 0, 0, width, height);
                }

                if (results.poseLandmarks) {
                    const landmarks = results.poseLandmarks;

                    smoothedLandmarks = landmarks.map((lm, i) => {
                        const prev = lastPoseLandmarks ? lastPoseLandmarks[i] : null;
                        return lerpLandmark(prev, lm, 0.4);
                    });
                    lastPoseLandmarks = smoothedLandmarks;

                    // Si quer√©s ver skeleton, descomenta:
                    // window.drawConnectors(canvasCtx, smoothedLandmarks, window.POSE_CONNECTIONS, {
                    //     color: '#22c55e', lineWidth: 2,
                    // });
                    // window.drawLandmarks(canvasCtx, smoothedLandmarks, {
                    //     color: '#60a5fa', lineWidth: 1, radius: 2,
                    // });

                    updateModelFromPose(smoothedLandmarks);
                }

                canvasCtx.restore();
            } else if (results.poseLandmarks) {
                const landmarks = results.poseLandmarks;
                smoothedLandmarks = landmarks.map((lm, i) => {
                    const prev = lastPoseLandmarks ? lastPoseLandmarks[i] : null;
                    return lerpLandmark(prev, lm, 0.4);
                });
                lastPoseLandmarks = smoothedLandmarks;
                updateModelFromPose(smoothedLandmarks);
            }
        }

        function initPose() {
            const Pose = window.Pose;
            if (!Pose) {
                console.error('MediaPipe Pose no est√° disponible');
                return;
            }

            poseInstance = new Pose({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
            });
            poseInstance.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: false,
                smoothSegmentation: false,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5,
            });
            poseInstance.onResults(onResultsPose);
        }

        async function startCapture() {
            if (!videoElement || !canvasElement) return false;
            if (capturing) return true;

            if (!poseInstance) initPose();
            if (!poseInstance) return false;

            const constraints = {
                audio: false,
                video: {
                    width: { ideal: 960 },
                    height: { ideal: 540 },
                    frameRate: { ideal: 30 },
                },
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                await videoElement.play();

                capturing = true;
                captureMocapInitialPose();
                mocapStarted = true;
                updateWebcamUiState(true);
                resizeCanvasToVideo();

                const CameraMP = window.Camera;
                if (!CameraMP) {
                    console.error('MediaPipe Camera no est√° disponible');
                    stopCapture();
                    return false;
                }

                if (cameraMP) {
                    cameraMP.stop();
                    cameraMP = null;
                }

                cameraMP = new CameraMP(videoElement, {
                    onFrame: async () => {
                        if (!capturing) return;
                        await poseInstance.send({ image: videoElement });
                    },
                    width: videoElement.videoWidth,
                    height: videoElement.videoHeight,
                });
                cameraMP.start();
                return true;
            } catch (err) {
                console.error('Error al iniciar c√°mara:', err);
                capturing = false;
                updateWebcamUiState(false);
                return false;
            }
        }

        function stopCapture() {
            capturing = false;
            mocapStarted = false;
            mocapInitialRootPosition = null;
            mocapInitialRootQuaternion = null;
            mocapInitialHipsPosition = null;
            mocapInitialHipsQuaternion = null;

            if (cameraMP) {
                cameraMP.stop();
                cameraMP = null;
            }

            if (videoElement && videoElement.srcObject) {
                const tracks = videoElement.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            if (videoElement) {
                videoElement.pause();
            }

            if (poseInstance && typeof poseInstance.close === 'function') {
                poseInstance.close();
            }
            poseInstance = null;

            if (canvasCtx && canvasElement) {
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            }

            updateWebcamUiState(false);
        }

        function setupMocap() {
            if (!videoElement || !webcamToggleBtn) return;

            updateWebcamUiState(false);

            const toggleWebcam = async () => {
                if (capturing) {
                    stopCapture();
                } else {
                    const started = await startCapture();
                    if (!started) {
                        stopCapture();
                    }
                }
            };

            webcamToggleBtn.addEventListener('click', toggleWebcam);
        }

        // Seguimiento de manos para detectar golpes
        let lastLeftHandPos = null;
        let lastRightHandPos = null;
        let lastLeftFistPos = null;
        let lastRightFistPos = null;

        function updatePosePunch(dt) {
            if (leftFistBody && rightFistBody) return;
            if (!skeleton || !bagBody || !bagMesh) return;

            const bagPos = bagMesh.position.clone();

            const checkHand = (boneName, lastPos, isLeft) => {
                const bone = getBone(boneName);
                if (!bone) return lastPos;

                const worldPos = new THREE.Vector3().setFromMatrixPosition(bone.matrixWorld);

                if (lastPos) {
                    const vel = worldPos.clone().sub(lastPos).divideScalar(Math.max(dt, 0.0001));
                    const speed = vel.length();

                    const distance = worldPos.distanceTo(bagPos);
                    const dirToBag = bagPos.clone().sub(worldPos).normalize();
                    const forwardFactor = vel.dot(dirToBag);

                    // El boxeador mantiene una distancia m√≠nima al saco (MIN_BAG_DISTANCE),
                    // por lo que el umbral de detecci√≥n del golpe debe respetar ese rango.
                    const maxPunchDistance = MIN_BAG_DISTANCE + 0.2;

                    if (speed > 1.5 && forwardFactor > 0.4 && distance < maxPunchDistance && bagSimulation) {
                        const punchResult = bagSimulation.applyPunch(vel, worldPos, isLeft);
                        if (punchResult) {
                            if (!audioInitialized) initAudioContext();
                            const impactForce = visualConfig.bag.punchForce * punchResult.normalizedImpact;
                            playImpactSound(impactForce);
                            playHeavyImpactSound(impactForce);

                            registerPunch(Math.min(1, punchResult.punchData.normalSpeed / 6));
                        }
                    }
                }

                return worldPos;
            };

            lastLeftHandPos  = checkHand('LeftHand',  lastLeftHandPos,  true);
            lastRightHandPos = checkHand('RightHand', lastRightHandPos, false);
        }

        // ============================
        //      ESCENA GYM + SACO
        // ============================
        (async function boot() {
            await init();
            animate();
        })();

        async function init() {
            const container = document.getElementById('canvas-container');
            noiseGen = new SimplexNoise();

            applyPresetBagSettings(currentPreset);
            applyMobileSimplifications();
            setupDebugPanelToggle();
            setupBagControls();
            setupPunchControls();
            setupLightingControls();

            initScene();
            initRenderer(container);
            initCamera();
            initControls();
            initPostProcessing();

            initWorld();

            const textures = await buildGymTextures();
            generateEnvMap();

            initLights();

            const envProps = createEnvironment(textures);
            initPhysics(textures, envProps);

            setupMuteButton();
            setupPresetButton();
            setupViewButton();
            setupCinematicCameraButton();
            setupFreeCameraControls();
            setupUiFxEvents();
            setupMobileControls();
            setupAudioUnlockListeners();

            // Tyson + webcam
            loadTysonModel();
            if (ENABLE_MOCAP_BLEND) {
                setupMocap();
            }

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown, { passive: true });
        }

        function initScene() {
            scene = new THREE.Scene();
            const preset = lightingPresets[currentPreset];
            scene.background = new THREE.Color(preset.background);
            baseFogDensity = preset.fogDensity;
            scene.fog = new THREE.FogExp2(preset.fogColor, baseFogDensity);
        }

        function initRenderer(container) {
            renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.0 : 1.5));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = !isMobile;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            container.appendChild(renderer.domElement);
        }

        function initPostProcessing() {
            if (isMobile) {
                composer = null;
                bloomPass = null;
                bokehPass = null;
                return;
            }

            composer = new EffectComposer(renderer);
            
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.6,
                0.55,
                0.22
            );
            composer.addPass(bloomPass);

            bokehPass = new BokehPass(scene, camera, {
                focus: 2.0,
                aperture: 0.00015,
                maxblur: 0.015,
                width: window.innerWidth,
                height: window.innerHeight
            });
            composer.addPass(bokehPass);

            const outputPass = new OutputPass();
            composer.addPass(outputPass);

            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function generateEnvMap() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            const envScene = new THREE.Scene();
            envScene.background = new THREE.Color(0x111111);
            const l1 = new THREE.PointLight(0xffffff, 10); l1.position.set(5, 5, 5); envScene.add(l1);
            const l2 = new THREE.PointLight(0x4444ff, 5); l2.position.set(-5, 2, -5); envScene.add(l2);
            const envRT = pmremGenerator.fromScene(envScene);
            scene.environment = envRT.texture;
            envRT.texture.needsUpdate = true;
            envRT.dispose();
            pmremGenerator.dispose();
        }

        function initCamera() {
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.copy(defaultCameraPosition);
        }

        function initControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.target.copy(targetBase);
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.minDistance = 0.6;
            controls.maxDistance = 8.0;
            controls.enablePan = false;
            applyCameraControlLocks();
        }

        async function buildGymTextures() {
            const textures = generateProceduralTextures();
            textures.posterPool = await loadPosterPool(textures.posterPlaceholder, textures.posterCover);
            return textures;
        }

        // --- TEXTURAS PROCEDURALES ---
        function generateProceduralTextures() {
            const width = 1024;
            const createTex = (drawFn) => {
                const cvs = document.createElement('canvas');
                cvs.width = cvs.height = width;
                const ctx = cvs.getContext('2d');
                drawFn(ctx, width);
                const t = new THREE.CanvasTexture(cvs);
                t.wrapS = t.wrapT = THREE.RepeatWrapping;
                t.colorSpace = THREE.SRGBColorSpace;
                return t;
            };

            const leatherColor = createTex((ctx, w) => {
                const img = ctx.createImageData(w, w);
                for(let i=0; i<img.data.length; i+=4) {
                    const x = (i/4)%w, y=Math.floor((i/4)/w);
                    const n = noiseGen.noise2D(x*0.02, y*0.02)*0.5+0.5;
                    const grain = noiseGen.noise2D(x*0.2, y*0.2)*0.1;
                    let val = 60 + n*30 + grain*10; 
                    const vFactor = y/w; 
                    if(vFactor > 0.7) val *= (1.0 - (vFactor-0.7)*1.5); 
                    const dx = x - w/2; const dy = y - w/2;
                    const d = Math.sqrt(dx*dx + dy*dy) / (w/2);
                    if(d < 0.6) val += (1.0-d)*25;
                    if(vFactor < 0.05 || vFactor > 0.95) val *= 0.6;
                    img.data[i]=val; img.data[i+1]=val*0.7; img.data[i+2]=val*0.5; img.data[i+3]=255;
                }
                ctx.putImageData(img,0,0);
                ctx.strokeStyle = '#221100'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(w*0.25, 0); ctx.lineTo(w*0.25, w); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(w*0.75, 0); ctx.lineTo(w*0.75, w); ctx.stroke();
                ctx.strokeStyle = '#aa8866'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(w*0.25-2, 0); ctx.lineTo(w*0.25-2, w); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(w*0.75+2, 0); ctx.lineTo(w*0.75+2, w); ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#332211'; ctx.fillRect(w*0.35, w*0.3, w*0.3, w*0.15);
                ctx.strokeStyle = '#664422'; ctx.lineWidth=2; ctx.strokeRect(w*0.35, w*0.3, w*0.3, w*0.15);
                ctx.fillStyle = '#ccaa88'; ctx.font = 'bold 80px Impact'; ctx.textAlign = 'center';
                ctx.fillText("TITAN", w*0.5, w*0.41);
            });

            const leatherNormal = createTex((ctx, w) => {
                const img = ctx.createImageData(w, w);
                for(let i=0; i<img.data.length; i+=4) {
                    const x = (i/4)%w, y=Math.floor((i/4)/w);
                    const scratch = Math.random() > 0.99 ? 1.0 : 0.0;
                    const r = 128 + (Math.random()-0.5)*10 + scratch*20;
                    const g = 128 + (Math.random()-0.5)*10;
                    img.data[i]=r; img.data[i+1]=g; img.data[i+2]=255; img.data[i+3]=255;
                }
                ctx.putImageData(img,0,0);
                ctx.fillStyle = 'rgba(128,128,255,1.0)';
                ctx.strokeStyle = '#a0a0ff'; ctx.lineWidth=4; ctx.strokeRect(w*0.35, w*0.3, w*0.3, w*0.15);
                ctx.fillStyle = '#c0c0ff'; ctx.font = 'bold 80px Impact'; ctx.textAlign = 'center';
                ctx.fillText("TITAN", w*0.5, w*0.41);
                ctx.strokeStyle = '#6060ff'; ctx.lineWidth = 6;
                ctx.beginPath(); ctx.moveTo(w*0.25, 0); ctx.lineTo(w*0.25, w); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(w*0.75, 0); ctx.lineTo(w*0.75, w); ctx.stroke();
            });

            const leatherRough = createTex((ctx, w) => {
                ctx.fillStyle = '#999999'; ctx.fillRect(0,0,w,w);
                const img = ctx.createImageData(w, w);
                for(let i=0; i<img.data.length; i+=4) {
                    const x = (i/4)%w, y=Math.floor((i/4)/w);
                    const n = noiseGen.noise2D(x*0.03, y*0.03);
                    const dx = x - w/2; const dy = y - w/2;
                    const d = Math.sqrt(dx*dx + dy*dy) / (w/2);
                    let val = 160 + n * 40; 
                    if(d < 0.5) val -= 60;
                    if(d < 0.7 && d > 0.5) val += 30;
                    if(Math.random() > 0.995) val = 255;
                    img.data[i]=val; img.data[i+1]=val; img.data[i+2]=val; img.data[i+3]=255;
                }
                ctx.putImageData(img,0,0);
                ctx.fillStyle = '#666666'; ctx.fillRect(w*0.35, w*0.3, w*0.3, w*0.15);
            });

            const floorColor = createTex((ctx, w) => {
                ctx.fillStyle = '#151515'; ctx.fillRect(0,0,w,w);
                for(let i=0; i<100; i++) {
                    const x = Math.random()*w; const y = Math.random()*w;
                    const r = Math.random()*50 + 20;
                    const g = ctx.createRadialGradient(x,y,0,x,y,r);
                    g.addColorStop(0, 'rgba(255,255,255,0.05)');
                    g.addColorStop(1, 'transparent');
                    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
                }
            });
            const floorRough = createTex((ctx, w) => {
                ctx.fillStyle = '#bbbbbb'; ctx.fillRect(0,0,w,w); 
                for(let i=0; i<30; i++){
                    const x = w/2 + (Math.random()-0.5)*300; 
                    const y = w/2 + (Math.random()-0.5)*300;
                    const r = Math.random()*40 + 10;
                    const g = ctx.createRadialGradient(x,y,0,x,y,r);
                    g.addColorStop(0, '#222222'); 
                    g.addColorStop(1, 'rgba(187,187,187,0)'); 
                    ctx.fillStyle = g; ctx.beginPath(); ctx.scale(1, 0.5 + Math.random()); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.setTransform(1,0,0,1,0,0);
                }
                for(let i=0; i<20; i++){
                    const x = Math.random()*w; const y = Math.random()*w;
                    const r = Math.random()*15;
                    ctx.fillStyle = '#ffffff'; 
                    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
                }
            });
            // Increase repeat so a larger floor keeps a consistent texel density
            floorColor.repeat.set(14,6);
            floorRough.repeat.set(14,6);

            const wallMap = createTex((ctx, w) => {
                const img = ctx.createImageData(w, w);
                for(let i=0; i<img.data.length; i+=4) {
                    const x = (i/4)%w, y=Math.floor((i/4)/w);
                    const n = noiseGen.noise2D(x*0.01, y*0.05);
                    const val = 40 + n*10;
                    img.data[i]=val; img.data[i+1]=val; img.data[i+2]=val+2; img.data[i+3]=255;
                }
                ctx.putImageData(img,0,0);
            });
            wallMap.repeat.set(2,1);

            const posterPlaceholder = createTex((ctx, w) => {
                const bg = ctx.createLinearGradient(0, 0, w, w);
                bg.addColorStop(0, '#0f172a');
                bg.addColorStop(1, '#1e293b');
                ctx.fillStyle = bg;
                ctx.fillRect(0,0,w,w);

                const accent = ctx.createLinearGradient(0, 0, w, 0);
                accent.addColorStop(0, 'rgba(255, 99, 71, 0.65)');
                accent.addColorStop(1, 'rgba(255, 182, 73, 0.8)');
                ctx.fillStyle = accent;
                ctx.fillRect(w*0.18, w*0.2, w*0.64, w*0.08);
                ctx.fillRect(w*0.18, w*0.7, w*0.64, w*0.08);

                ctx.fillStyle = '#e2e8f0';
                ctx.textAlign = 'center';
                ctx.font = 'bold 140px Inter, sans-serif';
                ctx.fillText('BOX', w/2, w*0.45);
                ctx.font = '900 120px Inter, sans-serif';
                ctx.fillStyle = '#f8fafc';
                ctx.fillText('GYM', w/2, w*0.6);

                ctx.globalCompositeOperation = 'soft-light';
                ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                ctx.lineWidth = 6;
                for(let i=0; i<18; i++) {
                    const x = Math.random()*w; const y = Math.random()*w;
                    const r = w*0.02 + Math.random()*w*0.03;
                    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke();
                }
                ctx.globalCompositeOperation = 'source-over';
            });
            posterPlaceholder.wrapS = posterPlaceholder.wrapT = THREE.ClampToEdgeWrapping;

            const posterCover = createTex((ctx, w) => {
                const bg = ctx.createRadialGradient(w*0.3, w*0.35, w*0.1, w*0.5, w*0.5, w*0.7);
                bg.addColorStop(0, '#0b1222');
                bg.addColorStop(1, '#0f172a');
                ctx.fillStyle = bg;
                ctx.fillRect(0,0,w,w);

                const streaks = ctx.createLinearGradient(0, 0, w, w);
                streaks.addColorStop(0, 'rgba(80,160,255,0.5)');
                streaks.addColorStop(1, 'rgba(255,120,80,0.4)');
                ctx.fillStyle = streaks;
                ctx.fillRect(w*0.08, w*0.15, w*0.84, w*0.1);
                ctx.fillRect(w*0.08, w*0.72, w*0.84, w*0.06);

                ctx.fillStyle = '#e2e8f0';
                ctx.textAlign = 'center';
                ctx.font = '900 150px Inter, sans-serif';
                ctx.fillText('BOX', w/2, w*0.44);
                ctx.fillStyle = '#f97316';
                ctx.font = '900 120px Inter, sans-serif';
                ctx.fillText('FIGHT', w/2, w*0.6);

                ctx.font = '600 60px Inter, sans-serif';
                ctx.fillStyle = '#cbd5e1';
                ctx.fillText('EDICI√ìN ESPECIAL', w/2, w*0.7);

                ctx.strokeStyle = 'rgba(255,255,255,0.18)';
                ctx.lineWidth = 10;
                ctx.strokeRect(w*0.06, w*0.08, w*0.88, w*0.84);

                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                for(let i=0; i<14; i++) {
                    const x = Math.random()*w; const y = Math.random()*w;
                    const r = w*0.015 + Math.random()*w*0.025;
                    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
                }
                ctx.globalCompositeOperation = 'source-over';
            });
            posterCover.wrapS = posterCover.wrapT = THREE.ClampToEdgeWrapping;

            const windowMap = createTex((ctx, w) => {
                const grad = ctx.createLinearGradient(0, 0, 0, w);
                grad.addColorStop(0, '#152238');
                grad.addColorStop(1, '#0c111b');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, w, w);

                ctx.strokeStyle = 'rgba(255,255,255,0.08)';
                ctx.lineWidth = 8;
                ctx.strokeRect(10, 10, w-20, w-20);

                ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                ctx.lineWidth = 12;
                ctx.beginPath();
                ctx.moveTo(w/2, 8); ctx.lineTo(w/2, w-8);
                ctx.moveTo(8, w/2); ctx.lineTo(w-8, w/2);
                ctx.stroke();
            });

            return { bag: {c: leatherColor, n: leatherNormal, r: leatherRough}, floor: {c: floorColor, r: floorRough}, wall: wallMap, posterPlaceholder, posterCover, window: windowMap };
        }

        // --- ESCENA Y PROPS ---
        function createEnvironment(tex) {
            const staticMat = new CANNON.Material('floor-wall');
            const ceilingMat = new CANNON.Material('ceiling');
            const [featurePoster, accentPoster, sidePoster] = selectPosterSet(tex.posterPool, tex.posterPlaceholder);
            const wallMat = new THREE.MeshStandardMaterial({
                map: tex.wall, roughness: 0.9, color: 0x444444
            });

            function createRingAnnex(tex, floorGeo, floorMat, wallMat) {
                const annex = new THREE.Group();
                annex.position.copy(RING_POSITION);

                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                annex.add(floor);

                const wallH = 5.2;
                const longWall = new THREE.PlaneGeometry(12, wallH);
                const sideWall = new THREE.PlaneGeometry(12, wallH);

                const backWall = new THREE.Mesh(longWall, wallMat);
                backWall.position.set(0, wallH / 2, -6);
                backWall.receiveShadow = true;
                annex.add(backWall);

                const frontWall = new THREE.Mesh(longWall, wallMat);
                frontWall.rotation.y = Math.PI;
                frontWall.position.set(0, wallH / 2, 6);
                frontWall.receiveShadow = true;
                annex.add(frontWall);

                const leftWall = new THREE.Mesh(sideWall, wallMat);
                leftWall.rotation.y = Math.PI / 2;
                leftWall.position.set(-6, wallH / 2, 0);
                leftWall.receiveShadow = true;
                annex.add(leftWall);

                const rightWall = new THREE.Mesh(sideWall, wallMat);
                rightWall.rotation.y = -Math.PI / 2;
                rightWall.position.set(6, wallH / 2, 0);
                rightWall.receiveShadow = true;
                annex.add(rightWall);

                const ceiling = new THREE.Mesh(
                    new THREE.PlaneGeometry(12.5, 12.5),
                    new THREE.MeshStandardMaterial({
                        map: tex.wall,
                        roughness: 0.92,
                        color: 0x3a3a3a,
                        side: THREE.DoubleSide
                    })
                );
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.set(0, RING_CEILING_HEIGHT, 0);
                ceiling.receiveShadow = true;
                annex.add(ceiling);

                const trussMat = new THREE.MeshStandardMaterial({ color: 0x202020, metalness: 0.82, roughness: 0.32 });
                const beamGeoLong = new THREE.BoxGeometry(12.5, 0.1, 0.18);
                const beamGeoShort = new THREE.BoxGeometry(0.18, 0.1, 12.5);
                const beams = [
                    new THREE.Mesh(beamGeoLong, trussMat),
                    new THREE.Mesh(beamGeoLong, trussMat),
                    new THREE.Mesh(beamGeoShort, trussMat),
                    new THREE.Mesh(beamGeoShort, trussMat)
                ];
                beams[0].position.set(0, RING_CEILING_HEIGHT - 0.05, -3);
                beams[1].position.set(0, RING_CEILING_HEIGHT - 0.05, 3);
                beams[2].position.set(-3, RING_CEILING_HEIGHT - 0.05, 0);
                beams[3].position.set(3, RING_CEILING_HEIGHT - 0.05, 0);
                beams.forEach(b => { b.receiveShadow = true; b.castShadow = true; annex.add(b); });

                const rig = new THREE.Group();
                rig.position.set(0, RING_CEILING_HEIGHT - 0.25, 0);

                const rigBarGeo = new THREE.BoxGeometry(7.5, 0.08, 0.12);
                const rigCrossGeo = new THREE.BoxGeometry(0.12, 0.08, 7.5);
                const rigBarA = new THREE.Mesh(rigBarGeo, trussMat);
                const rigBarB = new THREE.Mesh(rigBarGeo, trussMat);
                const rigCrossA = new THREE.Mesh(rigCrossGeo, trussMat);
                const rigCrossB = new THREE.Mesh(rigCrossGeo, trussMat);
                rigBarA.position.set(0, 0, -1.8);
                rigBarB.position.set(0, 0, 1.8);
                rigCrossA.position.set(-1.8, 0, 0);
                rigCrossB.position.set(1.8, 0, 0);
                [rigBarA, rigBarB, rigCrossA, rigCrossB].forEach(mesh => { mesh.castShadow = true; rig.add(mesh); });

                const rigTargetsParent = new THREE.Object3D();
                rigTargetsParent.position.set(0, 0, 0);
                annex.add(rigTargetsParent);

                const overheadOffsets = [
                    new THREE.Vector3(-2.4, 0.16, -2.4),
                    new THREE.Vector3(2.4, 0.16, -2.4),
                    new THREE.Vector3(-2.4, 0.16, 2.4),
                    new THREE.Vector3(2.4, 0.16, 2.4)
                ];

                overheadOffsets.forEach((offset, idx) => {
                    const target = new THREE.Object3D();
                    target.position.set(0, 1.2, 0);
                    rigTargetsParent.add(target);

                    const spot = new THREE.SpotLight(
                        lightingPresets[currentPreset].ringSpotColor,
                        lightBases.ringSpot,
                        28,
                        Math.PI / 4.4,
                        0.5,
                        1.4
                    );
                    spot.position.copy(offset);
                    // Evitamos usar sombras en estos spots para no exceder el l√≠mite de texturas
                    // del shader (MAX_TEXTURE_IMAGE_UNITS), ya que en conjunto con el resto de
                    // focos generaba el error de validaci√≥n de programa en WebGL.
                    spot.castShadow = false;
                    spot.shadow.mapSize.set(1024, 1024);
                    spot.shadow.bias = -0.00012;
                    spot.decay = 1.5;
                    spot.penumbra = 0.86;
                    spot.target = target;
                    spot.name = `ringRigSpot-${idx}`;

                    ringSpotLights.push(spot);
                    rig.add(spot);
                });

                const rigGlow = new THREE.Mesh(
                    new THREE.CircleGeometry(1.2, 24),
                    new THREE.MeshBasicMaterial({
                        color: lightingPresets[currentPreset].ringColor,
                        transparent: true,
                        opacity: 0.35,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    })
                );
                rigGlow.rotation.x = -Math.PI / 2;
                rigGlow.position.set(0, -0.05, 0);
                rig.add(rigGlow);

                ringReflectorFixtures.push(rig);
                annex.add(rig);

                scene.add(annex);
            }

            const mainFloorGeo = new THREE.PlaneGeometry(40, 28);
            const ringFloorGeo = new THREE.PlaneGeometry(12, 12);
            const floorMat = new THREE.MeshStandardMaterial({
                map: tex.floor.c, roughnessMap: tex.floor.r, metalness: 0.1, color: 0xaaaaaa
            });
            const floor = new THREE.Mesh(mainFloorGeo, floorMat);
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            const floorBody = new CANNON.Body({ mass: 0, material: staticMat, shape: new CANNON.Plane() });
            floorBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
            world.addBody(floorBody);

            const wallH = 5;
            const featureWallOffset = 15;
            const featureWallX = 6 + featureWallOffset;
            const wL = new THREE.Mesh(new THREE.PlaneGeometry(3, wallH), wallMat);
            wL.position.set(-3.9, wallH/2, -5); wL.receiveShadow=true; scene.add(wL);
            const wR = new THREE.Mesh(new THREE.PlaneGeometry(5, wallH), wallMat);
            wR.position.set(2.1, wallH/2, -5); wR.receiveShadow=true; scene.add(wR);
            const wT = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), wallMat);
            wT.position.set(-1.4, 4, -5); wT.receiveShadow=true; scene.add(wT);

            const posterMat = new THREE.MeshStandardMaterial({
                map: featurePoster,
                roughness: 0.82,
                metalness: 0.05,
                side: THREE.DoubleSide
            });

            const posterA = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.8), posterMat);
            posterA.position.set(featureWallX - 0.15, 2.1, -1.8);
            posterA.rotation.y = -Math.PI / 2;
            scene.add(posterA);

            const posterBMat = new THREE.MeshStandardMaterial({
                map: accentPoster,
                roughness: 0.82,
                metalness: 0.05,
                side: THREE.DoubleSide
            });

            const posterB = new THREE.Mesh(new THREE.PlaneGeometry(1.35, 1.35), posterBMat);
            posterB.position.set(featureWallX - 0.15, 1.6, 1.2);
            posterB.rotation.y = -Math.PI / 2;
            scene.add(posterB);

            const windowWidth = 8.6;
            const windowHeight = 0.6;
            const windowY = 4.15;
            const windowX = featureWallX - 0.1;
            const windowGroup = new THREE.Group();
            const windowPane = new THREE.Mesh(
                new THREE.PlaneGeometry(windowWidth, windowHeight),
                new THREE.MeshStandardMaterial({
                    map: tex.window,
                    roughness: 0.32,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.9,
                    emissive: new THREE.Color(0x1b2435),
                    emissiveIntensity: 0.7,
                    side: THREE.DoubleSide
                })
            );
            windowPane.position.z = 0.01;

            const windowGlow = new THREE.Mesh(
                new THREE.PlaneGeometry(windowWidth * 1.08, windowHeight * 2.6),
                new THREE.MeshBasicMaterial({
                    color: 0x9fc8ff,
                    transparent: true,
                    opacity: 0.22,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                })
            );
            windowGlow.renderOrder = 1;
            windowGroup.add(windowGlow);
            windowGroup.add(windowPane);
            windowGroup.position.set(windowX, windowY, 0);
            windowGroup.rotation.y = -Math.PI / 2;
            scene.add(windowGroup);

            const windowRayGeo = new THREE.PlaneGeometry(windowWidth * 1.05, 3.6);
            const windowRayMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: new THREE.Color(0xbdd3ff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform vec3 uColor;
                    varying vec2 vUv;

                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
                    }

                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        float a = hash(i);
                        float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0));
                        float d = hash(i + vec2(1.0, 1.0));
                        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
                    }

                    void main() {
                        float beam = smoothstep(0.4, 0.0, abs(vUv.x * 2.0 - 1.0));
                        float drift = noise(vec2(vUv.x * 6.0, uTime * 0.35)) * 0.3;
                        float bands = smoothstep(0.5, 0.0, vUv.y) * 0.5;
                        float alpha = beam * (0.26 + drift + bands) * smoothstep(0.1, 0.0, vUv.y - 0.65);
                        alpha *= smoothstep(0.0, 0.08, vUv.y);
                        alpha *= smoothstep(1.0, 0.82, vUv.y);
                        if (alpha < 0.01) discard;
                        gl_FragColor = vec4(uColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            windowGodrayMesh = new THREE.Mesh(windowRayGeo, windowRayMat);
            windowGodrayMesh.position.set(windowX - 0.18, windowY - 0.1, windowGroup.position.z);
            windowGodrayMesh.rotation.set(-Math.PI / 2.9, -Math.PI / 2, 0);
            scene.add(windowGodrayMesh);

            doorLight = new THREE.RectAreaLight(0x4488ff, lightBases.door, 2, 3);
            doorLight.position.set(-1.4, 1.5, -5.2);
            doorLight.lookAt(-1.4, 1.5, 0);
            scene.add(doorLight);
            
            const godrayGeo = new THREE.PlaneGeometry(3.2, 4.8);
            const godrayMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: new THREE.Color(0x6ca8ff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform vec3 uColor;
                    varying vec2 vUv;

                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
                    }

                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        float a = hash(i);
                        float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0));
                        float d = hash(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) +
                               (c - a) * u.y * (1.0 - u.x) +
                               (d - b) * u.x * u.y;
                    }

                    void main() {
                        float centeredX = vUv.x * 2.0 - 1.0;
                        float beam = smoothstep(0.0, 0.85, 1.0 - abs(centeredX));
                        float streaks = noise(vec2(vUv.y * 6.0, uTime * 0.4)) * 0.6;
                        float bands = smoothstep(0.25, 0.0, abs(centeredX * 2.0));
                        float fog = (1.0 - vUv.y);
                        float alpha = beam * fog;
                        alpha *= 0.18 + (streaks + bands) * 0.15;
                        alpha *= smoothstep(0.0, 0.15, vUv.y);
                        alpha *= smoothstep(1.0, 0.8, vUv.y);
                        if (alpha < 0.01) discard;
                        gl_FragColor = vec4(uColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            doorGodrayMesh = new THREE.Mesh(godrayGeo, godrayMat);
            doorGodrayMesh.position.set(-1.4, 2.2, -4.9);
            scene.add(doorGodrayMesh);

            const sideWall = new THREE.Mesh(new THREE.PlaneGeometry(12, wallH), wallMat);
            sideWall.rotation.y = Math.PI/2;
            sideWall.position.set(-6, wallH/2, 0);
            sideWall.receiveShadow = true;
            scene.add(sideWall);

            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(12, wallH), wallMat);
            rightWall.rotation.y = -Math.PI/2;
            rightWall.position.set(featureWallX, wallH/2, 0);
            rightWall.receiveShadow = true;
            scene.add(rightWall);

            const posterGeo = new THREE.PlaneGeometry(1.2, 1.8);
            const sidePosterMat = new THREE.MeshStandardMaterial({ map: sidePoster, roughness: 0.8 });
            const p1 = new THREE.Mesh(posterGeo, sidePosterMat);
            p1.position.set(-5.95, 2.5, 1); p1.rotation.y = Math.PI/2; p1.rotation.z = -0.05;
            scene.add(p1);

            fanMesh = new THREE.Group();
            fanMesh.position.set(0, 4.2, 0);
            const motor = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.3), new THREE.MeshStandardMaterial({color:0x222222}));
            const bladeGeo = new THREE.BoxGeometry(2.5, 0.05, 0.3);
            const bladeMat = new THREE.MeshStandardMaterial({color:0x333333, metalness: 0.5, roughness: 0.6});
            for(let i=0; i<3; i++) {
                const blade = new THREE.Mesh(bladeGeo, bladeMat);
                blade.position.y = -0.1; blade.rotation.y = i * (Math.PI*2/3); blade.castShadow = true;
                fanMesh.add(blade);
            }
            fanMesh.add(motor);
            scene.add(fanMesh);

            const benchGroup = new THREE.Group();
            const legGeo = new THREE.BoxGeometry(0.1, 0.5, 0.4);
            const seatGeo = new THREE.BoxGeometry(1.5, 0.1, 0.5);
            const metal = new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.3});
            const leather = new THREE.MeshStandardMaterial({color: 0x222222, roughness: 0.6});
            const seat = new THREE.Mesh(seatGeo, leather); seat.position.y = 0.5; seat.castShadow=true;
            const l1 = new THREE.Mesh(legGeo, metal); l1.position.set(-0.6, 0.25, 0);
            const l2 = new THREE.Mesh(legGeo, metal); l2.position.set(0.6, 0.25, 0);
            benchGroup.add(seat, l1, l2);
            benchGroup.position.set(2.5, 0, 1.5); benchGroup.rotation.y = -0.5;
            scene.add(benchGroup);

            const dbGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3);
            const wGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.05);
            const dbMesh = new THREE.Group();
            dbMesh.add(new THREE.Mesh(dbGeo, metal));
            const w1 = new THREE.Mesh(wGeo, metal); w1.rotation.z=Math.PI/2; w1.position.x=-0.12;
            const w2 = new THREE.Mesh(wGeo, metal); w2.rotation.z=Math.PI/2; w2.position.x=0.12;
            dbMesh.add(w1, w2);
            dbMesh.position.set(2, 0.1, 2.5); dbMesh.rotation.y=Math.random(); dbMesh.castShadow=true;
            scene.add(dbMesh);

            const trainingWallZ = 12.0;
            const trainingWallWidth = 14;

            const trainingMat = new THREE.Mesh(
                new THREE.PlaneGeometry(8, 2.6),
                new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.85, metalness: 0.05 })
            );
            trainingMat.rotation.x = -Math.PI / 2;
            trainingMat.position.set(0.5, 0.02, trainingWallZ - 0.6);
            trainingMat.receiveShadow = true;
            scene.add(trainingMat);

            const trainingWall = new THREE.Mesh(new THREE.PlaneGeometry(trainingWallWidth, wallH), wallMat);
            trainingWall.position.set(0.5, wallH / 2, trainingWallZ);
            trainingWall.receiveShadow = true;
            scene.add(trainingWall);

            const [trainingPosterA, trainingPosterB] = selectPosterSet(tex.posterPool, tex.posterPlaceholder);

            const trainingPosterMatA = new THREE.MeshStandardMaterial({
                map: trainingPosterA,
                roughness: 0.82,
                metalness: 0.06,
                side: THREE.DoubleSide
            });

            const trainingPosterLeft = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.8), trainingPosterMatA);
            trainingPosterLeft.position.set(-1.8, 2.2, trainingWallZ - 0.02);
            trainingPosterLeft.rotation.y = Math.PI;
            scene.add(trainingPosterLeft);

            const trainingPosterMatB = new THREE.MeshStandardMaterial({
                map: trainingPosterB,
                roughness: 0.82,
                metalness: 0.06,
                side: THREE.DoubleSide
            });

            const trainingPosterRight = new THREE.Mesh(new THREE.PlaneGeometry(1.35, 1.5), trainingPosterMatB);
            trainingPosterRight.position.set(2.6, 2.0, trainingWallZ - 0.02);
            trainingPosterRight.rotation.y = Math.PI;
            scene.add(trainingPosterRight);

            const machine = new THREE.Group();
            const columnGeo = new THREE.BoxGeometry(0.12, 2.4, 0.35);
            const crossBarGeo = new THREE.BoxGeometry(2.4, 0.1, 0.16);
            const paddingGeo = new THREE.BoxGeometry(0.35, 0.18, 1.1);
            const machineMetal = new THREE.MeshStandardMaterial({ color: 0x2a2e36, metalness: 0.82, roughness: 0.32 });
            const machinePad = new THREE.MeshStandardMaterial({ color: 0x181818, roughness: 0.55 });

            const colA = new THREE.Mesh(columnGeo, machineMetal); colA.position.set(-1.2, 1.2, 0);
            const colB = new THREE.Mesh(columnGeo, machineMetal); colB.position.set(1.2, 1.2, 0);
            const topBar = new THREE.Mesh(crossBarGeo, machineMetal); topBar.position.set(0, 2.35, 0);
            const backrest = new THREE.Mesh(paddingGeo, machinePad); backrest.position.set(0, 1.2, -0.32);
            const seatPad = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.12, 0.8), machinePad);
            seatPad.position.set(0, 0.48, -0.22);

            [colA, colB, topBar, backrest, seatPad].forEach((mesh) => {
                mesh.castShadow = true; mesh.receiveShadow = true; machine.add(mesh);
            });

            const cable = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 2.2), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            cable.position.set(0, 1.2, 0.05);
            machine.add(cable);

            const pulley = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.04, 12, 26), machineMetal);
            pulley.rotation.x = Math.PI / 2;
            pulley.position.set(0, 2.15, 0.08);
            machine.add(pulley);

            machine.position.set(-1.4, 0, trainingWallZ - 0.5);
            scene.add(machine);

            const weightRack = new THREE.Group();
            const rackBase = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.12, 0.4), machineMetal);
            rackBase.position.y = 0.06;
            const rackPostL = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.7), machineMetal);
            rackPostL.position.set(-0.75, 0.4, -0.1);
            const rackPostR = rackPostL.clone(); rackPostR.position.x = 0.75;
            const rackShelf = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.08, 0.12), machineMetal);
            rackShelf.position.set(0, 0.75, -0.12);
            weightRack.add(rackBase, rackPostL, rackPostR, rackShelf);

            for (let i = 0; i < 5; i++) {
                const plate = new THREE.Mesh(new THREE.CylinderGeometry(0.2 + i * 0.04, 0.2 + i * 0.04, 0.05, 24), new THREE.MeshStandardMaterial({ color: 0x30343c, metalness: 0.85, roughness: 0.32 }));
                plate.rotation.x = Math.PI / 2;
                plate.position.set(-0.6 + i * 0.3, 0.38, -0.05 - i * 0.01);
                plate.castShadow = true; plate.receiveShadow = true;
                weightRack.add(plate);
            }

            weightRack.position.set(1.6, 0, trainingWallZ - 0.35);
            scene.add(weightRack);

            const speedBag = new THREE.Group();
            const stand = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, 1.3, 16), machineMetal);
            stand.position.y = 0.65;
            const plateTop = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.08, 20), machineMetal);
            plateTop.position.y = 1.3;
            const bagGeo = new THREE.SphereGeometry(0.16, 20, 20);
            const bagMat = new THREE.MeshStandardMaterial({ color: 0x8b2b1a, roughness: 0.35, metalness: 0.12 });
            const bag = new THREE.Mesh(bagGeo, bagMat);
            bag.scale.set(1, 1.4, 1);
            bag.position.y = 1.0;
            const string = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.28), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.6, roughness: 0.25 }));
            string.position.y = 1.16;
            [stand, plateTop, bag, string].forEach((mesh) => { mesh.castShadow = true; mesh.receiveShadow = true; speedBag.add(mesh); });
            speedBag.position.set(3.0, 0, trainingWallZ - 0.3);
            scene.add(speedBag);

            gltfLoader.load(
                'modelos/Dummy.glb',
                (gltf) => {
                    const fumo = gltf.scene || gltf;
                    fumo.scale.setScalar(0.82);
                    fumo.position.set(-3.2, 0, trainingWallZ - 0.4);
                    fumo.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    scene.add(fumo);
                },
                undefined,
                (err) => console.warn('No se pudo cargar el fumo:', err)
            );

            gltfLoader.load(
                'modelos/Bolsa.glb',
                (gltf) => {
                    const hangingBag = gltf.scene || gltf;
                    hangingBag.scale.setScalar(0.95);
                    hangingBag.position.set(4.6, 0, trainingWallZ - 0.2);
                    hangingBag.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    scene.add(hangingBag);
                },
                undefined,
                (err) => console.warn('No se pudo cargar la bolsa GLB de modelos:', err)
            );

            const trainingSpot = new THREE.SpotLight(lightingPresets[currentPreset].keyColor, 4.8, 12, Math.PI / 4.2, 0.55, 1.25);
            trainingSpot.position.set(-2.4, 4.7, trainingWallZ - 1.0);
            trainingSpot.target.position.set(-1.5, 1.9, trainingWallZ + 0.4);
            trainingSpot.castShadow = !isMobile;
            trainingSpot.shadow.mapSize.set(768, 768);
            scene.add(trainingSpot);
            scene.add(trainingSpot.target);
            trainingAreaLights.push({ light: trainingSpot, base: 4.8, colorKey: 'keyColor' });

            const trainingFill = new THREE.RectAreaLight(lightingPresets[currentPreset].fillColor, 3.4, 3.2, 1.2);
            trainingFill.position.set(2.5, 2.3, trainingWallZ + 0.05);
            trainingFill.lookAt(2.5, 1.4, trainingWallZ - 1.0);
            scene.add(trainingFill);
            trainingAreaLights.push({ light: trainingFill, base: 3.4, colorKey: 'fillColor' });

            const speedBagAccent = new THREE.PointLight(lightingPresets[currentPreset].accentColor, 2.6, 8, 1.4);
            speedBagAccent.position.set(3.0, 2.0, trainingWallZ - 0.4);
            scene.add(speedBagAccent);
            trainingAreaLights.push({ light: speedBagAccent, base: 2.6, colorKey: 'accentColor' });

            const trainingBackdrop = new THREE.SpotLight(
                lightingPresets[currentPreset].trainingSetColor,
                2.8,
                14,
                Math.PI / 3.4,
                0.55,
                1.05
            );
            trainingBackdrop.position.set(0.5, 3.1, trainingWallZ + 0.8);
            trainingBackdrop.target.position.set(0.5, 1.6, trainingWallZ - 0.5);
            trainingBackdrop.castShadow = !isMobile;
            trainingBackdrop.shadow.mapSize.set(768, 768);
            scene.add(trainingBackdrop);
            scene.add(trainingBackdrop.target);
            trainingAreaLights.push({ light: trainingBackdrop, base: 2.8, colorKey: 'trainingSetColor' });

            const lockerGeo = new THREE.BoxGeometry(0.8, 2.2, 0.6);
            const lockerMat = new THREE.MeshStandardMaterial({ color: 0x556677, metalness: 0.6, roughness: 0.4, envMapIntensity: 1.0 });
            const locker = new THREE.Mesh(lockerGeo, lockerMat);
            locker.position.set(4, 1.1, -4); locker.rotation.y = -0.3; locker.castShadow = true; locker.receiveShadow = true;
            scene.add(locker);

            if (DUST_ENABLED) {
                createDustParticles();
            }

            createRingAnnex(tex, ringFloorGeo, floorMat, wallMat);

            gltfLoader.load(
                RING_MODEL_URL,
                (gltf) => {
                    const ring = gltf.scene || gltf;
                    ring.position.copy(RING_POSITION);
                    ring.rotation.y = Math.PI / 2;
                    ring.scale.setScalar(0.2);
                    ring.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    scene.add(ring);
                },
                undefined,
                (err) => console.warn('No se pudo cargar el ring:', err)
            );

            const flWidth = 3.0;
            const flHeight = 0.35;
            const flY = 4.6;
            const flPositionsZ = [-2.5, 0.0, 2.5];
            for (let i = 0; i < flPositionsZ.length; i++) {
                const z = flPositionsZ[i];
                const fl = new THREE.RectAreaLight(0xf0f6ff, lightBases.fluorescent, flWidth, flHeight);
                fl.position.set(0, flY, z);
                fl.rotation.x = -Math.PI / 2;
                scene.add(fl);
                fluorescentLights.push(fl);

                const glow = new THREE.Mesh(
                    new THREE.PlaneGeometry(flWidth * 1.6, flHeight * 2.4),
                    new THREE.MeshBasicMaterial({
                        map: getSpriteTexture(),
                        color: 0xeef8ff,
                        transparent: true,
                        opacity: 0.45,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    })
                );
                glow.position.copy(fl.position);
                glow.rotation.x = fl.rotation.x;
                glow.renderOrder = 2;
                scene.add(glow);
                fluorescentGlowCards.push(glow);
            }

            createClock();
            return { staticMat, ceilingMat };
        }

        function createClock() {
            const clockGroup = new THREE.Group();
            const frame = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.05, 32), new THREE.MeshStandardMaterial({color:0x111}));
            frame.rotation.x = Math.PI/2;
            const face = new THREE.Mesh(new THREE.CircleGeometry(0.35, 32), new THREE.MeshBasicMaterial({color:0xeeeeee}));
            face.position.z = 0.03;
            const handMat = new THREE.MeshBasicMaterial({color:0x000});
            const secMat = new THREE.MeshBasicMaterial({color:0xaa0000});
            clockHandHour = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.25, 0.01), handMat);
            clockHandHour.position.z = 0.04; clockHandHour.geometry.translate(0, 0.1, 0);
            clockHandMin = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.32, 0.01), handMat);
            clockHandMin.position.z = 0.05; clockHandMin.geometry.translate(0, 0.15, 0);
            clockHandSec = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.32, 0.01), secMat);
            clockHandSec.position.z = 0.06; clockHandSec.geometry.translate(0, 0.1, 0);
            clockGroup.add(frame, face, clockHandHour, clockHandMin, clockHandSec);
            clockGroup.position.set(0, 3.5, -4.9);
            scene.add(clockGroup);
        }

        function updateClockHands(elapsedSeconds) {
            if (!clockHandSec) return;

            let seconds;
            let minutes;
            let hours;

            if (CLOCK_MODE === 'session') {
                seconds = elapsedSeconds % 60;
                minutes = (elapsedSeconds / 60) % 60;
                hours = (elapsedSeconds / 3600) % 12;
            } else {
                const now = new Date();
                seconds = now.getSeconds() + now.getMilliseconds() / 1000;
                minutes = now.getMinutes() + seconds / 60;
                hours = (now.getHours() % 12) + minutes / 60;
            }

            clockHandSec.rotation.z = -seconds * (Math.PI / 30);
            clockHandMin.rotation.z = -minutes * (Math.PI / 30);
            clockHandHour.rotation.z = -hours * (Math.PI / 6);
        }

        function createRingReflectorFixture(position, target) {
            const fixture = new THREE.Group();

            const poleMat = new THREE.MeshStandardMaterial({ color: 0x1e1e1e, metalness: 0.82, roughness: 0.32 });

            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, 0.9, 14), poleMat);
            pole.position.y = -0.45;
            fixture.add(pole);

            const glow = new THREE.Mesh(
                new THREE.CircleGeometry(0.16, 18),
                new THREE.MeshBasicMaterial({
                    color: lightingPresets[currentPreset].ringSpotColor,
                    transparent: true,
                    opacity: 1.0,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                })
            );
            glow.position.set(0, 0.18, 0.16);
            fixture.add(glow);

            const reflectorLight = new THREE.SpotLight(
                lightingPresets[currentPreset].ringSpotColor,
                lightBases.ringSpot * 0.82,
                24,
                Math.PI / 4.4,
                0.65,
                1.35
            );
            reflectorLight.position.set(0, 0.16, 0.05);
            // Mantener estos reflectores sin sombras reduce los shadow maps activos y
            // evita superar el m√°ximo de unidades de textura disponibles en fragment shader.
            reflectorLight.castShadow = false;
            reflectorLight.shadow.mapSize.set(512, 512);
            reflectorLight.shadow.bias = -0.00012;
            reflectorLight.name = 'ringFixtureLight';

            const reflectorTarget = new THREE.Object3D();
            reflectorTarget.position.set(0, -0.12, -2.6);
            fixture.add(reflectorTarget);
            reflectorLight.target = reflectorTarget;

            fixture.add(reflectorLight);
            ringSpotLights.push(reflectorLight);

            fixture.position.copy(position);
            fixture.lookAt(target);

            return fixture;
        }

        function initLights() {
            const preset = lightingPresets[currentPreset];
            ambientLight = new THREE.HemisphereLight(preset.ambientSky, preset.ambientGround, preset.ambientBase);
            scene.add(ambientLight);

            keyLight = new THREE.SpotLight(0xffaa77, lightBases.key);
            keyLight.position.set(0, 5.5, 0);
            keyLight.target.position.set(0, 1, 0);
            keyLight.angle = Math.PI * 0.38;
            keyLight.penumbra = 0.82;
            keyLight.distance = 16;
            keyLight.decay = 1.6;
            keyLight.castShadow = !isMobile;
            keyLight.shadow.mapSize.set(1024, 1024);
            keyLight.shadow.bias = -0.0001;
            scene.add(keyLight);
            scene.add(keyLight.target);

            fillLight = new THREE.PointLight(0x6c7cff, lightBases.fill);
            const fillTarget = bagMesh ? bagMesh.position : BAG_LIGHT_BASE_POSITION;
            fillLight.position.copy(fillTarget).add(new THREE.Vector3(2.8, 0.4, 2.8));
            scene.add(fillLight);

            bagLight = new THREE.SpotLight(preset.bagLightColor || preset.keyColor, lightBases.bag, 10, Math.PI / 4.2, 0.6, 1.35);
            bagLight.castShadow = !isMobile;
            bagLight.shadow.mapSize.set(768, 768);
            bagLight.shadow.bias = -0.00012;
            bagLight.shadow.radius = 3.5;
            bagLightTarget = new THREE.Object3D();
            scene.add(bagLightTarget);
            bagLight.target = bagLightTarget;
            const bagAnchor = bagMesh ? bagMesh.position : BAG_LIGHT_BASE_POSITION;
            bagLight.position.copy(bagAnchor).add(BAG_LIGHT_OFFSET);
            scene.add(bagLight);

            ringLight = new THREE.PointLight(0xffdd88, lightBases.ring, 16, 1.5);
            ringLight.position.set(RING_POSITION.x, RING_CEILING_HEIGHT - 1.0, RING_POSITION.z + 0.15);
            scene.add(ringLight);

            rimLight = new THREE.SpotLight(0x6688ff, lightBases.rim, 8, Math.PI / 4, 0.5, 1);
            rimLight.position.set(0, 2.0, -2.0);
            rimLight.target.position.set(0, 1.7, 0);
            rimLight.castShadow = false;
            scene.add(rimLight);
            scene.add(rimLight.target);

            const accentPositions = [
                new THREE.Vector3(4.25, 1.35, -2.35),
                new THREE.Vector3(-4.25, 1.35, -2.35),
                new THREE.Vector3(4.25, 1.35, 2.45),
                new THREE.Vector3(-4.25, 1.35, 2.45)
            ];

            accentPositions.forEach((pos) => {
                const accent = new THREE.PointLight(preset.accentColor, lightBases.accent, 12, 1.4);
                accent.position.copy(pos);
                scene.add(accent);
                accentLights.push(accent);
            });

            const ringSpotSettings = [
                {
                    pos: RING_POSITION.clone().add(new THREE.Vector3(-3.8, 4.4, 2.2)),
                    target: RING_POSITION.clone().add(new THREE.Vector3(0, 1.2, 0))
                },
                {
                    pos: RING_POSITION.clone().add(new THREE.Vector3(3.8, 4.4, 2.2)),
                    target: RING_POSITION.clone().add(new THREE.Vector3(0, 1.2, 0))
                },
                {
                    pos: RING_POSITION.clone().add(new THREE.Vector3(-3.4, 4.4, -2.5)),
                    target: RING_POSITION.clone().add(new THREE.Vector3(0, 1.1, 0))
                },
                {
                    pos: RING_POSITION.clone().add(new THREE.Vector3(3.4, 4.4, -2.5)),
                    target: RING_POSITION.clone().add(new THREE.Vector3(0, 1.1, 0))
                }
            ];

            const ringCornerSpotSettings = [
                {
                    pos: RING_POSITION.clone().add(new THREE.Vector3(-2.6, 3.3, -2.6)),
                    target: RING_POSITION.clone().add(new THREE.Vector3(-1.1, 1.1, -1.1))
                },
                {
                    pos: RING_POSITION.clone().add(new THREE.Vector3(2.6, 3.3, -2.6)),
                    target: RING_POSITION.clone().add(new THREE.Vector3(1.1, 1.1, -1.1))
                },
                {
                    pos: RING_POSITION.clone().add(new THREE.Vector3(-2.6, 3.3, 2.6)),
                    target: RING_POSITION.clone().add(new THREE.Vector3(-1.1, 1.1, 1.1))
                },
                {
                    pos: RING_POSITION.clone().add(new THREE.Vector3(2.6, 3.3, 2.6)),
                    target: RING_POSITION.clone().add(new THREE.Vector3(1.1, 1.1, 1.1))
                }
            ];

            const allRingSpots = [...ringSpotSettings, ...ringCornerSpotSettings];

            allRingSpots.forEach((cfg, idx) => {
                const spot = new THREE.SpotLight(lightingPresets[currentPreset].ringSpotColor, lightBases.ringSpot, 24, Math.PI / 5.0, 0.7, 1.45);
                spot.position.copy(cfg.pos);
                spot.target.position.copy(cfg.target);
                // Mantener estas luces sin sombras evita que el shader supere
                // el l√≠mite de MAX_TEXTURE_IMAGE_UNITS en dispositivos con
                // hardware WebGL m√°s limitado (se sumaban demasiados shadow
                // maps junto a las texturas del escenario).
                spot.castShadow = false;
                spot.shadow.mapSize.set(1024, 1024);
                spot.shadow.bias = -0.00012;
                spot.penumbra = 0.85;
                spot.name = `ringSpot-${idx}`;
                scene.add(spot);
                scene.add(spot.target);
                ringSpotLights.push(spot);

                const fixture = createRingReflectorFixture(cfg.pos, cfg.target);
                ringReflectorFixtures.push(fixture);
                scene.add(fixture);
            });

            cinemaBackLight = new THREE.SpotLight(lightingPresets[currentPreset].cinemaBackColor, lightBases.cinemaBack, 12, Math.PI / 3.2, 0.9, 1);
            cinemaBackLight.position.set(0, 1.6, -7.6);
            cinemaBackLight.target.position.set(0, 1.2, 0);
            cinemaBackLight.castShadow = false;
            cinemaBackLight.penumbra = 0.95;
            scene.add(cinemaBackLight);
            scene.add(cinemaBackLight.target);
        }

        function createVolumetricLight() {
            // Deshabilitado: el cono volum√©trico ya no se crea en la inicializaci√≥n.
            volumetricMesh = null;
        }

        function alignVolumetricLight() {
            if (!volumetricMesh || !keyLight || !keyLight.target) return;
            const dir = new THREE.Vector3().subVectors(keyLight.target.position, keyLight.position).normalize();
            volumetricMesh.position.copy(keyLight.position).add(dir.clone().multiplyScalar(3.0));
            volumetricMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
            const spread = THREE.MathUtils.lerp(0.9, 1.1, punchActivity);
            volumetricMesh.scale.set(spread, 1, spread);
        }

        function applyLightingPreset(name) {
            const preset = lightingPresets[name];
            if (!preset) return;

            currentPreset = name;

            applyPresetBagSettings(name);

            lightBases.key = preset.keyBase;
            lightBases.fill = preset.fillBase;
            lightBases.bag = preset.bagLightBase ?? lightBases.bag;
            lightBases.rim = preset.rimBase;
            lightBases.ring = preset.ringBase;
            lightBases.cinemaBack = preset.cinemaBackBase;
            lightBases.door = preset.doorBase;
            lightBases.fluorescent = preset.fluorescentBase;
            lightBases.ringSpot = preset.ringSpotBase;
            lightBases.accent = preset.accentBase ?? lightBases.accent;
            baseFogDensity = preset.fogDensity;
            volumetricBaseHue = preset.volumetricHue;
            ambientBaseIntensity = preset.ambientBase;

            applyRingIntensityBases();
            applyLightingColorsToScene(preset);
            if (scene && scene.fog) {
                scene.fog.color.setHex(preset.fogColor);
                scene.fog.density = baseFogDensity;
            }
            if (scene && scene.background) {
                scene.background.setHex(preset.background);
            }

            if (cinemaBackLight) cinemaBackLight.intensity = preset.cinemaBackBase;
            if (bagLight) bagLight.intensity = lightBases.bag;
            if (ringSpotLights.length) {
                ringSpotLights.forEach(s => {
                    s.intensity = preset.ringSpotBase;
                });
            }
            if (accentLights.length) {
                accentLights.forEach(l => {
                    l.intensity = lightBases.accent;
                });
            }
            if (trainingAreaLights.length) {
                trainingAreaLights.forEach(({ light, base }) => {
                    light.intensity = base;
                });
            }

            syncLightingControlsFromState();
        }

        function setupPresetButton() {
            const presetBtn = document.getElementById('presetBtn');
            if (!presetBtn) return;

            const updateLabel = () => {
                presetBtn.textContent = currentPreset === 'night' ? 'üåô Noche' : 'üåá Atardecer';
            };

            presetBtn.addEventListener('click', () => {
                const nextPreset = currentPreset === 'night' ? 'sunset' : 'night';
                applyLightingPreset(nextPreset);
                updateLabel();
            });

            applyLightingPreset(currentPreset);
            updateLabel();
        }

        function triggerImpactFlash(strength = 1.0, addPunchEnergy = true) {
            const s = THREE.MathUtils.clamp(strength, 0, 1);
            if (addPunchEnergy) {
                punchActivity = Math.min(1.0, punchActivity + 0.3 * s);
            }
            impactFlashTime = IMPACT_FLASH_DURATION;
            impactFlashStrength = s;
        }

        function registerPunch(strength = 1) {
            const s = THREE.MathUtils.clamp(strength, 0, 1);
            triggerImpactFlash(s, true);
        }

        function updatePunchState(dt) {
            const decay = 0.6;
            punchActivity = Math.max(0, punchActivity - dt * decay);
            if (impactFlashTime > 0) {
                impactFlashTime -= dt;
                if (impactFlashTime < 0) impactFlashTime = 0;
            }
        }

        function getImpactFlashPhase() {
            if (impactFlashTime <= 0) return 0;
            const t = impactFlashTime / IMPACT_FLASH_DURATION;
            return t * t;
        }

        function updateLights(elapsed, dt, flashPhase) {
            if (!noiseGen) return;

            if (keyLight) {
                const low = noiseGen.noise2D(elapsed * 0.7, 0.1) * 0.5 + 0.5;
                const hi = noiseGen.noise2D(elapsed * 4.0, 1.3) * 0.5 + 0.5;
                const flick = 1.0 + ((low * 0.7 + hi * 0.3) - 0.8) * 0.4;
                const activity = 1.0 + punchActivity * 0.4;
                const flashBoost = 1.0 + flashPhase * 0.8 * (0.5 + 0.5 * impactFlashStrength);
                const intensity = lightBases.key * flick * activity * flashBoost;
                keyLight.intensity = Math.max(0.0, intensity);
            }

            if (fillLight) {
                const n = noiseGen.noise2D(elapsed * 0.9, 4.2) * 0.5 + 0.5;
                const f = 1.0 + (n - 0.5) * 0.25;
                fillLight.intensity = Math.max(0.0, lightBases.fill * f);
            }

            if (bagLight) {
                const slow = noiseGen.noise2D(elapsed * 0.8, 3.3) * 0.5 + 0.5;
                const fast = noiseGen.noise2D(elapsed * 3.1, 6.7) * 0.5 + 0.5;
                const flick = 1.0 + (slow - 0.5) * 0.35 + (fast - 0.5) * 0.25;
                const activity = 1.0 + punchActivity * 0.5;
                const flashBoost = 1.0 + flashPhase * 0.65 * (0.5 + 0.5 * impactFlashStrength);
                bagLight.intensity = Math.max(0.0, lightBases.bag * flick * activity * flashBoost);
            }

            if (ambientLight) {
                const n = noiseGen.noise2D(elapsed * 0.35, 9.1) * 0.5 + 0.5;
                const flick = 1.0 + (n - 0.5) * 0.2;
                const flashBoost = 1.0 + flashPhase * 0.25 + punchActivity * 0.08;
                ambientLight.intensity = Math.max(0.0, ambientBaseIntensity * flick * flashBoost);
            }

            if (rimLight) {
                const n = noiseGen.noise2D(elapsed * 0.6, 8.3) * 0.5 + 0.5;
                const flashBoost = 1.0 + flashPhase * 0.4 * (0.5 + 0.5 * impactFlashStrength);
                const f = 1.0 + (n - 0.5) * 0.3 + punchActivity * 0.2;
                rimLight.intensity = Math.max(0.0, lightBases.rim * f * flashBoost);
            }

            if (ringLight) {
                const n = noiseGen.noise2D(elapsed * 1.2, 2.7) * 0.5 + 0.5;
                const f = 1.0 + (n - 0.5) * 0.25 + punchActivity * 0.3 + flashPhase * 0.6 * impactFlashStrength;
                ringLight.intensity = Math.max(0.0, lightBases.ring * f);
            }

            if (ringSpotLights.length) {
                ringSpotLights.forEach((spot, idx) => {
                    const n = noiseGen.noise2D(elapsed * 0.55 + idx * 1.7, 6.3) * 0.5 + 0.5;
                    const jitter = 1.0 + (n - 0.5) * 0.25;
                    const flashBoost = 1.0 + flashPhase * 0.55 * (0.5 + 0.5 * impactFlashStrength);
                    const activity = 1.0 + punchActivity * 0.32;
                    spot.intensity = Math.max(0.0, lightBases.ringSpot * jitter * flashBoost * activity);
                });
            }

            if (accentLights.length) {
                accentLights.forEach((light, idx) => {
                    const n = noiseGen.noise2D(elapsed * 0.65 + idx * 2.3, 4.5) * 0.5 + 0.5;
                    const flashBoost = 1.0 + flashPhase * 0.4 * (0.5 + 0.5 * impactFlashStrength);
                    const activity = 1.0 + punchActivity * 0.18;
                    const f = 1.0 + (n - 0.5) * 0.25;
                    light.intensity = Math.max(0.0, lightBases.accent * f * flashBoost * activity);
                });
            }

            if (trainingAreaLights.length) {
                trainingAreaLights.forEach(({ light, base }, idx) => {
                    const n = noiseGen.noise2D(elapsed * 0.75 + idx * 1.3, 5.1) * 0.5 + 0.5;
                    const flashBoost = 1.0 + flashPhase * 0.35 * (0.5 + 0.5 * impactFlashStrength);
                    const activity = 1.0 + punchActivity * 0.2;
                    const f = 1.0 + (n - 0.5) * 0.25;
                    light.intensity = Math.max(0.0, base * f * flashBoost * activity);
                });
            }

            if (cinemaBackLight) {
                const n = noiseGen.noise2D(elapsed * 0.18, 1.7) * 0.5 + 0.5;
                const f = 1.0 + (n - 0.5) * 0.08;
                cinemaBackLight.intensity = Math.max(0.0, lightBases.cinemaBack * f);
            }

            if (doorLight) {
                const n = noiseGen.noise2D(elapsed * 0.5, 5.5) * 0.5 + 0.5;
                const f = 1.0 + (n - 0.5) * 0.3;
                doorLight.intensity = Math.max(0.0, lightBases.door * f);
            }

            if (fluorescentLights.length) {
                fluorescentLights.forEach((l, i) => {
                    const t = elapsed + i * 10.123;
                    const n = noiseGen.noise2D(t * 1.4, 2.5) * 0.5 + 0.5;
                    const fast = noiseGen.noise2D(t * 12.0, 7.8) * 0.5 + 0.5;
                    let flick = 1.0 + (n - 0.5) * 0.3 + (fast - 0.5) * 0.6;
                    if (fast > 0.9) {
                        const k = THREE.MathUtils.clamp((1.0 - fast) / 0.1, 0.0, 1.0);
                        flick *= THREE.MathUtils.lerp(0.3, 0.7, k);
                    }
                    const base = lightBases.fluorescent;
                    const intensity = Math.max(0.0, base * flick);
                    l.intensity = intensity;
                    if (fluorescentGlowCards[i]) {
                        fluorescentGlowCards[i].material.opacity = THREE.MathUtils.clamp(0.3 + (intensity / base) * 0.35, 0, 0.85);
                    }
                });
            }
        }

        function updateBagLightAnchor() {
            if (!bagLight || !bagLightTarget) return;

            const anchor = bagMesh ? bagMesh.position : BAG_LIGHT_BASE_POSITION;
            bagLightAnchor.copy(anchor).add(BAG_LIGHT_OFFSET);
            bagLight.position.lerp(bagLightAnchor, 0.6);

            bagLightTargetPos.copy(anchor);
            bagLightTarget.position.lerp(bagLightTargetPos, 0.65);
        }

        function updateFog(dt, elapsed) {
            if (!scene || !scene.fog) return;
            const fogNoise = noiseGen ? (noiseGen.noise2D(elapsed * 0.05, 2.2) * 0.5 + 0.5) : 0.5;
            const targetDensity = baseFogDensity * (0.85 + fogNoise * 0.3);
            const h = THREE.MathUtils.clamp((camera.position.y - 0.5) / 4.0, 0.0, 1.0);
            const gradientDensity = THREE.MathUtils.lerp(targetDensity * 0.4, targetDensity, h);
            scene.fog.density += (gradientDensity - scene.fog.density) * 0.05;
        }

        function ensureBagPresence(tex) {
            if (bagMesh) {
                bagMesh.visible = true;
                if (bagMesh.material) bagMesh.material.needsUpdate = true;
                return;
            }

            const fallbackMat = new THREE.MeshStandardMaterial({
                map: tex?.bag?.c || null,
                normalMap: tex?.bag?.n || null,
                roughnessMap: tex?.bag?.r || null,
                color: visualConfig.bag.color,
                roughness: visualConfig.bag.roughness,
                metalness: visualConfig.bag.metalness
            });

            bagMesh = new THREE.Mesh(
                new THREE.CylinderGeometry(0.35, 0.35, 1.5, 24, 16),
                fallbackMat
            );
            bagMesh.castShadow = true;
            bagMesh.receiveShadow = true;
            bagMesh.position.set(0, 1.9, 0);
            scene.add(bagMesh);
        }

        function updateCinematicCamera(dt) {
            if (!cinematicCameraActive || !camera || !controls) return;
            const path = cinematicPaths[cinematicPathIndex % cinematicPaths.length];
            if (!path || path.length < 2) return;

            const start = path[cinematicSegmentIndex];
            const end = path[(cinematicSegmentIndex + 1) % path.length];
            const segDuration = Math.max(0.25, start.duration || 3);
            cinematicSegmentTime += dt;

            const rawT = THREE.MathUtils.clamp(cinematicSegmentTime / segDuration, 0, 1);
            const eased = THREE.MathUtils.smootherstep ? THREE.MathUtils.smootherstep(0, 1, rawT) : rawT * rawT * (3 - 2 * rawT);

            tmpVecA.lerpVectors(start.pos, end.pos, eased);
            tmpVecB.lerpVectors(start.target, end.target, eased);

            camera.position.copy(tmpVecA);
            targetBase.copy(tmpVecB);
            controls.target.copy(tmpVecB);

            if (cinematicSegmentTime >= segDuration) {
                cinematicSegmentIndex = (cinematicSegmentIndex + 1) % path.length;
                cinematicSegmentTime = 0;

                if (cinematicSegmentIndex === 0) {
                    cinematicPathIndex = (cinematicPathIndex + 1) % cinematicPaths.length;
                    snapToCinematicStart();
                }
            }
        }

        function updateCinematicFx(dt, elapsed) {
            if (!bloomPass || !bokehPass || !bokehPass.materialBokeh) return;

            const fxTarget = cinematicCameraActive ? cinematicFxTargets : defaultFxTargets;
            const bloomPulse = cinematicCameraActive ? (Math.sin(elapsed * 0.35) * 0.08 + 1) : 1;
            const bloomGoal = fxTarget.bloom * bloomPulse;
            bloomPass.strength += (bloomGoal - bloomPass.strength) * Math.min(1, dt * 2.2);

            const apertureUniform = bokehPass.materialBokeh.uniforms.aperture;
            const blurUniform = bokehPass.materialBokeh.uniforms.maxblur;
            if (apertureUniform) {
                apertureUniform.value += (fxTarget.aperture - apertureUniform.value) * Math.min(1, dt * 2.6);
            }
            if (blurUniform) {
                blurUniform.value += (fxTarget.maxBlur - blurUniform.value) * Math.min(1, dt * 2.6);
            }
        }

        // --- F√çSICA ---
        function initWorld() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.solver.iterations = 40;
            world.solver.tolerance = 0.0001;
            world.allowSleep = true;
        }

        function initPhysics(tex, envProps) {
            const { staticMat, ceilingMat } = envProps;

            const bagMat = new CANNON.Material('bag');
            fistMaterial = new CANNON.Material('fist');
            const chainMaterial = new CANNON.Material('chain');

            const wornClothContact = {
                friction: 0.55,
                restitution: 0.08,
                contactEquationStiffness: 50000,
                contactEquationRelaxation: 4.5,
                frictionEquationRelaxation: 3.5
            };

            const metalToCloth = {
                friction: 0.48,
                restitution: 0.03,
                contactEquationStiffness: 40000,
                contactEquationRelaxation: 5.5,
                frictionEquationRelaxation: 4.5
            };

            const metalToCeiling = {
                friction: 0.42,
                restitution: 0.02,
                contactEquationStiffness: 35000,
                contactEquationRelaxation: 6.5,
                frictionEquationRelaxation: 5.5
            };

            world.addContactMaterial(new CANNON.ContactMaterial(staticMat, bagMat, wornClothContact));
            world.addContactMaterial(new CANNON.ContactMaterial(staticMat, chainMaterial, {
                friction: 0.5,
                restitution: 0.04,
                contactEquationStiffness: 60000,
                contactEquationRelaxation: 3.5,
                frictionEquationRelaxation: 2.5
            }));
            world.addContactMaterial(new CANNON.ContactMaterial(bagMat, chainMaterial, metalToCloth));
            world.addContactMaterial(new CANNON.ContactMaterial(chainMaterial, ceilingMat, metalToCeiling));
            world.addContactMaterial(new CANNON.ContactMaterial(bagMat, ceilingMat, {
                friction: 0.35,
                restitution: 0.01,
                contactEquationStiffness: 28000,
                contactEquationRelaxation: 6.5,
                frictionEquationRelaxation: 5.5
            }));

            world.addContactMaterial(new CANNON.ContactMaterial(bagMat, fistMaterial, {
                friction: 0.3,
                restitution: 0.04,
                contactEquationStiffness: 25000,
                contactEquationRelaxation: 4,
                frictionEquationRelaxation: 3
            }));

            bagSimulation = new BagSimulation({
                world,
                scene,
                noise: noiseGen,
                visualConfig,
                punchConfig,
                collisionGroups,
                geometryDetail: BAG_GEOMETRY_DETAIL,
                bagVisualOffset,
                mobileSimpleMode: MOBILE_SIMPLE_MODE
            });

            bagSimulation.initialize(tex.bag, { bagMaterial: bagMat, chainMaterial, ceilingMaterial: ceilingMat, staticMat });
            bagBody = bagSimulation.getBody();
            bagMesh = bagSimulation.getMesh();
            bagVisualOffset = bagSimulation.getVisualOffset();
            chains = bagSimulation.getChains();

            if (bagBody) {
                bagBody.addEventListener('collide', handleBagCollision);
            }

            bagSimulation.reset();
            createFistColliders();
            ensureBagPresence(tex);
        }

        function applyBagPhysicsToBody() {
            const body = bagSimulation ? bagSimulation.getBody() : null;
            if (!body) return;
            body.mass = visualConfig.bag.mass;
            body.updateMassProperties();
            body.linearDamping = visualConfig.bag.linearDamping;
            body.angularDamping = visualConfig.bag.angularDamping;
        }

        function createFistColliders() {
            if (!world || !fistMaterial || leftFistBody || rightFistBody) return;

            const createFistBody = () => new CANNON.Body({
                mass: 1.0,
                type: CANNON.Body.KINEMATIC,
                position: new CANNON.Vec3(),
                shape: new CANNON.Sphere(0.11),
                material: fistMaterial,
                collisionFilterGroup: collisionGroups.fist,
                collisionFilterMask: collisionGroups.bag
            });

            leftFistBody = createFistBody();
            rightFistBody = createFistBody();

            world.addBody(leftFistBody);
            world.addBody(rightFistBody);
        }

        function getBodyPointVelocity(body, contactPoint) {
            const relativePoint = new CANNON.Vec3();
            contactPoint.vsub(body.position, relativePoint);

            const angularComponent = new CANNON.Vec3();
            body.angularVelocity.cross(relativePoint, angularComponent);

            const pointVelocity = new CANNON.Vec3();
            body.velocity.vadd(angularComponent, pointVelocity);
            return pointVelocity;
        }

        function syncFistBodies(dt) {
            if (!skeleton || !leftFistBody || !rightFistBody) return;
            const updateFist = (boneName, body, lastPosKey) => {
                const bone = getBone(boneName);
                if (!bone) return;
                const worldPos = new THREE.Vector3().setFromMatrixPosition(bone.matrixWorld);
                worldPos.z -= FIST_FORWARD_OFFSET;

                const lastPos = lastPosKey === 'left' ? lastLeftFistPos : lastRightFistPos;
                if (lastPos) {
                    const vel = worldPos.clone().sub(lastPos).divideScalar(Math.max(dt, 0.0001));
                    body.velocity.set(vel.x, vel.y, vel.z);
                } else {
                    body.velocity.set(0, 0, 0);
                }

                body.position.set(worldPos.x, worldPos.y, worldPos.z);
                body.angularVelocity.set(0, 0, 0);
                body.aabbNeedsUpdate = true;
                body.updateAABB();

                if (lastPosKey === 'left') {
                    lastLeftFistPos = worldPos;
                } else {
                    lastRightFistPos = worldPos;
                }
            };

            updateFist('LeftHand', leftFistBody, 'left');
            updateFist('RightHand', rightFistBody, 'right');
        }

        function handleBagCollision(event) {
            const other = event.body;
            if (!other || (other !== leftFistBody && other !== rightFistBody)) return;
            const contact = event.contact;
            if (!contact) return;

            const isLeft = other === leftFistBody;

            const contactPoint = new CANNON.Vec3();

            if (contact.bi === bagBody) {
                contactPoint.copy(contact.ri).vadd(bagBody.position, contactPoint);
            } else if (contact.bj === bagBody) {
                contactPoint.copy(contact.rj).vadd(bagBody.position, contactPoint);
            } else {
                return;
            }

            const fistPointVelocity = getBodyPointVelocity(other, contactPoint);
            const punchResult = bagSimulation ? bagSimulation.applyPunch(fistPointVelocity, contactPoint, isLeft) : null;

            if (punchResult) {
                if (!audioInitialized) initAudioContext();
                const impactForce = visualConfig.bag.punchForce * punchResult.normalizedImpact;
                playImpactSound(impactForce);
                playHeavyImpactSound(impactForce);

                registerPunch(Math.min(1, punchResult.punchData.normalSpeed / 6));
            }
        }

        // --- AUDIO ---
        function initAudioContext() {
            if (audioInitialized) return;
            audioInitialized = true;

            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            masterGain = audioContext.createGain();
            masterGain.gain.value = audioConfig.volume;
            setupReverb();
            masterGain.connect(audioContext.destination);
            loadAllAudio();
        }

        async function ensureAudioContextActive() {
            if (!audioInitialized) initAudioContext();
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            return audioContext && audioContext.state === 'running';
        }

        function setupAudioUnlockListeners() {
            if (audioUnlockHandlers.length > 0) return;

            const tryUnlock = async () => {
                if (await ensureAudioContextActive()) removeAudioUnlockListeners();
            };

            const events = ['pointerdown', 'touchstart', 'keydown'];
            audioUnlockHandlers = events.map((evt) => {
                const handler = () => tryUnlock();
                document.addEventListener(evt, handler, { capture: true, passive: true });
                return { evt, handler };
            });
        }

        function removeAudioUnlockListeners() {
            audioUnlockHandlers.forEach(({ evt, handler }) =>
                document.removeEventListener(evt, handler, { capture: true })
            );
            audioUnlockHandlers = [];
        }

        function createImpulseResponse(context, decaySeconds) {
            const decay = Math.max(0.1, decaySeconds || 1);
            const sampleRate = context.sampleRate;
            const length = Math.floor(sampleRate * decay);
            const impulse = context.createBuffer(2, length, sampleRate);

            for (let channel = 0; channel < impulse.numberOfChannels; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    const t = i / length;
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, 2.5);
                }
            }

            return impulse;
        }

        function setupReverb() {
            if (!audioContext || !masterGain || !audioConfig.reverb?.enabled) return;

            reverbNode = audioContext.createConvolver();
            reverbWetGain = audioContext.createGain();
            reverbDryGain = audioContext.createGain();

            reverbNode.buffer = createImpulseResponse(audioContext, audioConfig.reverb.decay);

            updateReverbMix(audioConfig.reverb.mix);

            reverbNode.connect(reverbWetGain);
            reverbWetGain.connect(masterGain);
            reverbDryGain.connect(masterGain);
        }

        function updateReverbMix(mix) {
            if (!reverbWetGain || !reverbDryGain) return;
            const clamped = Math.min(1, Math.max(0, mix ?? 0));
            reverbWetGain.gain.value = clamped;
            reverbDryGain.gain.value = 1 - clamped;
        }

        function updateReverbDecay(decaySeconds) {
            if (!audioContext || !reverbNode) return;
            reverbNode.buffer = createImpulseResponse(audioContext, decaySeconds);
        }

        function setReverbDecay(decaySeconds) {
            if (!audioConfig.reverb) return;
            const decay = Math.max(0.1, decaySeconds);
            audioConfig.reverb.decay = decay;
            updateReverbDecay(decay);
        }

        function setReverbMix(mix) {
            if (!audioConfig.reverb) return;
            const clamped = Math.min(1, Math.max(0, mix));
            audioConfig.reverb.mix = clamped;
            updateReverbMix(clamped);
        }

        function connectToAudioGraph(gainNode) {
            if (!masterGain) return;
            if (audioConfig.reverb?.enabled && reverbNode && reverbWetGain && reverbDryGain) {
                gainNode.connect(reverbNode);
                gainNode.connect(reverbDryGain);
            } else {
                gainNode.connect(masterGain);
            }
        }

        window.gymReverbSettings = {
            setDecay: setReverbDecay,
            setMix: setReverbMix,
            getSettings: () => ({ ...audioConfig.reverb })
        };

        async function loadAudioBuffer(url) {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            return audioContext.decodeAudioData(arrayBuffer);
        }

        async function loadAllAudio() {
            const entries = [];
            audioFiles.impacts.forEach((file) => entries.push(['impact:' + file, file]));
            entries.push(['heavyImpact', audioFiles.heavyImpact]);
            entries.push(['bell', audioFiles.bell]);
            entries.push(['countdown', audioFiles.countdown]);
            entries.push(['breath', audioFiles.breath]);
            entries.push(['crowd', audioFiles.crowd]);
            audioFiles.shouts.forEach((file, idx) => entries.push([`shout:${idx}`, file]));

            for (const [key, file] of entries) {
                try {
                    const buffer = await loadAudioBuffer(file);
                    audioBuffers.set(key, buffer);
                } catch (err) {
                    console.warn('No se pudo cargar el audio', file, err);
                }
            }
        }

        function playBuffer(name, { volume = 1, playbackRate = 1, slices = 1 } = {}) {
            if (!audioConfig.enabled) return;
            setupAudioUnlockListeners();
            if (!audioContext) return;
            const buffer = audioBuffers.get(name);
            if (!buffer) return;

            if (audioContext.state === 'suspended') return;

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.playbackRate.value = playbackRate;

            const gainNode = audioContext.createGain();
            gainNode.gain.value = volume;

            source.connect(gainNode);
            connectToAudioGraph(gainNode);

            const totalSlices = Math.max(1, Math.floor(slices));
            const segmentDuration = buffer.duration / totalSlices;
            const sliceIndex = Math.floor(Math.random() * totalSlices);
            const offset = sliceIndex * segmentDuration;
            const duration = Math.max(0.01, segmentDuration);

            updateDebugSound(name);
            source.start(0, offset, duration);
        }

        function playImpactSound(strength = 1) {
            const vol = THREE.MathUtils.clamp(strength / 90, 0.2, 1.1);
            const rate = 0.9 + Math.random() * 0.2;
            const impactFiles = audioFiles.impacts
                .map((file) => ({ key: 'impact:' + file, slices: 4 }))
                .filter((entry) => audioBuffers.has(entry.key));
            if (impactFiles.length === 0) return;
            const pick = impactFiles[Math.floor(Math.random() * impactFiles.length)];
            playBuffer(pick.key, { volume: vol, playbackRate: rate, slices: pick.slices });
        }

        function playHeavyImpactSound(strength = 1) {
            const vol = THREE.MathUtils.clamp(strength / 60, 0.25, 0.7);
            playBuffer('heavyImpact', { volume: vol });
        }

        function playBell() { playBuffer('bell', { volume: 0.9 }); }
        function playCountdown() { playBuffer('countdown', { volume: 0.85 }); }
        function playBreath() { playBuffer('breath', { volume: 0.35 + Math.random() * 0.15 }); }
        function playCrowd() { playBuffer('crowd', { volume: 0.6 }); }
        function playShout() {
            const shoutKeys = audioFiles.shouts
                .map((_, idx) => `shout:${idx}`)
                .filter((key) => audioBuffers.has(key));
            if (shoutKeys.length === 0) return;
            const pick = shoutKeys[Math.floor(Math.random() * shoutKeys.length)];
            playBuffer(pick, { volume: 0.65 + Math.random() * 0.2 });
        }

        function setupMuteButton() {
            const muteBtn = document.getElementById('muteBtn');
            let muted = false;

            muteBtn.addEventListener('click', () => {
                muted = !muted;
                audioConfig.enabled = !muted;
                if (masterGain) {
                    masterGain.gain.value = muted ? 0 : audioConfig.volume;
                }
                muteBtn.textContent = muted ? 'üîá OFF' : 'üîä ON';
            });
        }

        function applyViewMode() {
            if (freeCameraActive) return;

            if (!controls || !camera) return;

            if (thirdPersonActive) {
                camera.position.copy(baseTarget).add(thirdPersonCameraOffset);
                targetBase.copy(baseTarget).add(thirdPersonTargetOffset);
            } else {
                camera.position.copy(defaultCameraPosition);
                targetBase.copy(baseTarget);
            }

            controls.target.copy(targetBase);
        }

        function applyCameraControlLocks() {
            if (!controls) return;
            controls.enableRotate = !cinematicCameraActive && !freeCameraActive;
            controls.enableZoom = !cinematicCameraActive || freeCameraActive;
            controls.enablePan = freeCameraActive && !cinematicCameraActive;
            controls.enabled = !cinematicCameraActive || freeCameraActive;
        }

        function updateFreeCameraButton() {
            const freeCamBtn = document.getElementById('freeCamBtn');
            if (!freeCamBtn) return;
            freeCamBtn.textContent = freeCameraActive ? 'üõ∞Ô∏è C√°mara libre ON' : 'üõ∞Ô∏è C√°mara libre OFF';
            freeCamBtn.classList.toggle('active', freeCameraActive);
        }

        function alignFreeCameraTarget() {
            if (!controls || !camera) return;
            tmpVecB.set(0, 0, -1).applyQuaternion(camera.quaternion);
            controls.target.copy(camera.position).add(tmpVecB);
        }

        function setFreeCameraActive(active) {
            if (!controls || !camera) return;
            if (active && cinematicCameraActive) {
                cinematicCameraActive = false;
                updateCinematicButton();
            }
            freeCameraActive = active;
            controls.enablePan = active;
            controls.enableZoom = active;
            freeCamVelocity.set(0, 0, 0);
            if (active) {
                alignFreeCameraTarget();
            } else {
                applyViewMode();
            }
            applyCameraControlLocks();
            updateFreeCameraButton();
        }

        function updateFreeCamera(dt) {
            if (!freeCameraActive || !camera || !controls) return;

            freeCamForward.copy(controls.target).sub(camera.position);
            freeCamForward.y = 0;
            if (freeCamForward.lengthSq() < 1e-6) {
                freeCamForward.set(0, 0, -1).applyQuaternion(camera.quaternion);
                freeCamForward.y = 0;
            }
            freeCamForward.normalize();

            freeCamSide.copy(freeCamForward).cross(THREE.Object3D.DEFAULT_UP).normalize();

            tmpVecB.set(0, 0, 0);
            if (freeCamMoveState.forward) tmpVecB.add(freeCamForward);
            if (freeCamMoveState.back) tmpVecB.sub(freeCamForward);
            if (freeCamMoveState.left) tmpVecB.sub(freeCamSide);
            if (freeCamMoveState.right) tmpVecB.add(freeCamSide);

            if (tmpVecB.lengthSq() > 0) {
                tmpVecB.normalize().multiplyScalar(freeCamSettings.speed * (freeCamMoveState.fast ? freeCamSettings.boost : 1) * dt);
                freeCamVelocity.add(tmpVecB);
            }

            freeCamVelocity.multiplyScalar(0.9);

            if (freeCamVelocity.lengthSq() > 0) {
                camera.position.add(freeCamVelocity);
                controls.target.add(freeCamVelocity);
            }
        }

        function setupFreeCameraControls() {
            const freeCamBtn = document.getElementById('freeCamBtn');
            if (freeCamBtn) {
                updateFreeCameraButton();
                freeCamBtn.addEventListener('click', () => setFreeCameraActive(!freeCameraActive));
            }

            const handleKey = (event, isDown) => {
                if (['INPUT', 'TEXTAREA'].includes(event.target?.tagName)) return;
                switch (event.code) {
                    case 'KeyW': freeCamMoveState.forward = isDown; break;
                    case 'KeyS': freeCamMoveState.back = isDown; break;
                    case 'KeyA': freeCamMoveState.left = isDown; break;
                    case 'KeyD': freeCamMoveState.right = isDown; break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        freeCamMoveState.fast = isDown;
                        break;
                    default:
                        return;
                }
                if (freeCameraActive) event.preventDefault();
            };

            window.addEventListener('keydown', (e) => handleKey(e, true));
            window.addEventListener('keyup', (e) => handleKey(e, false));
        }

        function setupViewButton() {
            const viewBtn = document.getElementById('viewBtn');
            if (!viewBtn) return;

            applyViewMode();

            viewBtn.addEventListener('click', () => {
                if (freeCameraActive) setFreeCameraActive(false);
                if (cinematicCameraActive) toggleCinematicCameraMode();
                thirdPersonActive = !thirdPersonActive;
                applyViewMode();
                viewBtn.textContent = thirdPersonActive ? 'üëÅÔ∏è 3ra Persona' : 'üéØ POV';
            });
        }

        function updateCinematicButton() {
            const cineBtn = document.getElementById('cineBtn');
            if (!cineBtn) return;
            cineBtn.textContent = cinematicCameraActive ? 'üé• Cine ON' : 'üé• Cine OFF';
            cineBtn.classList.toggle('active', cinematicCameraActive);
        }

        function snapToCinematicStart() {
            const path = cinematicPaths[cinematicPathIndex % cinematicPaths.length];
            if (!path || !path.length || !camera || !controls) return;
            const first = path[0];
            camera.position.copy(first.pos);
            targetBase.copy(first.target);
            controls.target.copy(first.target);
        }

        function resetCinematicLoop() {
            cinematicSegmentIndex = 0;
            cinematicSegmentTime = 0;
            snapToCinematicStart();
        }

        function toggleCinematicCameraMode() {
            cinematicCameraActive = !cinematicCameraActive;
            if (cinematicCameraActive) {
                lastManualThirdPerson = thirdPersonActive;
                thirdPersonActive = true;
                setFreeCameraActive(false);
                resetCinematicLoop();
            } else {
                thirdPersonActive = lastManualThirdPerson;
                applyViewMode();
            }
            applyCameraControlLocks();
            updateCinematicButton();
        }

        function setupCinematicCameraButton() {
            const cineBtn = document.getElementById('cineBtn');
            if (!cineBtn) return;

            updateCinematicButton();
            cineBtn.addEventListener('click', toggleCinematicCameraMode);
        }

        function setupUiFxEvents() {
            const ids = ['presetBtn', 'muteBtn', 'viewBtn', 'webcamBtn', 'cineBtn'];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                const handler = (evt) => {
                    spawnUiSpark(evt.clientX, evt.clientY, evt.type === 'click' ? 0.7 : 0.4);
                    triggerImpactFlash(evt.type === 'click' ? 0.45 : 0.25, false);
                };
                el.addEventListener('mouseenter', handler);
                el.addEventListener('click', handler);
            });
        }

        function setupMobileControls() {
            const panel = document.getElementById('mobileControls');
            if (!panel) return;

            if (!MOBILE_SIMPLE_MODE) {
                panel.style.display = 'none';
                return;
            }

            const buttons = panel.querySelectorAll('[data-hand]');
            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const hand = btn.dataset.hand || 'right';
                    triggerQuickPunch(hand);
                });
            });
        }

        function triggerQuickPunch(hand = 'right') {
            if (!bagSimulation || !bagMesh) return;

            initAudioContext();

            const baseForce = visualConfig.bag.punchForce * (hand === 'left' ? 0.8 : 1.0);
            const dir = bagMesh.position.clone().sub(camera.position).normalize();
            const hitPoint = bagMesh.position.clone().add(new THREE.Vector3(0, 0.3, 0.32));
            const handSettings = punchConfig[hand] || punchConfig.right;
            const syntheticSpeed = baseForce / (handSettings.effectiveMass * handSettings.contactArea);
            const punchResult = bagSimulation.applyPunch(dir.multiplyScalar(syntheticSpeed), hitPoint, hand === 'left');
            if (!punchResult) return;

            const impactForce = Math.max(baseForce, punchResult.punchData.impulseMagnitude);
            playImpactSound(impactForce);
            playHeavyImpactSound(impactForce * 0.9);
            registerPunch(Math.min(1, punchResult.punchData.normalSpeed / 6));

            shakeTime = shakeDuration;
            shakeStrength = 0.03 * (impactForce / visualConfig.bag.punchForce);
            triggerImpactFlash(0.35, false);
        }

        // --- INTERACCI√ìN (click sobre saco: solo si DEBUG_MOUSE_PUNCH = true) ---
        function onPointerDown(e) {
            if (!DEBUG_MOUSE_PUNCH) return;

            mouse.x = (e.clientX/window.innerWidth)*2-1;
            mouse.y = -(e.clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);
            
            if(!bagMesh || !bagSimulation) return;

            const hits = raycaster.intersectObject(bagMesh);
            if(hits.length>0) {
                initAudioContext();

                const hit = hits[0];
                const dir = hit.point.clone().sub(camera.position).normalize();
                const rightSettings = punchConfig.right;
                const targetImpulse = visualConfig.bag.punchForce;
                const syntheticSpeed = targetImpulse / (rightSettings.effectiveMass * rightSettings.contactArea);
                const handVelocity = dir.clone().multiplyScalar(syntheticSpeed);
                const punchResult = bagSimulation.applyPunch(handVelocity, hit.point, false);
                if (punchResult) {
                    const impactForce = Math.max(targetImpulse, punchResult.punchData.impulseMagnitude);
                    playImpactSound(impactForce);

                    registerPunch(Math.min(1, punchResult.punchData.normalSpeed / 6));

                    shakeTime = shakeDuration;
                    shakeStrength = 0.03 * (impactForce / visualConfig.bag.punchForce);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
            if (bloomPass) {
                bloomPass.setSize(window.innerWidth, window.innerHeight);
            }
            resizeCanvasToVideo();
        }

        function tunePhysicsBudget(stepDurationMs) {
            smoothedStepTime = physicsTuning.smoothing * smoothedStepTime + (1 - physicsTuning.smoothing) * stepDurationMs;

            if (smoothedStepTime > physicsTuning.stepTimeBudgetMs) {
                if (maxSubSteps > physicsTuning.minSubSteps) {
                    maxSubSteps -= 1;
                }
                if (fixedTimeStep < physicsTuning.maxFixedTimeStep) {
                    fixedTimeStep = Math.min(physicsTuning.maxFixedTimeStep, fixedTimeStep * 1.1);
                }
            } else if (smoothedStepTime < physicsTuning.stepTimeComfortMs) {
                if (maxSubSteps < physicsTuning.maxSubSteps) {
                    maxSubSteps += 1;
                }
                if (fixedTimeStep > physicsTuning.minFixedTimeStep) {
                    fixedTimeStep = Math.max(physicsTuning.minFixedTimeStep, fixedTimeStep * 0.95);
                }
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            const dtVis = Math.min(clock.getDelta(), 0.1);
            const elapsed = clock.getElapsedTime();
            const visualStep = fixedVisualStep || dtVis;
            lastVisualStep = visualStep;

            if (world) {
                syncFistBodies(visualStep);
                if (lastTime !== undefined) {
                    const frameDelta = Math.min(maxDelta, (time - lastTime) / 1000);
                    accumulator += frameDelta;

                    let subSteps = 0;
                    while (accumulator >= fixedTimeStep && subSteps < maxSubSteps) {
                        const stepStart = performance.now();
                        world.step(fixedTimeStep);
                        const stepDuration = performance.now() - stepStart;
                        tunePhysicsBudget(stepDuration);
                        accumulator -= fixedTimeStep;
                        subSteps += 1;
                    }

                    accumulator = Math.min(accumulator, fixedTimeStep * maxSubSteps);
                }

                lastTime = time;
            }

            if (mixer) {
                mixer.update(dtVis);
                keepTysonFeetOnFloor();
                if (animationDirector) animationDirector.update();
            }

            if (bagMesh && bagBody) {
                bagMesh.position.copy(bagBody.position);
                if (bagVisualOffset.lengthSq() > 0) {
                    tempV.copy(bagVisualOffset).applyQuaternion(bagBody.quaternion);
                    bagMesh.position.add(tempV);
                }
                bagMesh.quaternion.copy(bagBody.quaternion);
            }
            chains.forEach(o => {
                o.m.position.copy(o.b.position);
                o.m.quaternion.copy(o.b.quaternion);
            });

            updateBagLightAnchor();

            const distanceToBag = enforceTysonDistanceToBag();
            orientTysonTowardBag();
            if (animationDirector) animationDirector.cutWalkIfTooClose(distanceToBag);

            if (fanMesh) fanMesh.rotation.y -= 2.0 * dtVis;

            updateClockHands(elapsed);

            updatePunchState(dtVis);
            const flashPhase = getImpactFlashPhase();
            updateLights(elapsed, dtVis, flashPhase);

            if (volumetricMesh) {
                alignVolumetricLight();
                volumetricMesh.material.uniforms.uTime.value = elapsed;
                const hueNoise = noiseGen ? (noiseGen.noise2D(elapsed * 0.1, 9.1) * 0.5 + 0.5) * 0.015 : 0.0;
                const hue = (volumetricBaseHue || 0.08) + hueNoise;
                const l = 0.7 + Math.sin(elapsed) * 0.05 + punchActivity * 0.08;
                volumetricMesh.material.uniforms.uColor.value.setHSL(hue, 0.6, l);
            }

            if (doorGodrayMesh) {
                doorGodrayMesh.material.uniforms.uTime.value = elapsed;
            }
            if (windowGodrayMesh) {
                windowGodrayMesh.material.uniforms.uTime.value = elapsed;
            }

            if (DUST_ENABLED) {
                updateDust(elapsed, dtVis);
            }
            updateUiSparks(dtVis);

            updateCinematicFx(dtVis, elapsed);

            if (bagMesh && bokehPass && bokehPass.materialBokeh && bokehPass.materialBokeh.uniforms.focus) {
                const focusUniform = bokehPass.materialBokeh.uniforms.focus;
                if (cinematicCameraActive) {
                    const focusTarget = camera.position.distanceTo(targetBase);
                    focusUniform.value += (focusTarget - focusUniform.value) * Math.min(1, dtVis * 1.5);
                } else {
                    const d = camera.position.distanceTo(bagMesh.position);
                    focusUniform.value = d;
                }
            }

            if (cinematicCameraActive && controls && camera) {
                updateCinematicCamera(dtVis);
            } else if (!freeCameraActive) {
                const headAnchor = getHeadBone();
                const usingHeadAnchor = !thirdPersonActive && headAnchor;

                if (usingHeadAnchor) {
                    headAnchor.getWorldPosition(tmpVecA);
                    headAnchor.getWorldQuaternion(tmpQuatA);

                    targetBase.copy(tmpVecA).add(tmpDir.copy(povTargetOffset).applyQuaternion(tmpQuatA));
                    camera.position.copy(tmpVecA).add(tmpVecB.copy(povCameraOffset).applyQuaternion(tmpQuatA));
                } else if (!thirdPersonActive) {
                    camera.position.copy(defaultCameraPosition);
                    targetBase.copy(baseTarget);
                }

                const bobEnabled = thirdPersonActive || !usingHeadAnchor;
                if (bobEnabled) {
                    const bobAmount = 0.03;
                    const swayAmount = 0.04;
                    const bobY = Math.sin(elapsed * 1.8) * bobAmount;
                    const swayX = Math.sin(elapsed * 1.2) * swayAmount;
                    tmpVecB.set(
                        targetBase.x + swayX,
                        targetBase.y + bobY,
                        targetBase.z
                    );
                    controls.target.copy(tmpVecB);
                } else {
                    controls.target.copy(targetBase);
                }
            } else {
                alignFreeCameraTarget();
            }

            controls.update();

            if (freeCameraActive) {
                updateFreeCamera(visualStep);
                alignFreeCameraTarget();
            }

            if (shakeTime > 0) {
                shakeTime -= dtVis;
                camera.position.sub(shakeOffset);
                const s = shakeStrength * (shakeTime / shakeDuration);
                shakeOffset.set(
                    (Math.random() - 0.5) * s,
                    (Math.random() - 0.5) * s,
                    (Math.random() - 0.5) * s
                );
                camera.position.add(shakeOffset);
            } else if (!shakeOffset.equals(new THREE.Vector3(0, 0, 0))) {
                camera.position.sub(shakeOffset);
                shakeOffset.set(0, 0, 0);
            }

            if (bagSimulation) {
                bagSimulation.update(visualStep);
            }
            updateFog(dtVis, elapsed);

            // Golpes desde manos del personaje
            updatePosePunch(dtVis);

            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>







