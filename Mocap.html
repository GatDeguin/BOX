<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>MediaPipe + Three.js â€“ Modelo 3D que imita tu cuerpo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Evitar 404 de favicon -->
  <link rel="icon" href="data:," />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #050510;
      color: #f5f5f5;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      padding: 12px 20px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      background: radial-gradient(circle at top left, #1a1a3a 0, #050510 55%);
    }

    header h1 {
      font-size: 1.1rem;
      font-weight: 600;
    }

    header p {
      font-size: 0.8rem;
      opacity: 0.8;
    }

    .badge {
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.7rem;
      border: 1px solid rgba(255,255,255,0.12);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(0,0,0,0.2);
    }

    .badge-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 8px #22c55e;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.3fr);
      gap: 12px;
      height: calc(100vh - 80px);
    }

    .panel {
      position: relative;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.08);
      overflow: hidden;
      background: radial-gradient(circle at top, #111827 0, #020617 55%);
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      padding: 8px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.04);
      background: linear-gradient(to right, rgba(15,23,42,0.9), rgba(15,23,42,0.4));
      font-size: 0.8rem;
    }

    .panel-header span {
      opacity: 0.9;
    }

    .chip-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .chip {
      border-radius: 999px;
      padding: 3px 8px;
      border: 1px solid rgba(255,255,255,0.1);
      font-size: 0.7rem;
      opacity: 0.8;
    }

    .video-wrapper {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at center, #020617 0, #000 70%);
    }

    video#input_video {
      border-radius: 12px;
      max-width: 100%;
      max-height: 100%;
      transform: scaleX(-1); /* espejo */
      box-shadow: 0 0 40px rgba(0,0,0,0.9);
    }

    canvas#pose_canvas {
      position: absolute;
      max-width: 100%;
      max-height: 100%;
      pointer-events: none;
      transform: scaleX(-1); /* espejo igual que el video */
    }

    .three-wrapper {
      position: relative;
      flex: 1;
    }

    #three_container {
      position: absolute;
      inset: 0;
    }

    .control-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px 10px;
      border-top: 1px solid rgba(255,255,255,0.06);
      background: radial-gradient(circle at right, rgba(30,64,175,0.4), transparent 60%);
      font-size: 0.75rem;
      align-items: center;
      justify-content: space-between;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      border-radius: 999px;
      border: 0;
      padding: 6px 14px;
      background: #2563eb;
      color: #f9fafb;
      font-size: 0.75rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      box-shadow: 0 10px 25px rgba(37,99,235,0.45);
      transition: transform 0.12s ease-out, box-shadow 0.12s ease-out, background 0.12s;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 30px rgba(37,99,235,0.6);
      background: #1d4ed8;
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 4px 12px rgba(15,23,42,0.8);
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      font-size: 0.7rem;
      background: rgba(15,23,42,0.9);
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #4b5563;
    }

    .status-indicator.live {
      background: #22c55e;
      box-shadow: 0 0 10px #22c55e;
    }

    .hint {
      opacity: 0.75;
      font-size: 0.7rem;
    }

    .select {
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(15,23,42,0.9);
      padding: 4px 16px 4px 8px;
      font-size: 0.72rem;
      color: #e5e7eb;
      outline: none;
      cursor: pointer;
    }

    .file-label {
      border-radius: 999px;
      border: 1px dashed rgba(255,255,255,0.3);
      padding: 4px 10px;
      font-size: 0.7rem;
      opacity: 0.9;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .file-label input {
      display: none;
    }

    @media (max-width: 960px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
        grid-auto-rows: minmax(240px, 1fr);
        height: auto;
      }
      main {
        height: auto;
      }
    }
  </style>

  <!-- MediaPipe Pose (globals) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

  <!-- Import map para usar three como mÃ³dulo -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js"
      }
    }
  </script>
</head>
<body>
  <header>
    <div>
      <h1>MediaPipe + Three.js</h1>
      <p>Tu cuerpo â†’ esqueleto MediaPipe â†’ Tyson 3D (retarget completo)</p>
    </div>
    <div class="badge">
      <span class="badge-dot"></span>
      <span>Live mocap prototipo</span>
    </div>
  </header>

  <main>
    <div class="layout">
      <!-- Panel izquierda: cÃ¡mara + pose -->
      <section class="panel">
        <div class="panel-header">
          <span>ðŸ“· Webcam + Esqueleto MediaPipe</span>
          <div class="chip-row">
            <div class="chip">Pose 33 puntos</div>
            <div class="chip">Suavizado</div>
          </div>
        </div>
        <div class="video-wrapper">
          <video id="input_video" playsinline></video>
          <canvas id="pose_canvas"></canvas>
        </div>
        <div class="control-bar">
          <div class="control-group">
            <button id="btn_toggle">
              <span id="btn_icon">â–¶</span>
              <span id="btn_label">Iniciar captura</span>
            </button>
            <div class="status-pill">
              <span class="status-indicator" id="status_indicator"></span>
              <span id="status_label">En espera</span>
            </div>
          </div>
          <div class="hint">
            PermitÃ­ la cÃ¡mara y ponete centrado de cuerpo entero.
          </div>
        </div>
      </section>

      <!-- Panel derecha: 3D -->
      <section class="panel">
        <div class="panel-header">
          <span>ðŸ¦´ Modelo 3D que replica tu esqueleto</span>
          <div class="chip-row">
            <div class="chip">Three.js</div>
            <div class="chip">FBX skinned</div>
          </div>
        </div>
        <div class="three-wrapper">
          <div id="three_container"></div>
        </div>
        <div class="control-bar">
          <div class="control-group">
            <span class="hint">
              DejÃ¡ <code>modelos/Tyson.fbx</code>, <code>texturas/gltf_embedded_0.jpeg</code> y tus .fbx de animaciÃ³n dentro de <code>animaciones/</code> (ahora organizadas en <code>ataque</code>, <code>descanso</code>, <code>movimiento</code> y <code>daÃ±o</code>).
            </span>
          </div>
          <div class="control-group">
            <label class="hint" for="animation_select">AnimaciÃ³n FBX:</label>
            <select id="animation_select" class="select">
              <option value="none">Ninguna (usar mocap en vivo)</option>
            </select>
            <label class="file-label">
              <span>+ Cargar .fbx</span>
              <input type="file" id="anim_file_input" accept=".fbx" />
            </label>
          </div>
        </div>
      </section>
    </div>
  </main>

  <!-- LÃ³gica principal -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/GLTFLoader.js';
    import { FBXLoader } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/FBXLoader.js';
    import { OBJLoader } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/OBJLoader.js';

    // ==============================
    // 0. Sanity checks
    // ==============================
    console.assert(THREE && typeof THREE.Scene === 'function', 'THREE.Scene debe existir');
    console.assert(typeof OrbitControls === 'function', 'OrbitControls debe ser un constructor');
    console.assert(typeof GLTFLoader === 'function', 'GLTFLoader debe ser un constructor');
    console.assert(typeof FBXLoader === 'function', 'FBXLoader debe ser un constructor');
    console.assert(typeof OBJLoader === 'function', 'OBJLoader debe ser un constructor');
    console.assert(document.getElementById('three_container') instanceof HTMLElement, 'three_container debe existir');

    // ==============================
    // 1. Constantes / utils
    // ==============================
    const MODEL_URL = 'modelos/Tyson.fbx';
    const TEXTURE_URL = 'texturas/gltf_embedded_0.jpeg';
    const DEFAULT_ANIMATIONS = [
      { name: 'Idle to Fight (preset)', url: 'animaciones/descanso/Action Idle To Fight Idle.fbx', loop: 'once' },
      { name: 'Arm Stretching', url: 'animaciones/descanso/Arm Stretching.fbx', loop: 'repeat' },
      { name: 'Situp To Idle', url: 'animaciones/descanso/Situp To Idle.fbx', loop: 'once' },
      { name: 'Getting Up (rest)', url: 'animaciones/descanso/Getting Up.fbx', loop: 'once' },
      { name: 'Reaction', url: 'animaciones/descanso/Reaction.fbx', loop: 'once' },
      { name: 'Walking', url: 'animaciones/movimiento/Walking.fbx', loop: 'repeat' },
      { name: 'Walk Back', url: 'animaciones/movimiento/Walk back.fbx', loop: 'repeat' },
      { name: 'Boxing Combo', url: 'animaciones/ataque/Boxing.fbx', loop: 'repeat' },
      { name: 'Lead Jab', url: 'animaciones/ataque/Lead Jab.fbx', loop: 'once' },
      { name: 'Hook', url: 'animaciones/ataque/Hook.fbx', loop: 'once' },
      { name: 'Jab Cross', url: 'animaciones/ataque/Jab Cross.fbx', loop: 'once' },
      { name: 'Illegal Elbow Punch', url: 'animaciones/ataque/Illegal Elbow Punch.fbx', loop: 'once' },
      { name: 'Pointing Forward', url: 'animaciones/ataque/Pointing Forward.fbx', loop: 'once' },
      { name: 'Punching Bag', url: 'animaciones/ataque/Punching Bag.fbx', loop: 'repeat' },
      { name: 'Dodging', url: 'animaciones/defensa/Dodging.fbx', loop: 'repeat' },
      { name: 'Left Block', url: 'animaciones/defensa/Left Block.fbx', loop: 'repeat' },
      { name: 'Head Hit', url: 'animaciones/daÃ±o/Head Hit.fbx', loop: 'once' },
      { name: 'Light Hit To Head', url: 'animaciones/daÃ±o/Light Hit To Head.fbx', loop: 'once' },
      { name: 'Medium Hit To Head', url: 'animaciones/daÃ±o/Medium Hit To Head.fbx', loop: 'once' },
      { name: 'Big Kidney Hit', url: 'animaciones/daÃ±o/Big Kidney Hit.fbx', loop: 'once' },
      { name: 'Taking Punch', url: 'animaciones/daÃ±o/Taking Punch.fbx', loop: 'once' },
      { name: 'Receive Uppercut To The Face', url: 'animaciones/daÃ±o/Receive Uppercut To The Face.fbx', loop: 'once' },
      { name: 'Convulsing', url: 'animaciones/daÃ±o/Convulsing.fbx', loop: 'once' },
      { name: 'Dying', url: 'animaciones/daÃ±o/Dying.fbx', loop: 'once' },
      { name: 'Fall Flat', url: 'animaciones/daÃ±o/caida/Fall Flat.fbx', loop: 'once' },
      { name: 'Fall Over', url: 'animaciones/daÃ±o/caida/Fall Over.fbx', loop: 'once' },
      { name: 'Knocked Down', url: 'animaciones/daÃ±o/caida/Knocked Down.fbx', loop: 'once' },
      { name: 'Livershot Knockdown', url: 'animaciones/daÃ±o/caida/Livershot Knockdown.fbx', loop: 'once' },
      { name: 'Shoulder Hit And Fall', url: 'animaciones/daÃ±o/caida/Shoulder Hit And Fall.fbx', loop: 'once' },
      { name: 'Laying', url: 'animaciones/daÃ±o/caida/Laying.fbx', loop: 'repeat' },
      { name: 'Getting Up (fall)', url: 'animaciones/daÃ±o/caida/Getting Up.fbx', loop: 'once' },
    ];

    const POSE_LM = {
      NOSE: 0,
      LEFT_EYE_INNER: 1,
      LEFT_EYE: 2,
      LEFT_EYE_OUTER: 3,
      RIGHT_EYE_INNER: 4,
      RIGHT_EYE: 5,
      RIGHT_EYE_OUTER: 6,
      LEFT_EAR: 7,
      RIGHT_EAR: 8,
      MOUTH_LEFT: 9,
      MOUTH_RIGHT: 10,
      LEFT_SHOULDER: 11,
      RIGHT_SHOULDER: 12,
      LEFT_ELBOW: 13,
      RIGHT_ELBOW: 14,
      LEFT_WRIST: 15,
      RIGHT_WRIST: 16,
      LEFT_PINKY: 17,
      RIGHT_PINKY: 18,
      LEFT_INDEX: 19,
      RIGHT_INDEX: 20,
      LEFT_THUMB: 21,
      RIGHT_THUMB: 22,
      LEFT_HIP: 23,
      RIGHT_HIP: 24,
      LEFT_KNEE: 25,
      RIGHT_KNEE: 26,
      LEFT_ANKLE: 27,
      RIGHT_ANKLE: 28,
      LEFT_HEEL: 29,
      RIGHT_HEEL: 30,
      LEFT_FOOT_INDEX: 31,
      RIGHT_FOOT_INDEX: 32,
    };

    function lerp(a, b, t) { return a + (b - a) * t; }

    function lerpLandmark(prev, curr, factor) {
      if (!prev) return curr;
      return {
        x: lerp(prev.x, curr.x, factor),
        y: lerp(prev.y, curr.y, factor),
        z: lerp(prev.z ?? 0, curr.z ?? 0, factor),
        visibility: lerp(prev.visibility ?? 1, curr.visibility ?? 1, factor),
      };
    }

    // ==============================
    // 2. MediaPipe Pose + CÃ¡mara
    // ==============================
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('pose_canvas');
    const canvasCtx = canvasElement.getContext('2d');

    const btnToggle = document.getElementById('btn_toggle');
    const btnIcon = document.getElementById('btn_icon');
    const btnLabel = document.getElementById('btn_label');
    const statusIndicator = document.getElementById('status_indicator');
    const statusLabel = document.getElementById('status_label');

    const animationSelect = document.getElementById('animation_select');
    const animFileInput = document.getElementById('anim_file_input');

    let cameraMP = null;
    let capturing = false;
    let lastPoseLandmarks = null;
    let smoothedLandmarks = null;
    let poseInstance = null;

    // Flag para cortar el retarget y dejar que las animaciones FBX manden.
    let retargetEnabled = true;

    function setStatus(live, text) {
      if (live) statusIndicator.classList.add('live');
      else statusIndicator.classList.remove('live');
      statusLabel.textContent = text;
    }

    function resizeCanvasToVideo() {
      const rect = videoElement.getBoundingClientRect();
      if (!rect.width || !rect.height) return;
      canvasElement.width = rect.width * window.devicePixelRatio;
      canvasElement.height = rect.height * window.devicePixelRatio;
      canvasElement.style.width = rect.width + 'px';
      canvasElement.style.height = rect.height + 'px';
    }

    videoElement.onloadedmetadata = () => { resizeCanvasToVideo(); };
    window.addEventListener('resize', () => {
      if (videoElement.videoWidth > 0) resizeCanvasToVideo();
    });

    function onResultsPose(results) {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      const width = canvasElement.width;
      const height = canvasElement.height;

      if (results.image) {
        canvasCtx.drawImage(results.image, 0, 0, width, height);
      }

      if (results.poseLandmarks) {
        const landmarks = results.poseLandmarks;

        smoothedLandmarks = landmarks.map((lm, i) => {
          const prev = lastPoseLandmarks ? lastPoseLandmarks[i] : null;
          return lerpLandmark(prev, lm, 0.4);
        });
        lastPoseLandmarks = smoothedLandmarks;

        window.drawConnectors(canvasCtx, smoothedLandmarks, window.POSE_CONNECTIONS, {
          color: '#22c55e',
          lineWidth: 2,
        });
        window.drawLandmarks(canvasCtx, smoothedLandmarks, {
          color: '#60a5fa',
          lineWidth: 1,
          radius: 2,
        });

        updateModelFromPose(smoothedLandmarks);
      }

      canvasCtx.restore();
    }

    function initPose() {
      const Pose = window.Pose;
      if (!Pose) {
        console.error('MediaPipe Pose no estÃ¡ disponible');
        setStatus(false, 'Error cargando MediaPipe Pose');
        return;
      }

      poseInstance = new Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
      });
      poseInstance.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        smoothSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });
      poseInstance.onResults(onResultsPose);
    }

    async function startCapture() {
      if (!poseInstance) initPose();
      if (!poseInstance) return;

      capturing = true;
      btnIcon.textContent = 'â¸';
      btnLabel.textContent = 'Detener captura';
      setStatus(true, 'Capturando poseâ€¦');

      const constraints = {
        audio: false,
        video: {
          width: { ideal: 960 },
          height: { ideal: 540 },
          frameRate: { ideal: 30 },
        },
      };

      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoElement.srcObject = stream;
        await videoElement.play();

        resizeCanvasToVideo();

        const Camera = window.Camera;
        if (!Camera) {
          console.error('MediaPipe Camera no estÃ¡ disponible');
          setStatus(false, 'Error cÃ¡mara MediaPipe');
          return;
        }

        cameraMP = new Camera(videoElement, {
          onFrame: async () => {
            if (!capturing) return;
            await poseInstance.send({ image: videoElement });
          },
          width: videoElement.videoWidth,
          height: videoElement.videoHeight,
        });
        cameraMP.start();
      } catch (err) {
        console.error('Error al iniciar cÃ¡mara:', err);
        setStatus(false, 'Error: no se pudo acceder a la cÃ¡mara');
        capturing = false;
        btnIcon.textContent = 'â–¶';
        btnLabel.textContent = 'Reintentar';
      }
    }

    function stopCapture() {
      capturing = false;
      btnIcon.textContent = 'â–¶';
      btnLabel.textContent = 'Iniciar captura';
      setStatus(false, 'Pausa');

      if (cameraMP) {
        cameraMP.stop();
        cameraMP = null;
      }

      const stream = videoElement.srcObject;
      if (stream) {
        stream.getTracks().forEach((t) => t.stop());
        videoElement.srcObject = null;
      }
    }

    btnToggle.addEventListener('click', () => {
      if (capturing) stopCapture();
      else startCapture();
    });

    // ==============================
    // 3. Three.js â€“ escena y modelo
    // ==============================
    const threeContainer = document.getElementById('three_container');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf5f7fb);

    const camera3D = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera3D.position.set(0, 1.6, 3.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(threeContainer.clientWidth || 640, threeContainer.clientHeight || 360);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    threeContainer.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera3D, renderer.domElement);
    controls.target.set(0, 1.3, 0);
    controls.update();

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0xcfd8e3, 0.6);
    scene.add(hemiLight);

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.6);
    keyLight.position.set(2.5, 5, 3.2);
    keyLight.castShadow = true;
    scene.add(keyLight);

    const fillLight = new THREE.DirectionalLight(0xf0f4ff, 0.9);
    fillLight.position.set(-3, 3, 2);
    fillLight.castShadow = false;
    scene.add(fillLight);

    const rimLight = new THREE.DirectionalLight(0xffffff, 0.8);
    rimLight.position.set(0, 4.2, -3.5);
    rimLight.castShadow = false;
    scene.add(rimLight);

    const floorGeo = new THREE.CircleGeometry(3, 64);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0xe5e9f2, metalness: 0.05, roughness: 0.95 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    floor.receiveShadow = true;
    scene.add(floor);

    let mixer = null;
    let actions = {};
    let activeAction = null;
    let pendingClips = [];
    let skeleton = null;
    const bonesByName = {};
    let modelRoot = null;

    // Carga de textura para el modelo Tyson
    const textureLoader = new THREE.TextureLoader();
    const tysonTexture = textureLoader.load(TEXTURE_URL);
    tysonTexture.colorSpace = THREE.SRGBColorSpace;
    // Si la textura se ve invertida verticalmente, probÃ¡ comentar la siguiente lÃ­nea:
    tysonTexture.flipY = false;

    function getLoaderFor(url) {
      const lower = url.toLowerCase();
      if (lower.endsWith('.glb') || lower.endsWith('.gltf')) return { loader: new GLTFLoader(), type: 'gltf' };
      if (lower.endsWith('.fbx')) return { loader: new FBXLoader(), type: 'fbx' };
      if (lower.endsWith('.obj')) return { loader: new OBJLoader(), type: 'obj' };
      throw new Error('ExtensiÃ³n de modelo no soportada: ' + url);
    }

    function addAnimationOption(name) {
      if (!animationSelect) return;
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      animationSelect.appendChild(opt);
    }

    function loadModel(url) {
      const { loader, type } = getLoaderFor(url);
      loader.load(
        url,
        (asset) => {
          let root = (type === 'gltf') ? asset.scene : asset;
          modelRoot = root;

          modelRoot.traverse((obj) => {
            if (obj.isMesh) {
              obj.castShadow = true;
              obj.frustumCulled = false;

              // Aplicar la textura al material del mesh
              if (tysonTexture && obj.material) {
                if (Array.isArray(obj.material)) {
                  obj.material.forEach((m) => {
                    m.map = tysonTexture;
                    m.needsUpdate = true;
                  });
                } else {
                  obj.material.map = tysonTexture;
                  obj.material.needsUpdate = true;
                }
              }
            }
            if (obj.isSkinnedMesh) skeleton = obj.skeleton;
            if (obj.isBone) {
              bonesByName[obj.name] = obj;
              const cleaned = obj.name
                .replace(/^mixamorig[:_ ]?/i, '')
                .replace(/^mixamorig/i, '');
              if (cleaned && cleaned !== obj.name) {
                bonesByName[cleaned] = obj;
                bonesByName[cleaned.toLowerCase()] = obj;
              }
              bonesByName[obj.name.toLowerCase()] = obj;
            }
          });

          scene.add(modelRoot);

          const bbox = new THREE.Box3().setFromObject(modelRoot);
          const size = new THREE.Vector3();
          const center = new THREE.Vector3();
          bbox.getSize(size);
          bbox.getCenter(center);

          modelRoot.position.x += -center.x;
          modelRoot.position.z += -center.z;
          modelRoot.position.y += -bbox.min.y;

          scene.updateMatrixWorld(true);
          captureBindInfo();

          // Crear mixer y enganchar cualquier animaciÃ³n que venga dentro del modelo + las pendientes.
          mixer = new THREE.AnimationMixer(modelRoot);

          if (asset.animations && asset.animations.length) {
            asset.animations.forEach((clip, idx) => {
              const name = clip.name || `Clip_modelo_${idx}`;
              const action = mixer.clipAction(clip);
              action.loop = THREE.LoopRepeat;
              actions[name] = action;
              addAnimationOption(name);
            });
          }

          if (pendingClips.length) {
            pendingClips.forEach(({ clip, name, loop }) => {
              const action = mixer.clipAction(clip);
              const shouldLoop = loop !== 'once';
              action.loop = shouldLoop ? THREE.LoopRepeat : THREE.LoopOnce;
              action.clampWhenFinished = !shouldLoop;
              actions[name] = action;
              addAnimationOption(name);
            });
            pendingClips = [];
          }

          console.log('Modelo cargado (fbx). Huesos detectados:', Object.keys(bonesByName));
        },
        (xhr) => {
          if (xhr.total) {
            const p = (xhr.loaded / xhr.total) * 100;
            setStatus(false, `Cargando modelo 3Dâ€¦ ${p.toFixed(0)}%`);
          } else {
            setStatus(false, 'Cargando modelo 3Dâ€¦');
          }
        },
        (error) => {
          console.error('Error al cargar modelo:', error);
          setStatus(false, 'Error cargando modelo 3D');
        }
      );
    }

    function loadAnimationFBXFromURL(url, displayName, loopMode = 'repeat') {
      const loader = new FBXLoader();
      loader.load(
        url,
        (asset) => {
          const clips = asset.animations || [];
          if (!clips.length) {
            console.warn('El FBX no trae animaciones:', url);
            return;
          }

          clips.forEach((clip, idx) => {
            const name =
              displayName ||
              clip.name ||
              `Clip_${Object.keys(actions).length + idx}`;

            if (!modelRoot || !mixer) {
              // Guardamos la animaciÃ³n para engancharla cuando el modelo estÃ© listo.
              pendingClips.push({ clip, name, loop: loopMode });
            } else {
              const action = mixer.clipAction(clip);
              const shouldLoop = loopMode !== 'once';
              action.loop = shouldLoop ? THREE.LoopRepeat : THREE.LoopOnce;
              action.clampWhenFinished = !shouldLoop;
              action.enabled = true;
              actions[name] = action;
              addAnimationOption(name);
            }
          });
          setStatus(false, 'AnimaciÃ³n cargada: ' + (displayName || url));
        },
        undefined,
        (err) => {
          console.error('Error al cargar animaciÃ³n FBX:', err);
          setStatus(false, 'Error cargando animaciÃ³n FBX');
        }
      );
    }

    function playAnimation(name) {
      if (!mixer) return;
      const action = actions[name];
      if (!action) return;

      if (activeAction === action) return;

      if (activeAction) {
        activeAction.fadeOut(0.25);
      }
      action.reset().fadeIn(0.25).play();
      activeAction = action;
    }

    function stopAllAnimations() {
      if (!mixer) return;
      Object.values(actions).forEach((action) => action.stop());
      activeAction = null;
    }

    loadModel(MODEL_URL);

    // Cargar animaciones por defecto (por ejemplo: animaciones/descanso/Action Idle To Fight Idle.fbx)
    DEFAULT_ANIMATIONS.forEach((entry) => {
      loadAnimationFBXFromURL(entry.url, entry.name, entry.loop);
    });

    function onWindowResize() {
      const width = threeContainer.clientWidth || 640;
      const height = threeContainer.clientHeight || 360;
      camera3D.aspect = width / height;
      camera3D.updateProjectionMatrix();
      renderer.setSize(width, height);
    }
    window.addEventListener('resize', onWindowResize);

    // ==============================
    // 3.1. UI animaciones (selector + file input)
    // ==============================
    if (animationSelect) {
      animationSelect.addEventListener('change', () => {
        const selected = animationSelect.value;
        if (!selected || selected === 'none') {
          // Volvemos a modo "mocap en vivo"
          retargetEnabled = true;
          stopAllAnimations();
          setStatus(capturing, capturing ? 'Capturando poseâ€¦' : 'Listo. Mocap en vivo');
        } else {
          // Pasamos a modo animaciÃ³n FBX
          retargetEnabled = false;
          playAnimation(selected);
          setStatus(false, 'Reproduciendo animaciÃ³n: ' + selected);
        }
      });
    }

    if (animFileInput) {
      animFileInput.addEventListener('change', (event) => {
        const files = Array.from(event.target.files || []);
        files.forEach((file) => {
          const url = URL.createObjectURL(file);
          const name = file.name.replace(/\.[^/.]+$/, '');
          loadAnimationFBXFromURL(url, name);
        });
        animFileInput.value = '';
      });
    }

    // ==============================
    // 4. Retarget: pose â†’ huesos (incluye torso + cabeza)
    // ==============================
    const tmpVecA = new THREE.Vector3();
    const tmpVecB = new THREE.Vector3();
    const tmpDir  = new THREE.Vector3();

    function lmToVec3(lm) {
      if (!lm) return null;
      // Invertimos Z: hacia la cÃ¡mara en MediaPipe = hacia delante en 3D
      const x = (lm.x - 0.5) * 2;
      const y = (lm.y - 0.5) * -2;
      const z = -(lm.z ?? 0) * 2;
      return new THREE.Vector3(x, y, z);
    }

    function getBone(name) {
      return (
        bonesByName[name] ||
        bonesByName[name.toLowerCase()] ||
        bonesByName['mixamorig' + name]
      );
    }

    // --- Bind info: direcciÃ³n del hueso + quat mundo en pose de reposo ---
    const BIND = {}; // BIND[boneName] = { dir: Vector3 (world), wq: Quaternion (world) }

    const BIND_PAIRS = [
      // Torso
      ['Hips',   'Spine'],
      ['Spine',  'Spine1'],
      ['Spine1', 'Spine2'],
      ['Spine2', 'Neck'],
      ['Neck',   'Head'],
      ['Head',   'HeadTop_End'],

      // Hombros â†’ brazos
      ['LeftShoulder',  'LeftArm'],
      ['RightShoulder', 'RightArm'],

      // Brazos
      ['LeftArm',      'LeftForeArm'],
      ['LeftForeArm',  'LeftHand'],
      ['RightArm',     'RightForeArm'],
      ['RightForeArm', 'RightHand'],

      // Piernas
      ['LeftUpLeg',   'LeftLeg'],
      ['LeftLeg',     'LeftFoot'],
      ['RightUpLeg',  'RightLeg'],
      ['RightLeg',    'RightFoot'],
    ];

    function captureBindInfo() {
      for (const k of Object.keys(BIND)) delete BIND[k];

      scene.updateMatrixWorld(true);

      const missing = [];

      for (const [aName, bName] of BIND_PAIRS) {
        const A = getBone(aName);
        const B = getBone(bName);

        if (!A || !B) {
          missing.push(`${aName}->${bName} (A:${!!A} B:${!!B})`);
          continue;
        }

        const aPos = new THREE.Vector3().setFromMatrixPosition(A.matrixWorld);
        const bPos = new THREE.Vector3().setFromMatrixPosition(B.matrixWorld);

        const dirWorld = bPos.clone().sub(aPos).normalize();
        const rotWorld = new THREE.Quaternion().setFromRotationMatrix(
          new THREE.Matrix4().extractRotation(A.matrixWorld)
        );

        BIND[aName] = { dir: dirWorld, wq: rotWorld };
      }

      console.log('Bind info capturada para huesos:', Object.keys(BIND));
      if (missing.length) {
        console.warn('Pares de huesos sin bind (puede ser normal):', missing);
      }
    }

    function worldQuatToLocal(bone, targetWorldQuat) {
      const parentWorld = bone.parent
        ? bone.parent.getWorldQuaternion(new THREE.Quaternion())
        : new THREE.Quaternion();
      const parentWorldInv = parentWorld.clone().invert();
      return parentWorldInv.multiply(targetWorldQuat);
    }

    function orientBoneFromDirection(boneName, dirWorld, slerp = 0.35) {
      const bone = getBone(boneName);
      if (!skeleton || !bone || !dirWorld) return;

      const info = BIND[boneName];
      if (!info) return;

      const targetDir = dirWorld.clone().normalize();
      if (targetDir.lengthSq() < 1e-6) return;

      const qDelta = new THREE.Quaternion().setFromUnitVectors(info.dir, targetDir);
      const targetWorld = info.wq.clone().premultiply(qDelta);
      const targetLocal = worldQuatToLocal(bone, targetWorld);

      bone.quaternion.slerp(targetLocal, slerp);
    }

    function orientBoneFromLandmarks(boneName, lmStartIdx, lmEndIdx, slerp = 0.35) {
      const bone = getBone(boneName);
      if (!skeleton || !bone || !smoothedLandmarks) return;

      const lmStart = smoothedLandmarks[lmStartIdx];
      const lmEnd   = smoothedLandmarks[lmEndIdx];
      if (!lmStart || !lmEnd) return;
      if ((lmStart.visibility ?? 0) < 0.4 || (lmEnd.visibility ?? 0) < 0.4) return;

      const info = BIND[boneName];
      if (!info) return;

      const vStart = lmToVec3(lmStart);
      const vEnd   = lmToVec3(lmEnd);
      const dir    = vEnd.clone().sub(vStart).normalize();
      if (dir.lengthSq() < 1e-6) return;

      const qDelta = new THREE.Quaternion().setFromUnitVectors(info.dir, dir);
      const targetWorld = info.wq.clone().premultiply(qDelta);
      const targetLocal = worldQuatToLocal(bone, targetWorld);

      bone.quaternion.slerp(targetLocal, slerp);
    }

    function updateModelFromPose(landmarks) {
      if (!retargetEnabled) return; // Si estÃ¡ en modo animaciÃ³n FBX, no tocamos los huesos.
      if (!landmarks || !skeleton) return;

      const lmLS   = landmarks[POSE_LM.LEFT_SHOULDER];
      const lmRS   = landmarks[POSE_LM.RIGHT_SHOULDER];
      const lmLH   = landmarks[POSE_LM.LEFT_HIP];
      const lmRH   = landmarks[POSE_LM.RIGHT_HIP];
      const lmNose = landmarks[POSE_LM.NOSE];

      const hips = getBone('Hips') || getBone('hips');

      if (hips && lmLS && lmRS && lmLH && lmRH) {
        const vLS = lmToVec3(lmLS);
        const vRS = lmToVec3(lmRS);
        const vLH = lmToVec3(lmLH);
        const vRH = lmToVec3(lmRH);

        const vShoulderMid = tmpVecA.copy(vLS).add(vRS).multiplyScalar(0.5);
        const vHipMid      = tmpVecB.copy(vLH).add(vRH).multiplyScalar(0.5);

        const torsoDir = tmpDir.copy(vShoulderMid).sub(vHipMid).normalize();

        // Hips orientados por torsoDir
        const infoHips = BIND['Hips'];
        if (infoHips) {
          const qDelta = new THREE.Quaternion().setFromUnitVectors(infoHips.dir, torsoDir);
          const targetWorld = infoHips.wq.clone().premultiply(qDelta);
          const targetLocal = worldQuatToLocal(hips, targetWorld);
          hips.quaternion.slerp(targetLocal, 0.25);
        }

        // Altura de las caderas (traslaciÃ³n simple)
        hips.position.lerp(new THREE.Vector3(0, vHipMid.y * 0.4 + 1.0, 0), 0.15);

        // Torso completo
        orientBoneFromDirection('Spine',  torsoDir, 0.35);
        orientBoneFromDirection('Spine1', torsoDir, 0.35);
        orientBoneFromDirection('Spine2', torsoDir, 0.35);

        // Cabeza / cuello desde hombros â†’ nariz
        if (lmNose) {
          const vNose   = lmToVec3(lmNose);
          const headDir = vNose.clone().sub(vShoulderMid).normalize();

          orientBoneFromDirection('Neck', headDir, 0.45);
          orientBoneFromDirection('Head', headDir, 0.55);
        }
      }

      // Brazos
      orientBoneFromLandmarks('LeftArm',     POSE_LM.LEFT_SHOULDER,  POSE_LM.LEFT_ELBOW);
      orientBoneFromLandmarks('LeftForeArm', POSE_LM.LEFT_ELBOW,     POSE_LM.LEFT_WRIST);
      orientBoneFromLandmarks('RightArm',    POSE_LM.RIGHT_SHOULDER, POSE_LM.RIGHT_ELBOW);
      orientBoneFromLandmarks('RightForeArm',POSE_LM.RIGHT_ELBOW,    POSE_LM.RIGHT_WRIST);

      // Piernas
      orientBoneFromLandmarks('LeftUpLeg',   POSE_LM.LEFT_HIP,       POSE_LM.LEFT_KNEE);
      orientBoneFromLandmarks('LeftLeg',     POSE_LM.LEFT_KNEE,      POSE_LM.LEFT_ANKLE);
      orientBoneFromLandmarks('RightUpLeg',  POSE_LM.RIGHT_HIP,      POSE_LM.RIGHT_KNEE);
      orientBoneFromLandmarks('RightLeg',    POSE_LM.RIGHT_KNEE,     POSE_LM.RIGHT_ANKLE);
    }

    // ==============================
    // 5. Loop de render
    // ==============================
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (mixer) mixer.update(delta);
      renderer.render(scene, camera3D);
    }
    animate();

    onWindowResize();
    setStatus(false, 'Listo. TocÃ¡ "Iniciar captura"');
  </script>
</body>
</html>
