<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Boxing VR - Mixed Reality</title>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Holistic (Cuerpo, Manos, Cara) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <!-- Fuente Futurista -->
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Share Tech Mono', monospace;
            user-select: none;
        }

        /* Capas de visualización */
        #container-layer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* Capa 1: Fondo (Wireframe del Jugador) */
        #visualizer-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transform: scaleX(-1); /* Efecto espejo */
        }

        /* Capa 2: Juego 3D (Saco, Ring, Efectos) */
        #three-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Permitir clicks pasen si es necesario */
        }

        /* Capa 3: Interfaz de Usuario (HUD) */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        /* Video Input Oculto */
        .input_video { display: none; }

        /* Estilos HUD Cyberpunk */
        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 40px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .score-box { text-align: left; }
        .score-val {
            font-size: 60px;
            color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc;
        }
        .score-lbl { color: #00ffcc; font-size: 14px; letter-spacing: 2px; opacity: 0.8; }

        .health-bar-frame {
            width: 400px;
            height: 20px;
            background: rgba(0, 20, 10, 0.8);
            border: 1px solid #00ffcc;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.2);
            overflow: hidden;
            margin-top: 5px;
        }

        .health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ffcc, #004433);
            transition: width 0.1s;
        }

        #combo-display {
            position: absolute;
            right: 50px;
            top: 150px;
            text-align: right;
        }
        .combo-n { 
            font-size: 80px; 
            color: #ff0055; 
            text-shadow: 2px 2px 0px #fff, 0 0 20px #ff0055;
        }
        .combo-t { color: #fff; letter-spacing: 5px; }

        /* Pantallas de Inicio / Carga */
        #start-screen {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.95);
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        h1 {
            font-size: 70px;
            color: #00ffcc;
            text-shadow: 0 0 20px #00ffcc;
            margin: 0 0 20px 0;
            text-transform: uppercase;
        }

        p { color: #aaa; max-width: 600px; text-align: center; font-size: 18px; line-height: 1.6; margin-bottom: 40px; }

        button {
            background: transparent;
            border: 2px solid #00ffcc;
            color: #00ffcc;
            padding: 15px 50px;
            font-size: 24px;
            font-family: 'Share Tech Mono', monospace;
            cursor: pointer;
            text-transform: uppercase;
            transition: 0.2s;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
        }
        button:hover { 
            background: #00ffcc; 
            color: #000; 
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.6);
        }

        .loader {
            display: none;
            border: 4px solid #111;
            border-top: 4px solid #00ffcc;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-top: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Efecto Scanline del Visualizador */
        .scanline {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
            opacity: 0.3;
        }
        
    </style>
</head>
<body>

    <div id="container-layer">
        <video class="input_video"></video>
        
        <!-- Capa 1: Visualizador (Fondo) -->
        <canvas id="visualizer-canvas"></canvas>
        
        <!-- Capa 2: Three.js (Saco y físicas) -->
        <div id="three-container"></div>
        
        <!-- Efecto Scanline -->
        <div class="scanline"></div>

        <!-- Capa 3: UI -->
        <div id="ui-layer">
            <div class="hud-top">
                <div class="score-box">
                    <div class="score-lbl">SCORE</div>
                    <div class="score-val" id="score">0</div>
                </div>
                <div style="display:flex; flex-direction:column; align-items:center;">
                    <div class="score-lbl">TARGET INTEGRITY</div>
                    <div class="health-bar-frame">
                        <div class="health-fill" id="bag-health"></div>
                    </div>
                </div>
                <div class="score-box" style="text-align:right;">
                    <div class="score-lbl">SYS.STATUS</div>
                    <div style="color:#00ffcc; font-size:20px;">ONLINE</div>
                </div>
            </div>
            <div id="combo-display">
                <div class="combo-n" id="combo">0</div>
                <div class="combo-t">HITS</div>
            </div>
        </div>
    </div>

    <!-- Pantalla de Inicio -->
    <div id="start-screen">
        <h1>Cyber Boxing</h1>
        <p>
            <strong>PROTOCOL: MIXED REALITY</strong><br>
            Tu cuerpo digital ha sido cargado.<br>
            Usa tus puños de neón para golpear el objetivo.<br>
            Aléjate de la cámara para que capture tu cintura.
        </p>
        <button id="start-btn">INICIAR SISTEMA</button>
        <div class="loader" id="loader"></div>
        <div id="loading-text" style="display:none; color:#00ffcc; margin-top:10px;">CARGANDO RED NEURONAL...</div>
    </div>

    <script>
        // ==========================================
        // CONFIGURACIÓN VISUAL (DEL VISUALIZADOR)
        // ==========================================
        const theme = { 
            name: "CYAN", 
            main: '#00FFCC', 
            sub: '#004433', 
            bg: 'rgba(0,0,0,0.95)' // Fondo oscuro para resaltar el neon
        };

        const canvasVis = document.getElementById('visualizer-canvas');
        const ctxVis = canvasVis.getContext('2d');

        // Funciones de dibujo Sci-Fi
        function drawConnectorsSciFi(ctx, landmarks, connectors, color, width) {
            if (!landmarks || !connectors) return;
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            
            for (const connector of connectors) {
                const from = landmarks[connector[0]];
                const to = landmarks[connector[1]];
                if (from && to) {
                    ctx.beginPath();
                    ctx.moveTo(from.x * canvasVis.width, from.y * canvasVis.height);
                    ctx.lineTo(to.x * canvasVis.width, to.y * canvasVis.height);
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        function drawLandmarksSciFi(ctx, landmarks, color, radius) {
            if (!landmarks) return;
            ctx.save();
            ctx.fillStyle = color;
            ctx.shadowBlur = 5;
            ctx.shadowColor = color;
            
            for (const landmark of landmarks) {
                const x = landmark.x * canvasVis.width;
                const y = landmark.y * canvasVis.height;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.restore();
        }

        // ==========================================
        // LÓGICA DE JUEGO & THREE.JS (DEL INDEX)
        // ==========================================
        let scene, camera, renderer;
        let bag, bagChain, targetSpot;
        
        // El jugador ahora es invisible en 3D, pero sus colliders existen
        const player = {
            leftGlove: null, // Collider invisible
            rightGlove: null, // Collider invisible
            leftLight: null, // Luz ambiental para iluminar el saco al golpear
            rightLight: null
        };

        let audioCtx;
        const gameState = {
            score: 0,
            combo: 0,
            bagHealth: 100,
            lastHit: 0,
            isPlaying: false
        };

        const bagPhysics = {
            velocity: new THREE.Vector3(),
            angleX: 0, angleZ: 0,
            angularVelX: 0, angularVelZ: 0
        };

        // Elementos DOM UI
        const scoreEl = document.getElementById('score');
        const comboEl = document.getElementById('combo');
        const healthEl = document.getElementById('bag-health');

        function initThree() {
            const container = document.getElementById('three-container');
            
            // Escena con fondo transparente para ver el Canvas del Visualizador detrás
            scene = new THREE.Scene();
            
            // Cámara ajustada para VR "de escritorio"
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 3.5); // Un poco más cerca que antes

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha true para transparencia
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Transparente
            renderer.shadowMap.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            // Iluminación
            const ambient = new THREE.AmbientLight(0x444444);
            scene.add(ambient);

            const spot = new THREE.SpotLight(0x00ffcc, 1);
            spot.position.set(0, 6, 2);
            spot.castShadow = true;
            spot.angle = 0.6;
            scene.add(spot);

            // Creamos solo el saco y un suelo de "Grid" para referencia espacial
            createEnvironment();
            createBag();
            createInvisiblePlayer();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createEnvironment() {
            // Suelo Grid Holográfico
            const grid = new THREE.GridHelper(20, 20, 0x00ffcc, 0x003322);
            grid.position.y = 0;
            scene.add(grid);
            
            // Luz inferior para dar ambiente Cyberpunk
            const bottomLight = new THREE.PointLight(0xff0055, 0.5, 10);
            bottomLight.position.set(0, 0.5, 0);
            scene.add(bottomLight);
        }

        function createBag() {
            const pivot = new THREE.Group();
            pivot.position.set(0, 3.5, -1.0); // Saco centrado
            scene.add(pivot);
            bagChain = pivot;

            // Cadena
            const chain = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 1.5),
                new THREE.MeshStandardMaterial({color: 0x555555})
            );
            chain.position.y = -0.75;
            pivot.add(chain);

            // Saco
            const bagGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.4, 32);
            const bagMat = new THREE.MeshStandardMaterial({
                color: 0x111111, roughness: 0.2, metalness: 0.8,
                emissive: 0x001111
            });
            bag = new THREE.Mesh(bagGeo, bagMat);
            bag.position.y = -1.7;
            bag.castShadow = true;
            bag.receiveShadow = true;
            pivot.add(bag);

            // Anillos de neón en el saco
            const ringGeo = new THREE.TorusGeometry(0.31, 0.01, 16, 32);
            const ringMat = new THREE.MeshBasicMaterial({color: 0x00ffcc});
            const r1 = new THREE.Mesh(ringGeo, ringMat); r1.position.y = 0.4;
            const r2 = new THREE.Mesh(ringGeo, ringMat); r2.position.y = -0.4;
            bag.add(r1); bag.add(r2);

            // Target
            targetSpot = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 16, 16),
                new THREE.MeshBasicMaterial({color: 0xff0055})
            );
            targetSpot.position.set(0, 0, 0.3);
            bag.add(targetSpot);
            
            animateTarget();
        }

        function animateTarget() {
            if(!gameState.isPlaying) return;
            const angle = (Math.random()-0.5) * 2.0;
            const h = (Math.random()-0.5) * 0.8;
            targetSpot.position.set(Math.sin(angle)*0.31, h, Math.cos(angle)*0.31);
            setTimeout(animateTarget, 2000);
        }

        function createInvisiblePlayer() {
            // Creamos "manos" invisibles para las físicas.
            // No se renderizan (visible=false), pero su posición se actualiza para chocar con el saco.
            const gloveGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const gloveMat = new THREE.MeshBasicMaterial({visible: false}); // INVISIBLE

            player.leftGlove = new THREE.Mesh(gloveGeo, gloveMat);
            scene.add(player.leftGlove);

            player.rightGlove = new THREE.Mesh(gloveGeo, gloveMat);
            scene.add(player.rightGlove);

            // Luces que siguen a las manos para iluminar el saco al acercarse
            player.leftLight = new THREE.PointLight(0x00ffcc, 0, 2);
            scene.add(player.leftLight);
            
            player.rightLight = new THREE.PointLight(0x00ffcc, 0, 2);
            scene.add(player.rightLight);
        }

        // ==========================================
        // INTEGRACIÓN MEDIAPIPE (HOLISTIC)
        // ==========================================
        
        function onResults(results) {
            // 1. Dibujar Visualizador (Fondo)
            canvasVis.width = window.innerWidth;
            canvasVis.height = window.innerHeight;
            ctxVis.save();
            ctxVis.clearRect(0, 0, canvasVis.width, canvasVis.height);

            // Fondo semitransparente oscuro
            ctxVis.fillStyle = theme.bg;
            ctxVis.fillRect(0, 0, canvasVis.width, canvasVis.height);

            // Dibujamos el wireframe "Espejo"
            // Pose
            drawConnectorsSciFi(ctxVis, results.poseLandmarks, POSE_CONNECTIONS, theme.sub, 2);
            drawLandmarksSciFi(ctxVis, results.poseLandmarks, theme.main, 4);

            // Cara (Simplificada)
            drawConnectorsSciFi(ctxVis, results.faceLandmarks, FACEMESH_TESSELATION, theme.sub, 0.3);
            drawConnectorsSciFi(ctxVis, results.faceLandmarks, FACEMESH_RIGHT_EYE, '#fff', 1);
            drawConnectorsSciFi(ctxVis, results.faceLandmarks, FACEMESH_LEFT_EYE, '#fff', 1);

            // Manos (Detalladas)
            drawConnectorsSciFi(ctxVis, results.leftHandLandmarks, HAND_CONNECTIONS, theme.main, 2);
            drawLandmarksSciFi(ctxVis, results.leftHandLandmarks, '#fff', 3);
            
            drawConnectorsSciFi(ctxVis, results.rightHandLandmarks, HAND_CONNECTIONS, theme.main, 2);
            drawLandmarksSciFi(ctxVis, results.rightHandLandmarks, '#fff', 3);

            ctxVis.restore();

            // 2. Actualizar Lógica de Juego (Colliders invisibles)
            if (results.poseLandmarks) {
                updateGamePhysics(results.poseLandmarks, results.leftHandLandmarks, results.rightHandLandmarks);
            }
        }

        function updateGamePhysics(poseLM, leftHandLM, rightHandLM) {
            // Mapeo de coordenadas 2D (MediaPipe) a 3D (Three.js)
            // Esto permite que el dibujo 2D "toque" el objeto 3D virtualmente.

            // Cabeza para mover la cámara (Efecto parallax)
            const nose = poseLM[0];
            const headX = (0.5 - nose.x) * 4; 
            const headY = (1.0 - nose.y) * 2 + 0.5;
            
            // Suavizado cámara
            camera.position.x += (headX - camera.position.x) * 0.1;
            camera.position.y += (headY - camera.position.y) * 0.1;

            // Función para posicionar guante invisible
            function updateHand(gloveMesh, light, poseIdx, handLM, isRight) {
                // Si tenemos tracking de dedos, usamos la muñeca de la mano precisa
                // Si no, usamos la muñeca de la pose general
                let x, y, z_depth;

                if (handLM) {
                    // Usar muñeca de la mano (índice 0)
                    const w = handLM[0];
                    x = (0.5 - w.x) * 4; // Factor de escala ancho
                    y = (1.0 - w.y) * 2 + 0.5; // Factor de escala alto
                    // Z estimado por tamaño de mano relativo a hombro o por Z de Pose
                    // Usamos Z de pose para profundidad general
                } else {
                    const w = poseLM[poseIdx];
                    x = (0.5 - w.x) * 4;
                    y = (1.0 - w.y) * 2 + 0.5;
                }

                // Profundidad Z: Crítico para golpear
                // MediaPipe Pose Z es relativo a caderas. 
                // Necesitamos amplificar el movimiento hacia adelante.
                const poseWrist = poseLM[poseIdx];
                // Ajuste empírico: -1.0 es cerca de la cámara, -3.0 es fondo
                // poseWrist.z suele variar entre -0.5 (cerca) y 0.5 (lejos)
                const zBase = camera.position.z - 1.5; 
                // Multiplicador agresivo para detectar el puñetazo
                const zPunch = poseWrist.z * 5; 
                
                const targetPos = new THREE.Vector3(x, y, zBase + zPunch);

                // Lerp para suavidad pero rápido para respuesta
                gloveMesh.position.lerp(targetPos, 0.4);
                
                // Mover luz con el guante
                light.position.copy(gloveMesh.position);
                
                // Detección golpe
                checkHit(gloveMesh, isRight, light);
            }

            // Izquierda (Pose 15)
            updateHand(player.leftGlove, player.leftLight, 15, leftHandLM, false);
            // Derecha (Pose 16)
            updateHand(player.rightGlove, player.rightLight, 16, rightHandLM, true);
        }

        function checkHit(gloveMesh, isRight, light) {
            const bagPos = new THREE.Vector3();
            bag.getWorldPosition(bagPos);

            // Distancia de colisión (Radio saco + radio guante aprox)
            const dist = gloveMesh.position.distanceTo(bagPos);
            
            // Lógica de encendido de luz de proximidad
            const intensity = Math.max(0, 1 - (dist * 1.5));
            light.intensity = intensity * 2;

            if (dist < 0.55 && (Date.now() - gameState.lastHit > 200)) {
                // Verificar profundidad (solo golpea si está "dentro" o cerca en Z)
                if (gloveMesh.position.z < bagPos.z + 0.2) {
                    
                    // Calcular vector de impacto
                    const impactDir = new THREE.Vector3().subVectors(bagPos, gloveMesh.position).normalize();
                    
                    // Físicas saco
                    bagPhysics.angularVelX += impactDir.z * 0.1;
                    bagPhysics.angularVelZ -= impactDir.x * 0.1;

                    // Crítico (golpear al punto rojo)
                    const targetPos = new THREE.Vector3();
                    targetSpot.getWorldPosition(targetPos);
                    const isCrit = gloveMesh.position.distanceTo(targetPos) < 0.25;

                    registerHit(isCrit);
                    gameState.lastHit = Date.now();

                    // Flash visual
                    const flash = new THREE.PointLight(isCrit ? 0xff0055 : 0x00ffcc, 5, 5);
                    flash.position.copy(gloveMesh.position);
                    scene.add(flash);
                    setTimeout(() => scene.remove(flash), 100);
                }
            }
        }

        function registerHit(isCrit) {
            playSound(isCrit);
            const dmg = isCrit ? 15 : 5;
            gameState.score += dmg * 10;
            gameState.combo++;
            gameState.bagHealth -= dmg;

            scoreEl.innerText = gameState.score;
            comboEl.innerText = gameState.combo;
            healthEl.style.width = Math.max(0, gameState.bagHealth) + '%';
            
            comboEl.style.transform = "scale(1.5)";
            setTimeout(() => comboEl.style.transform = "scale(1)", 50);

            if(gameState.bagHealth <= 0) {
                gameState.bagHealth = 100;
                bag.material.emissive.setHex(0xffffff);
                setTimeout(() => bag.material.emissive.setHex(0x001111), 200);
                gameState.score += 1000;
            }
        }

        function playSound(isCrit) {
            if(!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (isCrit) {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.2);
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
            } else {
                osc.type = 'sine'; // Golpe seco
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.1);
                gain.gain.setValueAtTime(0.8, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            }
            
            osc.start();
            osc.stop(t + 0.2);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Físicas del saco
            const gravity = 0.005;
            const damping = 0.97;

            bagPhysics.angularVelX -= Math.sin(bagPhysics.angleX) * gravity;
            bagPhysics.angularVelX *= damping;
            bagPhysics.angleX += bagPhysics.angularVelX;

            bagPhysics.angularVelZ -= Math.sin(bagPhysics.angleZ) * gravity;
            bagPhysics.angularVelZ *= damping;
            bagPhysics.angleZ += bagPhysics.angularVelZ;

            bagChain.rotation.x = bagPhysics.angleX;
            bagChain.rotation.z = bagPhysics.angleZ;

            renderer.render(scene, camera);
        }

        // ==========================================
        // INICIALIZACIÓN
        // ==========================================
        const videoElement = document.getElementsByClassName('input_video')[0];
        const startBtn = document.getElementById('start-btn');
        const loader = document.getElementById('loader');
        const loadText = document.getElementById('loading-text');

        startBtn.addEventListener('click', async () => {
            startBtn.style.display = 'none';
            loader.style.display = 'block';
            loadText.style.display = 'block';
            
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            initThree();

            const holistic = new Holistic({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;
            }});

            holistic.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: false,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            holistic.onResults(onResults);

            const cameraPipe = new Camera(videoElement, {
                onFrame: async () => {
                    await holistic.send({image: videoElement});
                },
                width: 1280,
                height: 720
            });
            
            await cameraPipe.start();

            document.getElementById('start-screen').style.display = 'none';
            gameState.isPlaying = true;
            animate();
        });

    </script>
</body>
</html>