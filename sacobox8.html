<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gym Box 8 - Boxer POV (Tyson + Animaciones)</title>

    <!-- MediaPipe Pose (globals) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020203;
            user-select: none;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0,0,0,0.9);
            z-index: 10;
        }
        .instruction {
            background: radial-gradient(circle at top, rgba(200,200,220,0.1), rgba(5,5,8,0.9));
            padding: 14px 36px;
            border-radius: 4px;
            border-bottom: 2px solid rgba(255, 100, 50, 0.4);
            display: inline-flex;
            flex-direction: column;
            backdrop-filter: blur(8px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        canvas {
            cursor: crosshair;
        }
        #muteBtn {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 20;
        }
        #viewBtn {
            position: absolute;
            top: 16px;
            right: 110px;
            z-index: 20;
        }
        #webcamBtn {
            position: absolute;
            top: 16px;
            right: 204px;
            z-index: 20;
        }
        #presetBtn {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 20;
        }

        /* Webcam + overlay pose */
        #input_video {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 220px;
            border-radius: 12px;
            transform: scaleX(-1);
            z-index: 30;
            box-shadow: 0 8px 30px rgba(0,0,0,0.9);
            background: #000;
        }
        #pose_canvas {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 220px;
            pointer-events: none;
            transform: scaleX(-1);
            z-index: 31;
        }

        .webcam-label {
            position: fixed;
            bottom: 12px;
            right: 16px;
            transform: translateY(100%);
            font-size: 10px;
            color: #cbd5f5;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            text-shadow: 0 2px 6px rgba(0,0,0,0.9);
            z-index: 32;
            pointer-events: none;
        }

        /* Panel debug */
        #debugPanel {
            position: absolute;
            bottom: 16px;
            left: 16px;
            min-width: 220px;
            background: rgba(10, 12, 18, 0.82);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 12px 14px;
            color: #dbeafe;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            font-size: 12px;
            box-shadow: 0 18px 50px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            z-index: 35;
        }

        #debugPanel .debug-title {
            font-size: 11px;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: #f8fafc;
            opacity: 0.85;
            margin-bottom: 6px;
        }

        #debugPanel .debug-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            padding: 4px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.08);
        }

        #debugPanel .debug-row:last-child {
            border-bottom: none;
        }

        #debugPanel .control-row {
            display: grid;
            grid-template-columns: 1fr 2fr 0.8fr;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.08);
        }

        #debugPanel .control-row:last-child {
            border-bottom: none;
        }

        #debugPanel .control-row input[type="range"] {
            width: 100%;
        }

        #debugPanel .label {
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #94a3b8;
            font-weight: 600;
            font-size: 11px;
        }

        #debugPanel .value {
            font-weight: 700;
            color: #e2e8f0;
            text-align: right;
        }

        /* Tipograf√≠a del encabezado */
        .info-title {
            font-size: 1.5rem;
            font-weight: 900;
            margin-bottom: 0.25rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: #ffe7d6;
        }

        .info-subtitle {
            font-size: 10px;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            font-weight: 700;
            color: #9ca3af;
        }

        /* Botones estilo p√≠ldora */
        .pill-button {
            font-size: 12px;
            padding: 4px 12px;
            border-radius: 9999px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition: transform 0.12s ease, background-color 0.12s ease, border-color 0.12s ease;
        }

        .pill-button:hover {
            transform: translateY(-1px);
            border-color: rgba(255, 153, 102, 0.55);
        }

        .pill-button:active {
            transform: translateY(0);
            background: rgba(0, 0, 0, 0.82);
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>

    <div id="info">
        <div class="instruction">
            <h1 class="info-title">
                Box 8 ‚Ä¢ Tyson POV
            </h1>
            <p class="info-subtitle">
                Animaciones FBX + Webcam opcional ‚Ä¢ Golpes encadenados al saco
            </p>
        </div>
    </div>

    <!-- Bot√≥n de preset d√≠a/noche -->
    <button id="presetBtn" class="pill-button">
        üåô Noche
    </button>

    <!-- Bot√≥n de mute -->
    <button id="muteBtn" class="pill-button">
        üîä ON
    </button>

    <!-- Bot√≥n de webcam -->
    <button id="webcamBtn" class="pill-button">
        üì∑ Webcam OFF
    </button>

    <!-- Bot√≥n de vista en 3ra persona -->
    <button id="viewBtn" class="pill-button">
        üéØ POV
    </button>

    <div id="canvas-container"></div>

    <!-- Webcam + pose overlay -->
    <video id="input_video" playsinline muted></video>
    <canvas id="pose_canvas"></canvas>
    <div class="webcam-label">Webcam desactivada</div>

    <!-- Debug info -->
    <div id="debugPanel">
        <div class="debug-title">Debug</div>
        <div class="debug-row">
            <span class="label">Animaci√≥n</span>
            <span class="value" id="debugAnimation">‚Äî</span>
        </div>
        <div class="debug-row">
            <span class="label">Categor√≠a</span>
            <span class="value" id="debugCategory">‚Äî</span>
        </div>
        <div class="debug-row">
            <span class="label">Sonido</span>
            <span class="value" id="debugSound">‚Äî</span>
        </div>
        <div class="control-row">
            <span class="label">Masa</span>
            <input id="bagMass" type="range" min="20" max="120" step="1" value="60" />
            <span class="value" id="bagMassVal">60 kg</span>
        </div>
        <div class="control-row">
            <span class="label">Lin. damping</span>
            <input id="bagLinearDamping" type="range" min="0" max="1" step="0.01" value="0.6" />
            <span class="value" id="bagLinearDampingVal">0.60</span>
        </div>
        <div class="control-row">
            <span class="label">Ang. damping</span>
            <input id="bagAngularDamping" type="range" min="0" max="1" step="0.01" value="0.8" />
            <span class="value" id="bagAngularDampingVal">0.80</span>
        </div>
        <div class="control-row">
            <span class="label">Masa mano izq.</span>
            <input id="leftHandMass" type="range" min="1" max="10" step="0.1" value="4.5" />
            <span class="value" id="leftHandMassVal">4.5 kg</span>
        </div>
        <div class="control-row">
            <span class="label">√Årea contacto izq.</span>
            <input id="leftHandArea" type="range" min="0.5" max="2.0" step="0.05" value="1" />
            <span class="value" id="leftHandAreaVal">1.00x</span>
        </div>
        <div class="control-row">
            <span class="label">Masa mano der.</span>
            <input id="rightHandMass" type="range" min="1" max="10" step="0.1" value="5.5" />
            <span class="value" id="rightHandMassVal">5.5 kg</span>
        </div>
        <div class="control-row">
            <span class="label">√Årea contacto der.</span>
            <input id="rightHandArea" type="range" min="0.5" max="2.0" step="0.05" value="1" />
            <span class="value" id="rightHandAreaVal">1.00x</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- UTILIDAD DE RUIDO ---
        class SimplexNoise {
            constructor() {
                this.grad3 = [
                    [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                    [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                    [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
                ];
                this.p = [];
                for (let i=0; i<256; i++) this.p[i] = Math.floor(256*Math.random());
                this.perm = [];
                for (let i=0; i<512; i++) this.perm[i] = this.p[i & 255];
            }
            dot(g,x,y){ return g[0]*x + g[1]*y; }
            noise2D(xin,yin){
                let n0,n1,n2;
                const F2 = 0.5*(Math.sqrt(3)-1);
                const s = (xin+yin)*F2;
                const i = Math.floor(xin+s);
                const j = Math.floor(yin+s);
                const G2 = (3-Math.sqrt(3))/6;
                const t = (i+j)*G2;
                const X0=i-t, Y0=j-t;
                const x0=xin-X0, y0=yin-Y0;
                let i1,j1;
                if(x0>y0){ i1=1; j1=0; } else { i1=0; j1=1; }
                const x1=x0-i1+G2, y1=y0-j1+G2;
                const x2=x0-1+2*G2, y2=y0-1+2*G2;
                const ii=i&255, jj=j&255;
                const gi0=this.perm[ii+this.perm[jj]]%12;
                const gi1=this.perm[ii+i1+this.perm[jj+j1]]%12;
                const gi2=this.perm[ii+1+this.perm[jj+1]]%12;
                let t0=.5-x0*x0-y0*y0;
                if(t0<0) n0=0; else { t0*=t0; n0=t0*t0*this.dot(this.grad3[gi0],x0,y0); }
                let t1=.5-x1*x1-y1*y1;
                if(t1<0) n1=0; else { t1*=t1; n1=t1*t1*this.dot(this.grad3[gi1],x1,y1); }
                let t2=.5-x2*x2-y2*y2;
                if(t2<0) n2=0; else { t2*=t2; n2=t2*t2*this.dot(this.grad3[gi2],x2,y2); }
                return 70*(n0+n1+n2);
            }
        }

        // --- CONFIGURACI√ìN ---
        const visualConfig = {
            bag: {
                color: 0x4a3b32,
                roughness: 0.4,
                metalness: 0.1,
                deformationAmount: 0.45,
                bulgeAmount: 0.25,
                elasticity: 0.15,
                damping: 0.85,
                maxVertexSpeed: 2.5,
                noiseFactor: 0.03,
                punchForce: 80,
                mass: 60,
                linearDamping: 0.6,
                angularDamping: 0.8
            }
        };

        const fixedVisualStep = 1 / 60;
        let lastVisualStep = fixedVisualStep;

        const punchConfig = {
            left: {
                effectiveMass: 4.5,
                contactArea: 1.0
            },
            right: {
                effectiveMass: 5.5,
                contactArea: 1.0
            }
        };

        const audioConfig = {
            enabled: true,
            volume: 0.8,
            reverb: {
                enabled: true,
                decay: 1.4,
                mix: 0.35
            }
        };

        // Posici√≥n base del boxeador respecto al saco (aj√∫stalo si quer√©s)
        const BOXER_BASE_X = -0.5;  // izquierda/derecha (0 = alineado al saco)
        const BOXER_BASE_Z = 2.0;   // delante/detr√°s   (0 = mismo plano del saco)
        const MIN_BAG_DISTANCE = 1.25;

        const tysonBasePosition = new THREE.Vector3(BOXER_BASE_X, 0, BOXER_BASE_Z);
        const tysonTargetPosition = tysonBasePosition.clone();

        // Si lo pones en true, vuelven los golpes con el mouse (modo debug)
        const DEBUG_MOUSE_PUNCH = false;

        // Mezcla de animaciones autom√°ticas vs. mocap (webcam):
        // - Pon√© AUTO_ANIMATION_ENABLED en false para desactivar el combo autom√°tico y dejar solo mocap.
        // - Pon√© ENABLE_MOCAP_BLEND en false para correr las animaciones sin capturar webcam/pose.
        const AUTO_ANIMATION_ENABLED = true;
        const ENABLE_MOCAP_BLEND = true;
        const DUST_ENABLED = false;

        const isMobile = window.innerWidth < 768 || /Mobi|Android/i.test(navigator.userAgent);

        const RING_MODEL_URL = 'modelos/Ring 2.glb';

        const gltfLoader = new GLTFLoader();

        // --- VARIABLES GLOBALES ESCENA ---
        let scene, camera, renderer, controls, composer;
        let world;
        const fixedTimeStep = 1 / 60;
        const maxDelta = 0.1;
        let accumulator = 0;
        let lastTime;

        let bagBody, bagMesh, fanMesh, clockHandHour, clockHandMin, clockHandSec;
        let bagVisualOffset = new THREE.Vector3();
        let chains = [];
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const originalPositions = [];
        const vertexVelocities = [];
        const clock = new THREE.Clock();
        let noiseGen;

        let volumetricMesh;
        let doorGodrayMesh;
        let keyLight, fillLight, ringLight, rimLight, ambientLight;
        let cinemaBackLight;
        let ringSpotLights = [];
        let doorLight;
        let fluorescentLights = [];
        let fluorescentGlowCards = [];
        let dustSystem, dustVelocities = [], dustOffsets = [];
        let uiSparks = [];
        let spriteTexture;
        let bokehPass;

        const lightBases = {
            key: 8.8,
            fill: 0.8,
            rim: 1.1,
            ring: 1.5,
            ringSpot: 2.4,
            cinemaBack: 0.22,
            door: 18.5,
            fluorescent: 7.5
        };

        const lightingPresets = {
            night: {
                keyColor: 0xffaa77,
                keyBase: 8.8,
                fillColor: 0x6c7cff,
                fillBase: 0.95,
                rimColor: 0x4a8dff,
                rimBase: 1.25,
                ringColor: 0xffdd88,
                ringBase: 1.65,
                ringSpotColor: 0xffe2b0,
                ringSpotBase: 2.6,
                cinemaBackColor: 0x1a2846,
                cinemaBackBase: 0.22,
                doorColor: 0x4488ff,
                doorBase: 19.5,
                fluorescentColor: 0xf0f6ff,
                fluorescentBase: 8.0,
                ambientSky: 0x222233,
                ambientGround: 0x000000,
                ambientBase: 0.62,
                fogColor: 0x020203,
                fogDensity: 0.06,
                background: 0x020203,
                volumetricHue: 0.09,
                bagPhysics: {
                    mass: 60,
                    linearDamping: 0.6,
                    angularDamping: 0.8
                }
            },
            sunset: {
                keyColor: 0xffc189,
                keyBase: 9.2,
                fillColor: 0x7fa0ff,
                fillBase: 0.78,
                rimColor: 0xff9966,
                rimBase: 1.1,
                ringColor: 0xffe1aa,
                ringBase: 1.35,
                ringSpotColor: 0xffdcb0,
                ringSpotBase: 2.3,
                cinemaBackColor: 0x2c1b10,
                cinemaBackBase: 0.18,
                doorColor: 0xffa85a,
                doorBase: 12.0,
                fluorescentColor: 0xfff2da,
                fluorescentBase: 5.2,
                ambientSky: 0xffcba4,
                ambientGround: 0x110800,
                ambientBase: 0.65,
                fogColor: 0x130b06,
                fogDensity: 0.048,
                background: 0x130b06,
                volumetricHue: 0.07,
                bagPhysics: {
                    mass: 52,
                    linearDamping: 0.55,
                    angularDamping: 0.78
                }
            }
        };

        let currentPreset = 'night';
        let baseFogDensity = lightingPresets[currentPreset].fogDensity;
        let volumetricBaseHue = lightingPresets[currentPreset].volumetricHue;
        let ambientBaseIntensity = lightingPresets[currentPreset].ambientBase;

        // Golpes y respiraci√≥n de luz
        const IMPACT_FLASH_DURATION = 0.12;
        let punchActivity = 0;
        let impactFlashTime = 0;
        let impactFlashStrength = 0;

        // Audio
        let audioContext, masterGain, reverbNode, reverbWetGain, reverbDryGain;
        let audioInitialized = false;
        const audioBuffers = new Map();
        const audioFiles = {
            impacts: [
                'sonidos/golpe_1.mp3',
                'sonidos/golpe_2.mp3',
                'sonidos/golpe_3.mp3',
                'sonidos/golpe_4.mp3',
                'sonidos/golpe_5.mp3',
                'sonidos/golpe_7.mp3',
                'sonidos/golpe_8.mp3',
                'sonidos/golpe_9.mp3',
                'sonidos/golpe_10.mp3'
            ],
            heavyImpact: 'sonidos/impacto_grave.wav',
            bell: 'sonidos/campana.mp3',
            countdown: 'sonidos/cuenta_atras.wav',
            breath: 'sonidos/respira.wav',
            crowd: 'sonidos/publico_enojado.wav',
            shouts: [
                'sonidos/grito_1.wav',
                'sonidos/grito_2.wav',
                'sonidos/grito_3.wav'
            ]
        };

        let animationDirector = null;
        let currentAnimationEntry = null;
        let currentAnimationCategory = null;

        // Debug state
        const debugState = {
            animation: 'Cargando...',
            category: '‚Äî',
            sound: 'En espera'
        };

        const debugElements = {
            animation: document.getElementById('debugAnimation'),
            category: document.getElementById('debugCategory'),
            sound: document.getElementById('debugSound')
        };

        function refreshDebugPanel() {
            if (!debugElements.animation || !debugElements.category || !debugElements.sound) return;
            debugElements.animation.textContent = debugState.animation || '‚Äî';
            debugElements.category.textContent = debugState.category || '‚Äî';
            debugElements.sound.textContent = debugState.sound || '‚Äî';
        }

        function formatAnimationLabel(entry) {
            if (!entry) return '‚Äî';
            if (entry.file) return entry.file.split('/').pop().replace(/\.fbx$/i, '');
            if (entry.name) return entry.name;
            const clip = entry.action?.getClip?.();
            return clip?.name || '‚Äî';
        }

        function updateDebugAnimation(entry) {
            debugState.animation = formatAnimationLabel(entry);
            debugState.category = entry?.category || getClipCategory(entry?.name) || '‚Äî';
            refreshDebugPanel();
        }

        function updateDebugSound(name) {
            const cleanName = (() => {
                if (!name) return '‚Äî';
                if (name.startsWith('impact:')) {
                    return name
                        .replace('impact:', '')
                        .split('/')
                        .pop()
                        ?.replace(/\.[a-z0-9]+$/i, '') || 'Impacto';
                }
                if (name.startsWith('shout:')) {
                    return 'Grito ' + (parseInt(name.split(':')[1], 10) + 1 || 1);
                }
                return name;
            })();

            debugState.sound = cleanName;
            refreshDebugPanel();
        }

        refreshDebugPanel();

        const bagControlElements = {
            mass: document.getElementById('bagMass'),
            massValue: document.getElementById('bagMassVal'),
            linearDamping: document.getElementById('bagLinearDamping'),
            linearDampingValue: document.getElementById('bagLinearDampingVal'),
            angularDamping: document.getElementById('bagAngularDamping'),
            angularDampingValue: document.getElementById('bagAngularDampingVal')
        };

        const punchControlElements = {
            leftMass: document.getElementById('leftHandMass'),
            leftMassValue: document.getElementById('leftHandMassVal'),
            rightMass: document.getElementById('rightHandMass'),
            rightMassValue: document.getElementById('rightHandMassVal'),
            leftArea: document.getElementById('leftHandArea'),
            leftAreaValue: document.getElementById('leftHandAreaVal'),
            rightArea: document.getElementById('rightHandArea'),
            rightAreaValue: document.getElementById('rightHandAreaVal')
        };

        function formatDampingValue(value) {
            return parseFloat(value).toFixed(2);
        }

        function syncBagControlsFromConfig() {
            if (!bagControlElements.mass) return;
            bagControlElements.mass.value = visualConfig.bag.mass;
            bagControlElements.massValue.textContent = `${visualConfig.bag.mass.toFixed(0)} kg`;
            bagControlElements.linearDamping.value = visualConfig.bag.linearDamping;
            bagControlElements.linearDampingValue.textContent = formatDampingValue(visualConfig.bag.linearDamping);
            bagControlElements.angularDamping.value = visualConfig.bag.angularDamping;
            bagControlElements.angularDampingValue.textContent = formatDampingValue(visualConfig.bag.angularDamping);
        }

        function formatAreaMultiplier(value) {
            return `${parseFloat(value).toFixed(2)}x`;
        }

        function syncPunchControlsFromConfig() {
            if (!punchControlElements.leftMass) return;

            punchControlElements.leftMass.value = punchConfig.left.effectiveMass;
            punchControlElements.leftMassValue.textContent = `${punchConfig.left.effectiveMass.toFixed(1)} kg`;
            punchControlElements.rightMass.value = punchConfig.right.effectiveMass;
            punchControlElements.rightMassValue.textContent = `${punchConfig.right.effectiveMass.toFixed(1)} kg`;

            punchControlElements.leftArea.value = punchConfig.left.contactArea;
            punchControlElements.leftAreaValue.textContent = formatAreaMultiplier(punchConfig.left.contactArea);
            punchControlElements.rightArea.value = punchConfig.right.contactArea;
            punchControlElements.rightAreaValue.textContent = formatAreaMultiplier(punchConfig.right.contactArea);
        }

        function applyBagControlsToConfig() {
            if (!bagControlElements.mass) return;
            visualConfig.bag.mass = parseFloat(bagControlElements.mass.value);
            visualConfig.bag.linearDamping = parseFloat(bagControlElements.linearDamping.value);
            visualConfig.bag.angularDamping = parseFloat(bagControlElements.angularDamping.value);
            syncBagControlsFromConfig();
            applyBagPhysicsToBody();
        }

        function applyPunchControlsToConfig() {
            if (!punchControlElements.leftMass) return;

            punchConfig.left.effectiveMass = parseFloat(punchControlElements.leftMass.value);
            punchConfig.right.effectiveMass = parseFloat(punchControlElements.rightMass.value);
            punchConfig.left.contactArea = parseFloat(punchControlElements.leftArea.value);
            punchConfig.right.contactArea = parseFloat(punchControlElements.rightArea.value);

            syncPunchControlsFromConfig();
        }

        function setupBagControls() {
            if (!bagControlElements.mass) return;
            syncBagControlsFromConfig();
            const handler = () => applyBagControlsToConfig();
            ['mass', 'linearDamping', 'angularDamping'].forEach(key => {
                const el = bagControlElements[key];
                if (el) {
                    el.addEventListener('input', handler);
                }
            });
        }

        function setupPunchControls() {
            if (!punchControlElements.leftMass) return;
            syncPunchControlsFromConfig();
            const handler = () => applyPunchControlsToConfig();
            ['leftMass', 'rightMass', 'leftArea', 'rightArea'].forEach(key => {
                const el = punchControlElements[key];
                if (el) {
                    el.addEventListener('input', handler);
                }
            });
        }

        function applyPresetBagSettings(name) {
            const preset = lightingPresets[name];
            if (!preset || !preset.bagPhysics) return;

            const { bagPhysics } = preset;
            if (typeof bagPhysics.mass === 'number') visualConfig.bag.mass = bagPhysics.mass;
            if (typeof bagPhysics.linearDamping === 'number') visualConfig.bag.linearDamping = bagPhysics.linearDamping;
            if (typeof bagPhysics.angularDamping === 'number') visualConfig.bag.angularDamping = bagPhysics.angularDamping;

            syncBagControlsFromConfig();
            applyBagPhysicsToBody();
        }

        // Head bob
        const baseTarget = new THREE.Vector3(-0.6, 1.7, 0);
        const targetBase = baseTarget.clone();

        // Modos de c√°mara
        const defaultCameraPosition = new THREE.Vector3(0, 1.75, 2.2);
        const thirdPersonCameraOffset = new THREE.Vector3(0.0, 1.35, -4.5);
        const thirdPersonTargetOffset = new THREE.Vector3(0.0, 0.15, -0.4);
        const povCameraOffset = new THREE.Vector3(0.0, 0.05, 0.12);
        const povTargetOffset = new THREE.Vector3(0.0, 0.02, 0.32);
        let thirdPersonActive = false;

        // Reutilizaci√≥n de vectores para deformaci√≥n
        const tempV = new THREE.Vector3();
        const tempDisp = new THREE.Vector3();

        function getSpriteTexture() {
            if (spriteTexture) return spriteTexture;
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,230,170,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            spriteTexture = new THREE.CanvasTexture(canvas);
            spriteTexture.needsUpdate = true;
            return spriteTexture;
        }

        function spawnUiSpark(clientX, clientY, strength = 0.4) {
            if (!scene || !camera) return;
            const ndc = new THREE.Vector3(
                (clientX / window.innerWidth) * 2 - 1,
                -(clientY / window.innerHeight) * 2 + 1,
                0.2
            );
            ndc.unproject(camera);
            const dir = ndc.sub(camera.position).normalize();
            const pos = camera.position.clone().add(dir.clone().multiplyScalar(1.2));
            const hue = 0.08 + Math.random() * 0.08;
            const sparkColor = new THREE.Color().setHSL(hue, 0.8, 0.62 + strength * 0.1);
            const mat = new THREE.SpriteMaterial({
                map: getSpriteTexture(),
                color: sparkColor,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(mat);
            sprite.position.copy(pos);
            sprite.scale.setScalar(0.25 + strength * 0.25);
            scene.add(sprite);
            uiSparks.push({
                sprite,
                life: 0.36,
                maxLife: 0.36,
                velocity: dir.multiplyScalar(0.6 * (0.65 + strength)).add(new THREE.Vector3(0, 0.2 + strength * 0.2, 0)),
                spin: (Math.random() - 0.5) * 6.5
            });
        }

        function updateUiSparks(dt) {
            if (!uiSparks.length) return;
            for (let i = uiSparks.length - 1; i >= 0; i--) {
                const s = uiSparks[i];
                s.life -= dt;
                if (s.life <= 0 || !s.sprite) {
                    if (s.sprite) scene.remove(s.sprite);
                    uiSparks.splice(i, 1);
                    continue;
                }
                const fade = Math.pow(s.life / (s.maxLife || 0.36), 1.5);
                s.sprite.material.opacity = fade;
                s.sprite.material.rotation += s.spin * dt;
                s.sprite.position.addScaledVector(s.velocity, dt);
                s.sprite.scale.multiplyScalar(1.0 + dt * 1.8);
            }
        }

        function createDustParticles() {
            if (!DUST_ENABLED) return;
            if (!scene) return;
            const count = 520;
            const positions = new Float32Array(count * 3);
            dustVelocities = new Array(count);
            dustOffsets = new Array(count);
            for (let i = 0; i < count; i++) {
                const idx = i * 3;
                positions[idx] = (Math.random() - 0.5) * 6.5;
                positions[idx + 1] = 0.08 + Math.random() * 1.4;
                positions[idx + 2] = (Math.random() - 0.5) * 6.5;
                dustVelocities[i] = 0.32 + Math.random() * 0.42;
                dustOffsets[i] = Math.random() * 50;
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                map: getSpriteTexture(),
                size: 0.05,
                color: 0xffffff,
                transparent: true,
                opacity: 0.25,
                depthWrite: false,
                sizeAttenuation: true,
                blending: THREE.NormalBlending
            });
            dustSystem = new THREE.Points(geometry, material);
            dustSystem.frustumCulled = false;
            scene.add(dustSystem);
        }

        function updateDust(elapsed, dt) {
            if (!DUST_ENABLED) return;
            if (!dustSystem || !dustSystem.geometry.attributes.position) return;
            if (dustSystem.material) {
                dustSystem.material.opacity = 0.22 + Math.sin(elapsed * 0.4) * 0.06;
            }
            const posAttr = dustSystem.geometry.attributes.position;
            for (let i = 0; i < posAttr.count; i++) {
                const idx = i * 3;
                let x = posAttr.array[idx];
                let y = posAttr.array[idx + 1];
                let z = posAttr.array[idx + 2];
                const sway = noiseGen ? (noiseGen.noise2D(elapsed * 0.12, dustOffsets[i]) * 0.5 + 0.5) : 0.5;
                const swirl = elapsed * 0.08 + dustOffsets[i] * 0.15;
                x += (sway - 0.5) * dt * 0.38 + Math.cos(swirl) * dt * 0.12;
                z += Math.sin(elapsed * 0.6 + dustOffsets[i]) * dt * 0.2 + Math.sin(swirl) * dt * 0.12;
                y += dustVelocities[i] * dt;
                if (y > 2.8) {
                    y = 0.05 + Math.random() * 0.4;
                    x = (Math.random() - 0.5) * 6.5;
                    z = (Math.random() - 0.5) * 6.5;
                }
                posAttr.array[idx] = x;
                posAttr.array[idx + 1] = y;
                posAttr.array[idx + 2] = z;
            }
            posAttr.needsUpdate = true;
        }

        // Shake de c√°mara
        let shakeTime = 0;
        const shakeDuration = 0.15;
        let shakeStrength = 0;
        const shakeOffset = new THREE.Vector3();

        // ============================
        //  TYSON + MEDIAPIPE (MOCAP)
        // ============================
        const MODEL_URL = 'modelos/Tyson.fbx';
        // Textura base del modelo de Tyson (corregimos la ruta inexistente)
        const TYSON_TEXTURE_URL = 'texturas/Tyson.jpeg';

        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('pose_canvas');
        const canvasCtx = canvasElement ? canvasElement.getContext('2d') : null;
        const webcamInfoLabel = document.querySelector('.webcam-label');
        const webcamToggleBtn = document.getElementById('webcamBtn');

        if (!ENABLE_MOCAP_BLEND) {
            if (videoElement) videoElement.style.display = 'none';
            if (canvasElement) canvasElement.style.display = 'none';
            if (webcamToggleBtn) webcamToggleBtn.style.display = 'none';
        }

        let poseInstance = null;
        let cameraMP = null;
        let capturing = false;
        let lastPoseLandmarks = null;
        let smoothedLandmarks = null;
        let mocapStarted = false;
        let mocapInitialRootPosition = null;
        let mocapInitialRootQuaternion = null;
        let mocapInitialHipsPosition = null;
        let mocapInitialHipsQuaternion = null;

        function updateWebcamUiState(active) {
            if (videoElement) videoElement.style.display = active ? 'block' : 'none';
            if (canvasElement) canvasElement.style.display = active ? 'block' : 'none';
            if (webcamToggleBtn) {
                webcamToggleBtn.textContent = active ? 'üì∑ Webcam ON' : 'üì∑ Webcam OFF';
            }
            if (webcamInfoLabel) {
                webcamInfoLabel.textContent = active
                    ? 'Webcam activa: seguimiento de pose en vivo'
                    : 'Webcam desactivada';
            }
        }

        const POSE_LM = {
            NOSE: 0,
            LEFT_EYE_INNER: 1,
            LEFT_EYE: 2,
            LEFT_EYE_OUTER: 3,
            RIGHT_EYE_INNER: 4,
            RIGHT_EYE: 5,
            RIGHT_EYE_OUTER: 6,
            LEFT_EAR: 7,
            RIGHT_EAR: 8,
            MOUTH_LEFT: 9,
            MOUTH_RIGHT: 10,
            LEFT_SHOULDER: 11,
            RIGHT_SHOULDER: 12,
            LEFT_ELBOW: 13,
            RIGHT_ELBOW: 14,
            LEFT_WRIST: 15,
            RIGHT_WRIST: 16,
            LEFT_PINKY: 17,
            RIGHT_PINKY: 18,
            LEFT_INDEX: 19,
            RIGHT_INDEX: 20,
            LEFT_THUMB: 21,
            RIGHT_THUMB: 22,
            LEFT_HIP: 23,
            RIGHT_HIP: 24,
            LEFT_KNEE: 25,
            RIGHT_KNEE: 26,
            LEFT_ANKLE: 27,
            RIGHT_ANKLE: 28,
            LEFT_HEEL: 29,
            RIGHT_HEEL: 30,
            LEFT_FOOT_INDEX: 31,
            RIGHT_FOOT_INDEX: 32,
        };

        function lerp(a, b, t) { return a + (b - a) * t; }

        function lerpLandmark(prev, curr, factor) {
            if (!prev) return curr;
            return {
                x: lerp(prev.x, curr.x, factor),
                y: lerp(prev.y, curr.y, factor),
                z: lerp(prev.z ?? 0, curr.z ?? 0, factor),
                visibility: lerp(prev.visibility ?? 1, curr.visibility ?? 1, factor),
            };
        }

        // Tyson 3D
        let tysonRoot = null;
        let skeleton = null;
        const bonesByName = {};
        const headBoneCandidates = ['HeadTop_End', 'Head', 'LeftEye', 'RightEye'];
        let headBone = null;
        let mixer = null;
        const tysonTexture = new THREE.TextureLoader().load(TYSON_TEXTURE_URL);
        tysonTexture.colorSpace = THREE.SRGBColorSpace;
        tysonTexture.flipY = false;

        const MODEL_FORWARD = new THREE.Vector3(0, 0, 1);
        const tysonFloorBox = new THREE.Box3();

        const tmpVecA = new THREE.Vector3();
        const tmpVecB = new THREE.Vector3();
        const tmpDir  = new THREE.Vector3();
        const tmpQuatA = new THREE.Quaternion();

        function lmToVec3(lm) {
            if (!lm) return null;
            const x = (lm.x - 0.5) * 2;
            const y = (lm.y - 0.5) * -2;
            const z = -(lm.z ?? 0) * 2;
            return new THREE.Vector3(x, y, z);
        }

        function getBone(name) {
            return (
                bonesByName[name] ||
                bonesByName[name.toLowerCase()] ||
                bonesByName['mixamorig' + name]
            );
        }

        function getHeadBone() {
            if (headBone && headBone.parent) return headBone;
            headBone = null;
            for (const candidate of headBoneCandidates) {
                const bone = getBone(candidate);
                if (bone) {
                    headBone = bone;
                    break;
                }
            }
            return headBone;
        }

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        const BIND = {};
        const BIND_PAIRS = [
            ['Hips',   'Spine'],
            ['Spine',  'Spine1'],
            ['Spine1', 'Spine2'],
            ['Spine2', 'Neck'],
            ['Neck',   'Head'],
            ['Head',   'HeadTop_End'],
            ['LeftShoulder',  'LeftArm'],
            ['RightShoulder', 'RightArm'],
            ['LeftArm',      'LeftForeArm'],
            ['LeftForeArm',  'LeftHand'],
            ['RightArm',     'RightForeArm'],
            ['RightForeArm', 'RightHand'],
            ['LeftUpLeg',   'LeftLeg'],
            ['LeftLeg',     'LeftFoot'],
            ['RightUpLeg',  'RightLeg'],
            ['RightLeg',    'RightFoot'],
        ];

        function captureBindInfo() {
            for (const k of Object.keys(BIND)) delete BIND[k];
            if (!tysonRoot) return;

            scene.updateMatrixWorld(true);

            for (const [aName, bName] of BIND_PAIRS) {
                const A = getBone(aName);
                const B = getBone(bName);
                if (!A || !B) continue;

                const aPos = new THREE.Vector3().setFromMatrixPosition(A.matrixWorld);
                const bPos = new THREE.Vector3().setFromMatrixPosition(B.matrixWorld);

                const dirWorld = bPos.clone().sub(aPos).normalize();
                const rotWorld = new THREE.Quaternion().setFromRotationMatrix(
                    new THREE.Matrix4().extractRotation(A.matrixWorld)
                );
                BIND[aName] = { dir: dirWorld, wq: rotWorld };
            }
        }

        function worldQuatToLocal(bone, targetWorldQuat) {
            const parentWorld = bone.parent
                ? bone.parent.getWorldQuaternion(new THREE.Quaternion())
                : new THREE.Quaternion();
            const parentWorldInv = parentWorld.clone().invert();
            return parentWorldInv.multiply(targetWorldQuat);
        }

        function orientBoneFromDirection(boneName, dirWorld, slerp = 0.35) {
            const bone = getBone(boneName);
            if (!skeleton || !bone || !dirWorld) return;

            const info = BIND[boneName];
            if (!info) return;

            const targetDir = dirWorld.clone().normalize();
            if (targetDir.lengthSq() < 1e-6) return;

            const qDelta = new THREE.Quaternion().setFromUnitVectors(info.dir, targetDir);
            const targetWorld = info.wq.clone().premultiply(qDelta);
            const targetLocal = worldQuatToLocal(bone, targetWorld);

            bone.quaternion.slerp(targetLocal, slerp);
        }

        function orientBoneFromLandmarks(boneName, lmStartIdx, lmEndIdx, slerp = 0.35) {
            const bone = getBone(boneName);
            if (!skeleton || !bone || !smoothedLandmarks) return;

            const lmStart = smoothedLandmarks[lmStartIdx];
            const lmEnd   = smoothedLandmarks[lmEndIdx];
            if (!lmStart || !lmEnd) return;
            if ((lmStart.visibility ?? 0) < 0.4 || (lmEnd.visibility ?? 0) < 0.4) return;

            const info = BIND[boneName];
            if (!info) return;

            const vStart = lmToVec3(lmStart);
            const vEnd   = lmToVec3(lmEnd);
            const dir    = vEnd.clone().sub(vStart).normalize();
            if (dir.lengthSq() < 1e-6) return;

            const qDelta = new THREE.Quaternion().setFromUnitVectors(info.dir, dir);
            const targetWorld = info.wq.clone().premultiply(qDelta);
            const targetLocal = worldQuatToLocal(bone, targetWorld);

            bone.quaternion.slerp(targetLocal, slerp);
        }

        function captureMocapInitialPose() {
            mocapInitialRootPosition = null;
            mocapInitialRootQuaternion = null;
            mocapInitialHipsPosition = null;
            mocapInitialHipsQuaternion = null;

            if (!tysonRoot) return;

            tysonRoot.updateMatrixWorld(true);
            mocapInitialRootPosition = tysonRoot.position.clone();
            mocapInitialRootQuaternion = tysonRoot.quaternion.clone();

            const hips = getBone('Hips') || getBone('hips');
            if (hips) {
                hips.updateMatrixWorld(true);
                mocapInitialHipsPosition = hips.position.clone();
                mocapInitialHipsQuaternion = hips.getWorldQuaternion(new THREE.Quaternion());
            }
        }

        function updateModelFromPose(landmarks) {
            if (!ENABLE_MOCAP_BLEND) return;
            if (!landmarks || !skeleton) return;

            const lmLS   = landmarks[POSE_LM.LEFT_SHOULDER];
            const lmRS   = landmarks[POSE_LM.RIGHT_SHOULDER];
            const lmLH   = landmarks[POSE_LM.LEFT_HIP];
            const lmRH   = landmarks[POSE_LM.RIGHT_HIP];
            const lmNose = landmarks[POSE_LM.NOSE];

            const hips = getBone('Hips') || getBone('hips');

            if (hips && lmLS && lmRS && lmLH && lmRH) {
                const vLS = lmToVec3(lmLS);
                const vRS = lmToVec3(lmRS);
                const vLH = lmToVec3(lmLH);
                const vRH = lmToVec3(lmRH);

                const vShoulderMid = tmpVecA.copy(vLS).add(vRS).multiplyScalar(0.5);
                const vHipMid      = tmpVecB.copy(vLH).add(vRH).multiplyScalar(0.5);

                const torsoDir = tmpDir.copy(vShoulderMid).sub(vHipMid).normalize();

                const infoHips = BIND['Hips'];
                if (infoHips) {
                    const qDelta = new THREE.Quaternion().setFromUnitVectors(infoHips.dir, torsoDir);
                    const hipsWorldReference = (mocapInitialHipsQuaternion || infoHips.wq).clone();
                    const targetWorld = hipsWorldReference.premultiply(qDelta);
                    const targetLocal = worldQuatToLocal(hips, targetWorld);
                    hips.quaternion.slerp(targetLocal, 0.25);
                }

                const hipsReferencePosition = mocapInitialHipsPosition
                    ? mocapInitialHipsPosition
                    : (mocapInitialRootPosition || tysonRoot?.position || tysonBasePosition);

                hips.position.lerp(
                    new THREE.Vector3(
                        hipsReferencePosition.x,
                        vHipMid.y * 0.4 + 1.0,
                        hipsReferencePosition.z
                    ),
                    0.15
                );

                orientBoneFromDirection('Spine',  torsoDir, 0.35);
                orientBoneFromDirection('Spine1', torsoDir, 0.35);
                orientBoneFromDirection('Spine2', torsoDir, 0.35);

                if (lmNose) {
                    const vNose   = lmToVec3(lmNose);
                    const headDir = vNose.clone().sub(vShoulderMid).normalize();
                    orientBoneFromDirection('Neck', headDir, 0.45);
                    orientBoneFromDirection('Head', headDir, 0.55);
                }
            }

            // Brazos
            orientBoneFromLandmarks('LeftArm',     POSE_LM.LEFT_SHOULDER,  POSE_LM.LEFT_ELBOW);
            orientBoneFromLandmarks('LeftForeArm', POSE_LM.LEFT_ELBOW,     POSE_LM.LEFT_WRIST);
            orientBoneFromLandmarks('RightArm',    POSE_LM.RIGHT_SHOULDER, POSE_LM.RIGHT_ELBOW);
            orientBoneFromLandmarks('RightForeArm',POSE_LM.RIGHT_ELBOW,    POSE_LM.RIGHT_WRIST);

            // Piernas
            orientBoneFromLandmarks('LeftUpLeg',   POSE_LM.LEFT_HIP,       POSE_LM.LEFT_KNEE);
            orientBoneFromLandmarks('LeftLeg',     POSE_LM.LEFT_KNEE,      POSE_LM.LEFT_ANKLE);
            orientBoneFromLandmarks('RightUpLeg',  POSE_LM.RIGHT_HIP,      POSE_LM.RIGHT_KNEE);
            orientBoneFromLandmarks('RightLeg',    POSE_LM.RIGHT_KNEE,     POSE_LM.RIGHT_ANKLE);
        }

        function orientTysonTowardBag(force = false) {
            if (!tysonRoot || !bagMesh) return;

            tmpVecA.copy(bagMesh.position).sub(tysonRoot.position);
            tmpVecA.y = 0;

            if (tmpVecA.lengthSq() < 1e-6) return;

            const targetQuat = tmpQuatA.setFromUnitVectors(
                MODEL_FORWARD,
                tmpVecA.normalize()
            );

            if (force) {
                tysonRoot.quaternion.copy(targetQuat);
            } else {
                const blend = currentAnimationCategory === 'attack' ? 0.35 : 0.15;
                tysonRoot.quaternion.slerp(targetQuat, blend);
            }
        }

        function resetTysonTargetToBase() {
            tysonTargetPosition.copy(tysonBasePosition);
        }

        function setTysonWalkTargetAroundBag() {
            const pivot = bagMesh ? bagMesh.position : tysonBasePosition;
            const minRadius = MIN_BAG_DISTANCE + 0.25;
            const radius = minRadius + Math.random() * 1.1;
            const angle = Math.random() * Math.PI * 2;
            const target = new THREE.Vector3(
                pivot.x + Math.cos(angle) * radius,
                0,
                pivot.z + Math.sin(angle) * radius
            );

            tysonTargetPosition.lerp(target, 0.7);
        }

        function enforceTysonDistanceToBag() {
            if (!tysonRoot || !bagMesh) return 0;

            const bagPos = bagMesh.position;
            const currentPos = tysonRoot.position;
            tmpVecA.copy(currentPos).sub(bagPos);

            let distance = tmpVecA.length();
            if (distance < MIN_BAG_DISTANCE) {
                const safePos = bagPos.clone().add(tmpVecA.normalize().multiplyScalar(MIN_BAG_DISTANCE));
                tysonTargetPosition.lerp(safePos, 0.6);
                distance = MIN_BAG_DISTANCE;
            }

            return distance;
        }

        function handleCategoryTransitions(category) {
            if (category === 'walk') {
                setTysonWalkTargetAroundBag();
            } else if (category === 'rest') {
                resetTysonTargetToBase();
            } else if (category === 'attack') {
                orientTysonTowardBag(true);
            }
        }

        function loadTysonModel() {
            const loader = new FBXLoader();
            loader.load(
                MODEL_URL,
                (asset) => {
                    tysonRoot = asset;

                    tysonRoot.traverse((obj) => {
                        if (obj.isMesh) {
                            obj.castShadow = true;
                            obj.frustumCulled = false;

                            const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
                            materials.forEach((mat) => {
                                if (!mat) return;
                                if (!mat.map) {
                                    mat.map = tysonTexture;
                                }
                                mat.needsUpdate = true;
                            });
                        }
                        if (obj.isSkinnedMesh) skeleton = obj.skeleton;
                        if (obj.isBone) {
                            bonesByName[obj.name] = obj;
                            const cleaned = obj.name
                                .replace(/^mixamorig[:_ ]?/i, '')
                                .replace(/^mixamorig/i, '');
                            if (cleaned && cleaned !== obj.name) {
                                bonesByName[cleaned] = obj;
                                bonesByName[cleaned.toLowerCase()] = obj;
                            }
                            bonesByName[obj.name.toLowerCase()] = obj;
                        }
                    });

                    const bbox = new THREE.Box3().setFromObject(tysonRoot);
                    const size = new THREE.Vector3();
                    const center = new THREE.Vector3();
                    bbox.getSize(size);
                    bbox.getCenter(center);

                    const targetHeight = 3.6;
                    const scale = targetHeight / size.y;
                    tysonRoot.scale.setScalar(scale);

                    bbox.setFromObject(tysonRoot);
                    bbox.getCenter(center);

                    tysonRoot.position.x += -center.x + BOXER_BASE_X;
                    tysonRoot.position.z += -center.z + BOXER_BASE_Z;
                    tysonRoot.position.y += -bbox.min.y;

                    orientTysonTowardBag(true);

                    scene.add(tysonRoot);
                    scene.updateMatrixWorld(true);
                    captureBindInfo();

                    mixer = new THREE.AnimationMixer(tysonRoot);
                    loadTysonAnimations();

                    console.log('Tyson cargado. Huesos:', Object.keys(bonesByName));
                },
                undefined,
                (err) => {
                    console.error('Error cargando Tyson:', err);
                }
            );
        }

        const BLOCKED_ANIMATION_SUBSTRINGS = [
            'animaciones/da√±o/',
            'animaciones/dano/',
            'animaciones/damage/'
        ];

        const BLOCKED_ANIMATION_NAMES = ['taking punch'];

        const ANIMATION_LIBRARY = [
            { file: 'animaciones/ataque/Boxing.fbx', loop: 'repeat', category: 'attack' },
            { file: 'animaciones/ataque/Lead Jab.fbx', loop: 'once', category: 'attack' },
            { file: 'animaciones/ataque/Hook.fbx', loop: 'once', category: 'attack' },
            { file: 'animaciones/ataque/Jab Cross.fbx', loop: 'once', category: 'attack' },
            { file: 'animaciones/ataque/Illegal Elbow Punch.fbx', loop: 'once', category: 'attack' },
            { file: 'animaciones/ataque/Punching Bag.fbx', loop: 'repeat', category: 'attack' },
            { file: 'animaciones/movimiento/Walking.fbx', loop: 'repeat', category: 'walk' },
            { file: 'animaciones/movimiento/Walk back.fbx', loop: 'repeat', category: 'walk' },
            { file: 'animaciones/descanso/Arm Stretching.fbx', loop: 'repeat', category: 'rest' },
            { file: 'animaciones/descanso/Action Idle To Fight Idle.fbx', loop: 'once', category: 'rest' },
            { file: 'animaciones/descanso/Pointing Forward.fbx', loop: 'once', category: 'rest' }
        ];

        const ANIMATION_RULES = {
            crossFade: { in: 0.2, out: 0.25 },
            autoDelayMs: () => 500 + Math.random() * 800,
            rest: {
                initialDelayMs: () => 2000 + Math.random() * 2500,
                cadenceMs: () => 6000 + Math.random() * 4500
            }
        };

        function sanitizeClipRootMotion(clip) {
            if (!clip || !Array.isArray(clip.tracks)) return clip;

            const filteredTracks = clip.tracks.filter((track) => {
                const name = track.name?.toLowerCase?.() || '';
                return !name.includes('hips.position');
            });

            if (filteredTracks.length === clip.tracks.length) return clip;

            const sanitized = clip.clone();
            sanitized.tracks = filteredTracks;
            sanitized.resetDuration();
            return sanitized;
        }

        function isAnimationAllowed(file = '') {
            return !BLOCKED_ANIMATION_SUBSTRINGS.some((pattern) => file.includes(pattern));
        }

        function getClipCategory(name = '') {
            if (typeof name !== 'string') return null;
            if (name.includes('animaciones/ataque/')) return 'attack';
            if (name.includes('animaciones/defensa/')) return 'defense';
            if (name.includes('animaciones/descanso/')) return 'rest';
            return null;
        }

        function extractImpactCueTimes(clip) {
            const times = [];
            clip.tracks.forEach((track) => {
                if (track.times && track.times.length) {
                    track.times.forEach((t) => times.push(t));
                }
            });

            times.sort((a, b) => a - b);
            const uniqueTimes = times.filter((t, i) => i === 0 || Math.abs(t - times[i - 1]) > 1e-3);
            const minWindow = clip.duration * 0.2;
            const maxWindow = clip.duration * 0.9;
            const filtered = uniqueTimes.filter((t) => t >= minWindow && t <= maxWindow);

            const spaced = [];
            filtered.forEach((t) => {
                if (spaced.every((p) => Math.abs(p - t) > 0.3)) spaced.push(t);
            });

            if (spaced.length === 0) {
                spaced.push(clip.duration * 0.6);
            } else if (spaced.length > 3) {
                spaced.length = 3;
            }

            return spaced;
        }

        class AnimationSoundDirector {
            constructor({ mixer }) {
                this.mixer = mixer;
                this.loader = new FBXLoader();
                this.actions = [];
                this.queue = [];
                this.activeAction = null;
                this.activeEntry = null;
                this.cues = [];
                this.restBreathing = false;
                this.actionTimeState = null;
                this.lastStuckWarning = { action: null, time: 0 };
            }

            async loadLibrary(definitions = ANIMATION_LIBRARY) {
                const allowed = definitions.filter(({ file }) => {
                    const ok = isAnimationAllowed(file);
                    if (!ok) console.warn('Animaci√≥n bloqueada por configuraci√≥n:', file);
                    return ok;
                });

                const tasks = allowed.map((def) => this.loadClip(def));
                await Promise.all(tasks);
                this.prepareQueue();
            }

            loadClip(definition) {
                return new Promise((resolve) => {
                    this.loader.load(
                        definition.file,
                        (anim) => {
                            if (anim.animations && anim.animations.length > 0 && this.mixer) {
                                const clip = sanitizeClipRootMotion(anim.animations[0]);
                                const clipId = (definition.file || clip.name || '').toLowerCase();
                                const isNameBlocked = BLOCKED_ANIMATION_NAMES.some((pattern) =>
                                    clipId.includes(pattern)
                                );

                                if (isNameBlocked) {
                                    console.warn('Animaci√≥n bloqueada por nombre:', definition.file);
                                    resolve();
                                    return;
                                }

                                const action = this.mixer.clipAction(clip);
                                const isLoop = definition.loop === 'repeat';
                                action.loop = isLoop ? THREE.LoopRepeat : THREE.LoopOnce;
                                action.clampWhenFinished = !isLoop;
                                action.enabled = true;
                                this.actions.push({ ...definition, action });
                            }
                            resolve();
                        },
                        undefined,
                        (err) => {
                            console.error('No se pudo cargar animaci√≥n', definition.file, err);
                            resolve();
                        }
                    );
                });
            }

            startAutoPlaylist() {
                if (!AUTO_ANIMATION_ENABLED || this.actions.length === 0) return;
                initAudioContext();
                this.playNext();
            }

            prepareQueue() {
                this.queue = this.generateAttackCombo();
            }

            playNext() {
                if (!this.mixer || this.actions.length === 0) return;
                if (this.queue.length === 0) this.prepareQueue();
                const next = this.queue.shift();
                if (!next) return;

                this.stopAutoAdvance();
                this.clearAudioCues();
                this.stopRestBreathing();
                this.resetCueState();

                if (this.activeAction && this.activeAction !== next.action) {
                    this.activeAction.fadeOut(ANIMATION_RULES.crossFade.out);
                }

                next.action.reset();
                next.action.fadeIn(ANIMATION_RULES.crossFade.in);
                next.action.play();
                this.activeAction = next.action;
                this.activeEntry = next;
                this.resetCueState();
                currentAnimationEntry = next;
                currentAnimationCategory = next.category || getClipCategory(next.name);

                updateDebugAnimation(next);
                handleCategoryTransitions(currentAnimationCategory);
                this.handleAudioFor(next);
                this.scheduleAutoAdvance(next);
            }

            generateAttackCombo() {
                const attacks = this.actions.filter(({ category }) => category === 'attack');
                const restPool = this.actions.filter(({ category }) => category === 'rest');
                const walks = this.actions.filter(({ category }) => category === 'walk');

                if (!attacks.length) return [];

                const desiredHits = [3, 4, 5, 6][Math.floor(Math.random() * 4)];
                const sequence = [];
                let lastAttack = null;

                for (let i = 0; i < desiredHits; i++) {
                    const attackPool = attacks.filter((entry) => entry !== lastAttack);
                    const attack = attackPool[Math.floor(Math.random() * attackPool.length)] || attacks[0];
                    sequence.push(attack);
                    lastAttack = attack;

                    const shouldWalk = i < desiredHits - 1 && walks.length > 0 && Math.random() > 0.4;
                    if (shouldWalk) {
                        const walk = walks[Math.floor(Math.random() * walks.length)];
                        sequence.push(walk);
                    }
                }

                if (walks.length && Math.random() > 0.65) {
                    sequence.push(walks[Math.floor(Math.random() * walks.length)]);
                }

                if (restPool.length) {
                    const rest = restPool[Math.floor(Math.random() * restPool.length)];
                    sequence.push(rest);
                }

                return sequence;
            }

            handleAudioFor(entry) {
                const category = entry.category || getClipCategory(entry.name);
                this.handleRestBreathing(category);

                if (category === 'attack') {
                    this.scheduleAttackAudio(entry);
                } else if (category === 'defense') {
                    this.scheduleDefenseAudio(entry);
                }
            }

            scheduleAutoAdvance(entry) {
                const duration = entry.action.getClip()?.duration || 3;
                this.queueMixerCue('auto-advance', entry, duration + ANIMATION_RULES.autoDelayMs() / 1000, () => {
                    this.playNext();
                });
            }

            stopAutoAdvance() {
                this.removeCues('auto-advance');
            }

            cutCurrentWalk() {
                if (!this.activeEntry || this.activeEntry.category !== 'walk') return;

                this.stopAutoAdvance();
                this.clearAudioCues();
                if (this.activeAction) {
                    this.activeAction.fadeOut(0.12);
                }
                this.playNext();
            }

            cutWalkIfTooClose(distance) {
                if (!distance || distance > MIN_BAG_DISTANCE + 0.05) return;
                this.cutCurrentWalk();
            }

            scheduleAttackAudio(entry) {
                const clip = entry.action?.getClip?.();
                if (!clip || !(typeof entry.name === 'string' && entry.name.includes('animaciones/ataque/'))) return;

                const cueTimes = extractImpactCueTimes(clip);
                const shoutCueIndex = Math.random() > 0.4 ? Math.floor(Math.random() * cueTimes.length) : -1;

                cueTimes.forEach((timeSec, idx) => {
                    this.queueAudioCue(entry, timeSec, () => {
                        if (!audioInitialized) return;
                        playImpactSound(visualConfig.bag.punchForce);
                        if (idx === shoutCueIndex) playShout();
                    }, { repeatEachLoop: true });
                });
            }

            scheduleDefenseAudio(entry) {
                const clip = entry.action?.getClip?.();
                if (!clip) return;

                const cueTimes = extractImpactCueTimes(clip);
                const pickTime = cueTimes.length ? cueTimes[0] : clip.duration * 0.45;

                this.queueAudioCue(entry, pickTime, () => {
                    if (!audioInitialized) return;
                    playImpactSound(visualConfig.bag.punchForce * 0.6);
                    if (Math.random() > 0.6) playBreath();
                }, { repeatEachLoop: true });
            }

            handleRestBreathing(category) {
                if (category === 'rest') {
                    this.restBreathing = true;
                    this.scheduleRestBreath(this.activeEntry, ANIMATION_RULES.rest.initialDelayMs());
                } else {
                    this.stopRestBreathing();
                }
            }

            scheduleRestBreath(entry, delayMs) {
                if (!this.restBreathing) return;
                this.removeCues('rest-breath');
                this.queueActionCue('rest-breath', entry, delayMs / 1000, () => {
                    if (!this.restBreathing) return;
                    if (audioInitialized) playBreath();
                    this.scheduleRestBreath(entry, ANIMATION_RULES.rest.cadenceMs());
                });
            }

            stopRestBreathing() {
                this.restBreathing = false;
                this.removeCues('rest-breath');
            }

            queueAudioCue(entry, timeSec, cb, options = {}) {
                this.queueActionCue('audio', entry, timeSec, cb, options);
            }

            clearAudioCues() {
                this.removeCues('audio');
            }

            queueActionCue(tag, entry, clipTime, cb, { repeatEachLoop = false } = {}) {
                if (!this.mixer || !entry?.action || entry.action !== this.activeAction) return;
                const clipDuration = entry.action.getClip?.()?.duration || 0;
                const requiredLoop = clipDuration > 0 ? Math.floor(clipTime / clipDuration) : 0;
                const normalizedTime = clipDuration > 0 ? clipTime % clipDuration : clipTime;
                this.cues.push({
                    tag,
                    action: entry.action,
                    mode: 'action',
                    targetTime: normalizedTime,
                    requiredLoop,
                    repeatEachLoop,
                    lastLoopFired: requiredLoop - 1,
                    callback: () => {
                        if (this.activeEntry !== entry) return;
                        cb();
                    }
                });
            }

            queueMixerCue(tag, entry, delaySeconds, cb) {
                if (!this.mixer || !entry?.action || entry.action !== this.activeAction) return;
                this.cues.push({
                    tag,
                    action: entry.action,
                    mode: 'mixer',
                    targetTime: this.mixer.time + delaySeconds,
                    callback: () => {
                        if (this.activeEntry !== entry) return;
                        cb();
                    }
                });
            }

            removeCues(tag = null) {
                if (tag === null) {
                    this.cues = [];
                    return;
                }
                this.cues = this.cues.filter((cue) => cue.tag !== tag);
            }

            resetCueState() {
                this.removeCues();
                if (this.activeAction) {
                    this.actionTimeState = {
                        action: this.activeAction,
                        time: this.activeAction.time,
                        prevTime: this.activeAction.time,
                        loop: 0
                    };
                } else {
                    this.actionTimeState = null;
                }
            }

            processActionTime() {
                if (!this.activeAction) {
                    this.actionTimeState = null;
                    return;
                }

                const currentTime = this.activeAction.time;
                if (!this.actionTimeState || this.actionTimeState.action !== this.activeAction) {
                    this.actionTimeState = { action: this.activeAction, time: currentTime, prevTime: currentTime, loop: 0 };
                    return;
                }

                const prevTime = this.actionTimeState.time;
                const looped = currentTime + 1e-4 < prevTime;
                const nextLoop = looped ? this.actionTimeState.loop + 1 : this.actionTimeState.loop;
                this.actionTimeState = { action: this.activeAction, time: currentTime, prevTime, loop: nextLoop };
            }

            processCues() {
                if (!this.mixer || !this.activeAction || !this.actionTimeState) {
                    this.removeCues();
                    return;
                }

                const mixerTime = this.mixer.time;
                const { time, prevTime, loop } = this.actionTimeState;

                this.cues = this.cues.filter((cue) => {
                    if (cue.action !== this.activeAction) return false;

                    if (cue.mode === 'mixer') {
                        if (mixerTime >= cue.targetTime) {
                            cue.callback();
                            return false;
                        }
                        return true;
                    }

                    const loopedBack = time + 1e-4 < prevTime;
                    const isOnEligibleLoop = loop >= (cue.requiredLoop ?? 0);
                    const crossed =
                        isOnEligibleLoop &&
                        ((time >= cue.targetTime && prevTime < cue.targetTime) ||
                            (loop > cue.lastLoopFired && time >= cue.targetTime));

                    if (isOnEligibleLoop && (crossed || (loopedBack && time >= cue.targetTime))) {
                        cue.lastLoopFired = loop;
                        cue.callback();
                        if (cue.repeatEachLoop) {
                            return true;
                        }
                        return false;
                    }

                    return true;
                });
            }

            update() {
                this.processActionTime();
                this.processCues();
                this.ensureNotStuck();
            }

            ensureNotStuck() {
                if (!AUTO_ANIMATION_ENABLED || !this.activeAction || !this.activeEntry) return;

                const isRunning = this.activeAction.isRunning?.() !== false;
                if (isRunning) return;

                const clip = this.activeAction.getClip?.();
                const duration = clip?.duration ?? 0;
                const hasDuration = duration > 0;
                const nearEnd = hasDuration && this.activeAction.time >= duration - 1e-3;

                if (!hasDuration || nearEnd) {
                    const now = performance.now?.() || Date.now();
                    const sameAction = this.lastStuckWarning.action === this.activeAction;
                    const elapsed = now - this.lastStuckWarning.time;

                    if (!sameAction || elapsed > 1500) {
                        console.warn('Detecci√≥n de animaci√≥n trabada, saltando a la siguiente.');
                        this.lastStuckWarning = { action: this.activeAction, time: now };
                    }

                    this.playNext();
                }
            }
        }

        function loadTysonAnimations() {
            if (!tysonRoot) return;

            animationDirector = new AnimationSoundDirector({ mixer });
            animationDirector.loadLibrary().then(() => {
                animationDirector.startAutoPlaylist();
            });
        }

        function keepTysonFeetOnFloor() {
            if (!tysonRoot) return;
            tysonRoot.updateMatrixWorld(true);

            // Usar solo los huesos de los pies para evitar que las manos
            // (cuando golpean hacia abajo) eleven todo el modelo al
            // calcular el contacto con el suelo.
            const footBones = [
                'LeftFoot', 'RightFoot',
                'LeftToeBase', 'RightToeBase',
                'LeftToe_End', 'RightToe_End'
            ];

            let minFootY = Infinity;
            footBones.forEach((name) => {
                const bone = getBone(name);
                if (!bone) return;
                const pos = new THREE.Vector3().setFromMatrixPosition(bone.matrixWorld);
                minFootY = Math.min(minFootY, pos.y);
            });

            if (!isFinite(minFootY)) {
                // Fallback: usar la bounding box completa si no se
                // localizaron los huesos esperados.
                tysonFloorBox.setFromObject(tysonRoot);
                minFootY = tysonFloorBox.min.y;
            }

            const correction = -minFootY;

            if (Math.abs(correction) > 1e-4) {
                tysonRoot.position.y += correction;
            }

            // Evitar que el root se desplace hacia adelante entre animaciones
            tysonRoot.position.x = lerp(tysonRoot.position.x, tysonTargetPosition.x, 0.25);
            tysonRoot.position.z = lerp(tysonRoot.position.z, tysonTargetPosition.z, 0.25);
            tysonRoot.updateMatrixWorld(true);
        }

        // --- MediaPipe Pose ---
        function resizeCanvasToVideo() {
            if (!videoElement || !canvasElement) return;
            const rect = videoElement.getBoundingClientRect();
            if (!rect.width || !rect.height) return;
            canvasElement.width = rect.width * window.devicePixelRatio;
            canvasElement.height = rect.height * window.devicePixelRatio;
            canvasElement.style.width = rect.width + 'px';
            canvasElement.style.height = rect.height + 'px';
        }

        if (videoElement) {
            videoElement.onloadedmetadata = () => resizeCanvasToVideo();
            window.addEventListener('resize', () => {
                if (videoElement.videoWidth > 0) resizeCanvasToVideo();
            });
        }

        function onResultsPose(results) {
            if (!ENABLE_MOCAP_BLEND) return;
            if (canvasCtx && canvasElement) {
                canvasCtx.save();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

                const width = canvasElement.width;
                const height = canvasElement.height;

                if (results.image) {
                    canvasCtx.drawImage(results.image, 0, 0, width, height);
                }

                if (results.poseLandmarks) {
                    const landmarks = results.poseLandmarks;

                    smoothedLandmarks = landmarks.map((lm, i) => {
                        const prev = lastPoseLandmarks ? lastPoseLandmarks[i] : null;
                        return lerpLandmark(prev, lm, 0.4);
                    });
                    lastPoseLandmarks = smoothedLandmarks;

                    // Si quer√©s ver skeleton, descomenta:
                    // window.drawConnectors(canvasCtx, smoothedLandmarks, window.POSE_CONNECTIONS, {
                    //     color: '#22c55e', lineWidth: 2,
                    // });
                    // window.drawLandmarks(canvasCtx, smoothedLandmarks, {
                    //     color: '#60a5fa', lineWidth: 1, radius: 2,
                    // });

                    updateModelFromPose(smoothedLandmarks);
                }

                canvasCtx.restore();
            } else if (results.poseLandmarks) {
                const landmarks = results.poseLandmarks;
                smoothedLandmarks = landmarks.map((lm, i) => {
                    const prev = lastPoseLandmarks ? lastPoseLandmarks[i] : null;
                    return lerpLandmark(prev, lm, 0.4);
                });
                lastPoseLandmarks = smoothedLandmarks;
                updateModelFromPose(smoothedLandmarks);
            }
        }

        function initPose() {
            const Pose = window.Pose;
            if (!Pose) {
                console.error('MediaPipe Pose no est√° disponible');
                return;
            }

            poseInstance = new Pose({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
            });
            poseInstance.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: false,
                smoothSegmentation: false,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5,
            });
            poseInstance.onResults(onResultsPose);
        }

        async function startCapture() {
            if (!videoElement || !canvasElement) return false;
            if (capturing) return true;

            if (!poseInstance) initPose();
            if (!poseInstance) return false;

            const constraints = {
                audio: false,
                video: {
                    width: { ideal: 960 },
                    height: { ideal: 540 },
                    frameRate: { ideal: 30 },
                },
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                await videoElement.play();

                capturing = true;
                captureMocapInitialPose();
                mocapStarted = true;
                updateWebcamUiState(true);
                resizeCanvasToVideo();

                const CameraMP = window.Camera;
                if (!CameraMP) {
                    console.error('MediaPipe Camera no est√° disponible');
                    stopCapture();
                    return false;
                }

                if (cameraMP) {
                    cameraMP.stop();
                    cameraMP = null;
                }

                cameraMP = new CameraMP(videoElement, {
                    onFrame: async () => {
                        if (!capturing) return;
                        await poseInstance.send({ image: videoElement });
                    },
                    width: videoElement.videoWidth,
                    height: videoElement.videoHeight,
                });
                cameraMP.start();
                return true;
            } catch (err) {
                console.error('Error al iniciar c√°mara:', err);
                capturing = false;
                updateWebcamUiState(false);
                return false;
            }
        }

        function stopCapture() {
            capturing = false;
            mocapStarted = false;
            mocapInitialRootPosition = null;
            mocapInitialRootQuaternion = null;
            mocapInitialHipsPosition = null;
            mocapInitialHipsQuaternion = null;

            if (cameraMP) {
                cameraMP.stop();
                cameraMP = null;
            }

            if (videoElement && videoElement.srcObject) {
                const tracks = videoElement.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            if (videoElement) {
                videoElement.pause();
            }

            if (poseInstance && typeof poseInstance.close === 'function') {
                poseInstance.close();
            }
            poseInstance = null;

            if (canvasCtx && canvasElement) {
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            }

            updateWebcamUiState(false);
        }

        function setupMocap() {
            if (!videoElement || !webcamToggleBtn) return;

            updateWebcamUiState(false);

            const toggleWebcam = async () => {
                if (capturing) {
                    stopCapture();
                } else {
                    const started = await startCapture();
                    if (!started) {
                        stopCapture();
                    }
                }
            };

            webcamToggleBtn.addEventListener('click', toggleWebcam);
        }

        // Seguimiento de manos para detectar golpes
        let lastLeftHandPos = null;
        let lastRightHandPos = null;
        let leftPunchCooldown = 0;
        let rightPunchCooldown = 0;

        function getBagPointVelocity(contactPoint) {
            const relativePoint = new CANNON.Vec3();
            contactPoint.vsub(bagBody.position, relativePoint);

            const angularComponent = new CANNON.Vec3();
            bagBody.angularVelocity.cross(relativePoint, angularComponent);

            const bagPointVelocity = new CANNON.Vec3();
            bagBody.velocity.vadd(angularComponent, bagPointVelocity);
            return bagPointVelocity;
        }

        function computeBagNormal(contactPoint) {
            const normal = new CANNON.Vec3();
            contactPoint.vsub(bagBody.position, normal);
            const length = normal.length();
            if (length > 1e-6) {
                normal.scale(1 / length, normal);
            } else {
                normal.set(0, 1, 0);
            }
            return normal;
        }

        function computePunchImpulse(handVelocityVec3, contactPointVec3, isLeft) {
            if (!bagBody) return null;

            const handVelocity = new CANNON.Vec3(handVelocityVec3.x, handVelocityVec3.y, handVelocityVec3.z);
            const contactPoint = new CANNON.Vec3(contactPointVec3.x, contactPointVec3.y, contactPointVec3.z);
            const normal = computeBagNormal(contactPoint);
            const bagPointVelocity = getBagPointVelocity(contactPoint);

            const relativeVelocity = new CANNON.Vec3();
            handVelocity.vsub(bagPointVelocity, relativeVelocity);

            const normalSpeed = relativeVelocity.dot(normal);
            if (normalSpeed <= 0) return null;

            const handSettings = isLeft ? punchConfig.left : punchConfig.right;
            const impulseMagnitude = normalSpeed * handSettings.effectiveMass * handSettings.contactArea;
            const impulse = normal.scale(impulseMagnitude, new CANNON.Vec3());

            return { impulse, contactPoint, normal, normalSpeed, impulseMagnitude };
        }

        function updatePosePunch(dt) {
            if (!skeleton || !bagBody || !bagMesh) return;

            leftPunchCooldown = Math.max(0, leftPunchCooldown - dt);
            rightPunchCooldown = Math.max(0, rightPunchCooldown - dt);

            const bagPos = bagMesh.position.clone();

            const checkHand = (boneName, lastPos, isLeft) => {
                const bone = getBone(boneName);
                if (!bone) return lastPos;

                const worldPos = new THREE.Vector3().setFromMatrixPosition(bone.matrixWorld);

                if (lastPos) {
                    const vel = worldPos.clone().sub(lastPos).divideScalar(Math.max(dt, 0.0001));
                    const speed = vel.length();

                    const distance = worldPos.distanceTo(bagPos);
                    const dirToBag = bagPos.clone().sub(worldPos).normalize();
                    const forwardFactor = vel.dot(dirToBag);

                    const cooldown = isLeft ? leftPunchCooldown : rightPunchCooldown;

                    if (speed > 1.5 && forwardFactor > 0.4 && distance < 0.8 && cooldown <= 0) {
                        const punchData = computePunchImpulse(vel, worldPos, isLeft);
                        if (punchData) {
                            bagBody.applyImpulse(punchData.impulse, punchData.contactPoint);
                            const normalDir = new THREE.Vector3(punchData.normal.x, punchData.normal.y, punchData.normal.z);
                            deform(worldPos, normalDir, dt);

                            if (!audioInitialized) initAudioContext();
                            const normalizedImpact = THREE.MathUtils.clamp(
                                punchData.impulseMagnitude / visualConfig.bag.punchForce,
                                0.15,
                                1.5
                            );
                            const impactForce = visualConfig.bag.punchForce * normalizedImpact;
                            playImpactSound(impactForce);
                            playHeavyImpactSound(impactForce);

                            registerPunch(Math.min(1, punchData.normalSpeed / 6));

                            if (isLeft) leftPunchCooldown = 0.25;
                            else rightPunchCooldown = 0.25;
                        }
                    }
                }

                return worldPos;
            };

            lastLeftHandPos  = checkHand('LeftHand',  lastLeftHandPos,  true);
            lastRightHandPos = checkHand('RightHand', lastRightHandPos, false);
        }

        // ============================
        //      ESCENA GYM + SACO
        // ============================
        init();
        animate();

        function init() {
            const container = document.getElementById('canvas-container');
            noiseGen = new SimplexNoise();

            applyPresetBagSettings(currentPreset);
            setupBagControls();
            setupPunchControls();

            initScene();
            initRenderer(container);
            initCamera();
            initControls();
            initPostProcessing();
            
            initWorld(); 

            const textures = generateProceduralTextures();
            generateEnvMap(); 

            initLights();
            createVolumetricLight();
            
            const envProps = createEnvironment(textures);
            initPhysics(textures, envProps);

            setupMuteButton();
            setupPresetButton();
            setupViewButton();
            setupUiFxEvents();

            // Tyson + webcam
            loadTysonModel();
            if (ENABLE_MOCAP_BLEND) {
                setupMocap();
            }

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown, { passive: true });
        }

        function initScene() {
            scene = new THREE.Scene();
            const preset = lightingPresets[currentPreset];
            scene.background = new THREE.Color(preset.background);
            baseFogDensity = preset.fogDensity;
            scene.fog = new THREE.FogExp2(preset.fogColor, baseFogDensity);
        }

        function initRenderer(container) {
            renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.0 : 1.5));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = !isMobile;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            container.appendChild(renderer.domElement);
        }

        function initPostProcessing() {
            if (isMobile) {
                composer = null;
                bokehPass = null;
                return;
            }

            composer = new EffectComposer(renderer);
            
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            bokehPass = new BokehPass(scene, camera, {
                focus: 2.0,
                aperture: 0.00015,
                maxblur: 0.015,
                width: window.innerWidth,
                height: window.innerHeight
            });
            composer.addPass(bokehPass);

            const outputPass = new OutputPass();
            composer.addPass(outputPass);

            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function generateEnvMap() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            const envScene = new THREE.Scene();
            envScene.background = new THREE.Color(0x111111);
            const l1 = new THREE.PointLight(0xffffff, 10); l1.position.set(5, 5, 5); envScene.add(l1);
            const l2 = new THREE.PointLight(0x4444ff, 5); l2.position.set(-5, 2, -5); envScene.add(l2);
            const envRT = pmremGenerator.fromScene(envScene);
            scene.environment = envRT.texture;
            envRT.texture.needsUpdate = true;
            envRT.dispose();
            pmremGenerator.dispose();
        }

        function initCamera() {
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.copy(defaultCameraPosition);
        }

        function initControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.target.copy(targetBase);
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.minDistance = 0.6;
            controls.maxDistance = 8.0;
            controls.enablePan = false;
        }

        // --- TEXTURAS PROCEDURALES ---
        function generateProceduralTextures() {
            const width = 1024;
            const createTex = (drawFn) => {
                const cvs = document.createElement('canvas');
                cvs.width = cvs.height = width;
                const ctx = cvs.getContext('2d');
                drawFn(ctx, width);
                const t = new THREE.CanvasTexture(cvs);
                t.wrapS = t.wrapT = THREE.RepeatWrapping;
                return t;
            };

            const leatherColor = createTex((ctx, w) => {
                const img = ctx.createImageData(w, w);
                for(let i=0; i<img.data.length; i+=4) {
                    const x = (i/4)%w, y=Math.floor((i/4)/w);
                    const n = noiseGen.noise2D(x*0.02, y*0.02)*0.5+0.5;
                    const grain = noiseGen.noise2D(x*0.2, y*0.2)*0.1;
                    let val = 60 + n*30 + grain*10; 
                    const vFactor = y/w; 
                    if(vFactor > 0.7) val *= (1.0 - (vFactor-0.7)*1.5); 
                    const dx = x - w/2; const dy = y - w/2;
                    const d = Math.sqrt(dx*dx + dy*dy) / (w/2);
                    if(d < 0.6) val += (1.0-d)*25;
                    if(vFactor < 0.05 || vFactor > 0.95) val *= 0.6;
                    img.data[i]=val; img.data[i+1]=val*0.7; img.data[i+2]=val*0.5; img.data[i+3]=255;
                }
                ctx.putImageData(img,0,0);
                ctx.strokeStyle = '#221100'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(w*0.25, 0); ctx.lineTo(w*0.25, w); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(w*0.75, 0); ctx.lineTo(w*0.75, w); ctx.stroke();
                ctx.strokeStyle = '#aa8866'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(w*0.25-2, 0); ctx.lineTo(w*0.25-2, w); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(w*0.75+2, 0); ctx.lineTo(w*0.75+2, w); ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#332211'; ctx.fillRect(w*0.35, w*0.3, w*0.3, w*0.15);
                ctx.strokeStyle = '#664422'; ctx.lineWidth=2; ctx.strokeRect(w*0.35, w*0.3, w*0.3, w*0.15);
                ctx.fillStyle = '#ccaa88'; ctx.font = 'bold 80px Impact'; ctx.textAlign = 'center';
                ctx.fillText("TITAN", w*0.5, w*0.41);
            });

            const leatherNormal = createTex((ctx, w) => {
                const img = ctx.createImageData(w, w);
                for(let i=0; i<img.data.length; i+=4) {
                    const x = (i/4)%w, y=Math.floor((i/4)/w);
                    const scratch = Math.random() > 0.99 ? 1.0 : 0.0;
                    const r = 128 + (Math.random()-0.5)*10 + scratch*20;
                    const g = 128 + (Math.random()-0.5)*10;
                    img.data[i]=r; img.data[i+1]=g; img.data[i+2]=255; img.data[i+3]=255;
                }
                ctx.putImageData(img,0,0);
                ctx.fillStyle = 'rgba(128,128,255,1.0)';
                ctx.strokeStyle = '#a0a0ff'; ctx.lineWidth=4; ctx.strokeRect(w*0.35, w*0.3, w*0.3, w*0.15);
                ctx.fillStyle = '#c0c0ff'; ctx.font = 'bold 80px Impact'; ctx.textAlign = 'center';
                ctx.fillText("TITAN", w*0.5, w*0.41);
                ctx.strokeStyle = '#6060ff'; ctx.lineWidth = 6;
                ctx.beginPath(); ctx.moveTo(w*0.25, 0); ctx.lineTo(w*0.25, w); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(w*0.75, 0); ctx.lineTo(w*0.75, w); ctx.stroke();
            });

            const leatherRough = createTex((ctx, w) => {
                ctx.fillStyle = '#999999'; ctx.fillRect(0,0,w,w);
                const img = ctx.createImageData(w, w);
                for(let i=0; i<img.data.length; i+=4) {
                    const x = (i/4)%w, y=Math.floor((i/4)/w);
                    const n = noiseGen.noise2D(x*0.03, y*0.03);
                    const dx = x - w/2; const dy = y - w/2;
                    const d = Math.sqrt(dx*dx + dy*dy) / (w/2);
                    let val = 160 + n * 40; 
                    if(d < 0.5) val -= 60;
                    if(d < 0.7 && d > 0.5) val += 30;
                    if(Math.random() > 0.995) val = 255;
                    img.data[i]=val; img.data[i+1]=val; img.data[i+2]=val; img.data[i+3]=255;
                }
                ctx.putImageData(img,0,0);
                ctx.fillStyle = '#666666'; ctx.fillRect(w*0.35, w*0.3, w*0.3, w*0.15);
            });

            const floorColor = createTex((ctx, w) => {
                ctx.fillStyle = '#151515'; ctx.fillRect(0,0,w,w);
                for(let i=0; i<100; i++) {
                    const x = Math.random()*w; const y = Math.random()*w;
                    const r = Math.random()*50 + 20;
                    const g = ctx.createRadialGradient(x,y,0,x,y,r);
                    g.addColorStop(0, 'rgba(255,255,255,0.05)');
                    g.addColorStop(1, 'transparent');
                    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
                }
            });
            const floorRough = createTex((ctx, w) => {
                ctx.fillStyle = '#bbbbbb'; ctx.fillRect(0,0,w,w); 
                for(let i=0; i<30; i++){
                    const x = w/2 + (Math.random()-0.5)*300; 
                    const y = w/2 + (Math.random()-0.5)*300;
                    const r = Math.random()*40 + 10;
                    const g = ctx.createRadialGradient(x,y,0,x,y,r);
                    g.addColorStop(0, '#222222'); 
                    g.addColorStop(1, 'rgba(187,187,187,0)'); 
                    ctx.fillStyle = g; ctx.beginPath(); ctx.scale(1, 0.5 + Math.random()); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.setTransform(1,0,0,1,0,0);
                }
                for(let i=0; i<20; i++){
                    const x = Math.random()*w; const y = Math.random()*w;
                    const r = Math.random()*15;
                    ctx.fillStyle = '#ffffff'; 
                    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
                }
            });
            floorColor.repeat.set(4,4); floorRough.repeat.set(4,4);

            const wallMap = createTex((ctx, w) => {
                const img = ctx.createImageData(w, w);
                for(let i=0; i<img.data.length; i+=4) {
                    const x = (i/4)%w, y=Math.floor((i/4)/w);
                    const n = noiseGen.noise2D(x*0.01, y*0.05); 
                    const val = 40 + n*10;
                    img.data[i]=val; img.data[i+1]=val; img.data[i+2]=val+2; img.data[i+3]=255;
                }
                ctx.putImageData(img,0,0);
            });
            wallMap.repeat.set(2,1);

            const posterMap = createTex((ctx, w) => {
                ctx.fillStyle = '#eaddcf'; ctx.fillRect(0,0,w,w);
                ctx.font = 'bold 120px sans-serif';
                ctx.fillStyle = '#aa2222'; ctx.textAlign = 'center';
                ctx.fillText("FIGHT", w/2, w/3);
                ctx.fillStyle = '#111'; ctx.font = '80px sans-serif';
                ctx.fillText("CLUB", w/2, w/2);
                ctx.globalCompositeOperation = 'destination-out';
                for(let i=0; i<20; i++) {
                    const x = Math.random()*w; const y = Math.random()*w;
                    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.random()*100-50, y+Math.random()*100); ctx.stroke();
                }
            });

            const windowMap = createTex((ctx, w) => {
                const grad = ctx.createLinearGradient(0, 0, 0, w);
                grad.addColorStop(0, '#152238');
                grad.addColorStop(1, '#0c111b');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, w, w);

                ctx.strokeStyle = 'rgba(255,255,255,0.08)';
                ctx.lineWidth = 8;
                ctx.strokeRect(10, 10, w-20, w-20);

                ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                ctx.lineWidth = 12;
                ctx.beginPath();
                ctx.moveTo(w/2, 8); ctx.lineTo(w/2, w-8);
                ctx.moveTo(8, w/2); ctx.lineTo(w-8, w/2);
                ctx.stroke();
            });

            return { bag: {c: leatherColor, n: leatherNormal, r: leatherRough}, floor: {c: floorColor, r: floorRough}, wall: wallMap, poster: posterMap, window: windowMap };
        }

        // --- ESCENA Y PROPS ---
        function createEnvironment(tex) {
            const staticMat = new CANNON.Material('floor-wall');
            const ceilingMat = new CANNON.Material('ceiling');
            const wallMat = new THREE.MeshStandardMaterial({ 
                map: tex.wall, roughness: 0.9, color: 0x444444 
            });

            const floorGeo = new THREE.PlaneGeometry(12, 12);
            const floorMat = new THREE.MeshStandardMaterial({ 
                map: tex.floor.c, roughnessMap: tex.floor.r, metalness: 0.1, color: 0xaaaaaa
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            const floorBody = new CANNON.Body({ mass: 0, material: staticMat, shape: new CANNON.Plane() });
            floorBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
            world.addBody(floorBody);

            const wallH = 5;
            const wL = new THREE.Mesh(new THREE.PlaneGeometry(3, wallH), wallMat);
            wL.position.set(-3.9, wallH/2, -5); wL.receiveShadow=true; scene.add(wL);
            const wR = new THREE.Mesh(new THREE.PlaneGeometry(5, wallH), wallMat);
            wR.position.set(2.1, wallH/2, -5); wR.receiveShadow=true; scene.add(wR);
            const wT = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), wallMat);
            wT.position.set(-1.4, 4, -5); wT.receiveShadow=true; scene.add(wT);

            const posterMat = new THREE.MeshStandardMaterial({
                map: tex.poster,
                roughness: 0.82,
                metalness: 0.05,
                side: THREE.DoubleSide
            });

            const posterA = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.8), posterMat);
            posterA.position.set(-3.5, 2.1, -4.92);
            scene.add(posterA);

            const posterB = new THREE.Mesh(new THREE.PlaneGeometry(1.35, 1.35), posterMat);
            posterB.position.set(2.8, 1.6, -4.92);
            scene.add(posterB);

            const windowGroup = new THREE.Group();
            const windowPane = new THREE.Mesh(
                new THREE.PlaneGeometry(2.8, 1.4),
                new THREE.MeshStandardMaterial({
                    map: tex.window,
                    roughness: 0.35,
                    metalness: 0.08,
                    transparent: true,
                    opacity: 0.88,
                    emissive: new THREE.Color(0x1b2435),
                    emissiveIntensity: 0.6,
                    side: THREE.DoubleSide
                })
            );
            windowPane.position.z = 0.01;

            const windowGlow = new THREE.Mesh(
                new THREE.PlaneGeometry(3.2, 1.8),
                new THREE.MeshBasicMaterial({
                    color: 0x6da5ff,
                    transparent: true,
                    opacity: 0.18,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                })
            );
            windowGlow.renderOrder = 1;
            windowGroup.add(windowGlow);
            windowGroup.add(windowPane);
            windowGroup.position.set(-0.2, 2.3, -4.95);
            scene.add(windowGroup);

            doorLight = new THREE.RectAreaLight(0x4488ff, lightBases.door, 2, 3);
            doorLight.position.set(-1.4, 1.5, -5.2);
            doorLight.lookAt(-1.4, 1.5, 0);
            scene.add(doorLight);
            
            const godrayGeo = new THREE.PlaneGeometry(3.2, 4.8);
            const godrayMat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: new THREE.Color(0x6ca8ff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform vec3 uColor;
                    varying vec2 vUv;

                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
                    }

                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        float a = hash(i);
                        float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0));
                        float d = hash(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) +
                               (c - a) * u.y * (1.0 - u.x) +
                               (d - b) * u.x * u.y;
                    }

                    void main() {
                        float centeredX = vUv.x * 2.0 - 1.0;
                        float beam = smoothstep(0.0, 0.85, 1.0 - abs(centeredX));
                        float streaks = noise(vec2(vUv.y * 6.0, uTime * 0.4)) * 0.6;
                        float bands = smoothstep(0.25, 0.0, abs(centeredX * 2.0));
                        float fog = (1.0 - vUv.y);
                        float alpha = beam * fog;
                        alpha *= 0.18 + (streaks + bands) * 0.15;
                        alpha *= smoothstep(0.0, 0.15, vUv.y);
                        alpha *= smoothstep(1.0, 0.8, vUv.y);
                        if (alpha < 0.01) discard;
                        gl_FragColor = vec4(uColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            doorGodrayMesh = new THREE.Mesh(godrayGeo, godrayMat);
            doorGodrayMesh.position.set(-1.4, 2.2, -4.9);
            scene.add(doorGodrayMesh);

            const sideWall = new THREE.Mesh(new THREE.PlaneGeometry(12, wallH), wallMat);
            sideWall.rotation.y = Math.PI/2;
            sideWall.position.set(-6, wallH/2, 0);
            sideWall.receiveShadow = true;
            scene.add(sideWall);

            const posterGeo = new THREE.PlaneGeometry(1.2, 1.8);
            const posterMat = new THREE.MeshStandardMaterial({ map: tex.poster, roughness: 0.8 });
            const p1 = new THREE.Mesh(posterGeo, posterMat);
            p1.position.set(-5.95, 2.5, 1); p1.rotation.y = Math.PI/2; p1.rotation.z = -0.05;
            scene.add(p1);

            fanMesh = new THREE.Group();
            fanMesh.position.set(0, 4.2, 0);
            const motor = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.3), new THREE.MeshStandardMaterial({color:0x222222}));
            const bladeGeo = new THREE.BoxGeometry(2.5, 0.05, 0.3);
            const bladeMat = new THREE.MeshStandardMaterial({color:0x333333, metalness: 0.5, roughness: 0.6});
            for(let i=0; i<3; i++) {
                const blade = new THREE.Mesh(bladeGeo, bladeMat);
                blade.position.y = -0.1; blade.rotation.y = i * (Math.PI*2/3); blade.castShadow = true;
                fanMesh.add(blade);
            }
            fanMesh.add(motor);
            scene.add(fanMesh);

            const benchGroup = new THREE.Group();
            const legGeo = new THREE.BoxGeometry(0.1, 0.5, 0.4);
            const seatGeo = new THREE.BoxGeometry(1.5, 0.1, 0.5);
            const metal = new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.3});
            const leather = new THREE.MeshStandardMaterial({color: 0x222222, roughness: 0.6});
            const seat = new THREE.Mesh(seatGeo, leather); seat.position.y = 0.5; seat.castShadow=true;
            const l1 = new THREE.Mesh(legGeo, metal); l1.position.set(-0.6, 0.25, 0);
            const l2 = new THREE.Mesh(legGeo, metal); l2.position.set(0.6, 0.25, 0);
            benchGroup.add(seat, l1, l2);
            benchGroup.position.set(2.5, 0, 1.5); benchGroup.rotation.y = -0.5;
            scene.add(benchGroup);

            const dbGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3);
            const wGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.05);
            const dbMesh = new THREE.Group();
            dbMesh.add(new THREE.Mesh(dbGeo, metal));
            const w1 = new THREE.Mesh(wGeo, metal); w1.rotation.z=Math.PI/2; w1.position.x=-0.12;
            const w2 = new THREE.Mesh(wGeo, metal); w2.rotation.z=Math.PI/2; w2.position.x=0.12;
            dbMesh.add(w1, w2);
            dbMesh.position.set(2, 0.1, 2.5); dbMesh.rotation.y=Math.random(); dbMesh.castShadow=true;
            scene.add(dbMesh);

            const lockerGeo = new THREE.BoxGeometry(0.8, 2.2, 0.6);
            const lockerMat = new THREE.MeshStandardMaterial({ color: 0x556677, metalness: 0.6, roughness: 0.4, envMapIntensity: 1.0 });
            const locker = new THREE.Mesh(lockerGeo, lockerMat);
            locker.position.set(4, 1.1, -4); locker.rotation.y = -0.3; locker.castShadow = true; locker.receiveShadow = true;
            scene.add(locker);

            if (DUST_ENABLED) {
                createDustParticles();
            }

            gltfLoader.load(
                RING_MODEL_URL,
                (gltf) => {
                    const ring = gltf.scene || gltf;
                    ring.position.set(20.10, 0, 2.00);
                    ring.rotation.y = Math.PI / 2;
                    ring.scale.setScalar(0.2);
                    ring.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    scene.add(ring);
                },
                undefined,
                (err) => console.warn('No se pudo cargar el ring:', err)
            );

            const flWidth = 3.0;
            const flHeight = 0.35;
            const flY = 4.6;
            const flPositionsZ = [-2.5, 0.0, 2.5];
            for (let i = 0; i < flPositionsZ.length; i++) {
                const z = flPositionsZ[i];
                const fl = new THREE.RectAreaLight(0xf0f6ff, lightBases.fluorescent, flWidth, flHeight);
                fl.position.set(0, flY, z);
                fl.rotation.x = -Math.PI / 2;
                scene.add(fl);
                fluorescentLights.push(fl);

                const glow = new THREE.Mesh(
                    new THREE.PlaneGeometry(flWidth * 1.6, flHeight * 2.4),
                    new THREE.MeshBasicMaterial({
                        map: getSpriteTexture(),
                        color: 0xeef8ff,
                        transparent: true,
                        opacity: 0.45,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    })
                );
                glow.position.copy(fl.position);
                glow.rotation.x = fl.rotation.x;
                glow.renderOrder = 2;
                scene.add(glow);
                fluorescentGlowCards.push(glow);
            }

            createClock();
            return { staticMat, ceilingMat };
        }

        function createClock() {
            const clockGroup = new THREE.Group();
            const frame = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.05, 32), new THREE.MeshStandardMaterial({color:0x111}));
            frame.rotation.x = Math.PI/2;
            const face = new THREE.Mesh(new THREE.CircleGeometry(0.35, 32), new THREE.MeshBasicMaterial({color:0xeeeeee}));
            face.position.z = 0.03;
            const handMat = new THREE.MeshBasicMaterial({color:0x000});
            const secMat = new THREE.MeshBasicMaterial({color:0xaa0000});
            clockHandHour = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.25, 0.01), handMat);
            clockHandHour.position.z = 0.04; clockHandHour.geometry.translate(0, 0.1, 0);
            clockHandMin = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.32, 0.01), handMat);
            clockHandMin.position.z = 0.05; clockHandMin.geometry.translate(0, 0.15, 0);
            clockHandSec = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.32, 0.01), secMat);
            clockHandSec.position.z = 0.06; clockHandSec.geometry.translate(0, 0.1, 0);
            clockGroup.add(frame, face, clockHandHour, clockHandMin, clockHandSec);
            clockGroup.position.set(0, 3.5, -4.9);
            scene.add(clockGroup);
        }

        function initLights() {
            ambientLight = new THREE.HemisphereLight(0x222233, 0x000000, 0.52);
            scene.add(ambientLight);

            keyLight = new THREE.SpotLight(0xffaa77, lightBases.key);
            keyLight.position.set(0, 5.5, 0);
            keyLight.target.position.set(0, 1, 0);
            keyLight.angle = Math.PI * 0.38;
            keyLight.penumbra = 0.82;
            keyLight.distance = 16;
            keyLight.decay = 1.6;
            keyLight.castShadow = !isMobile;
            keyLight.shadow.mapSize.set(1024, 1024);
            keyLight.shadow.bias = -0.0001;
            scene.add(keyLight);
            scene.add(keyLight.target);

            fillLight = new THREE.PointLight(0x6c7cff, lightBases.fill);
            fillLight.position.set(3.2, 2.1, 3.2);
            scene.add(fillLight);

            ringLight = new THREE.PointLight(0xffdd88, lightBases.ring, 6, 2);
            ringLight.position.set(0, 3.6, 0.15);
            scene.add(ringLight);

            rimLight = new THREE.SpotLight(0x6688ff, lightBases.rim, 8, Math.PI / 4, 0.5, 1);
            rimLight.position.set(0, 2.0, -2.0);
            rimLight.target.position.set(0, 1.7, 0);
            rimLight.castShadow = false;
            scene.add(rimLight);
            scene.add(rimLight.target);

            const ringSpotSettings = [
                { pos: new THREE.Vector3(-3.8, 4.4, 2.2), target: new THREE.Vector3(0, 1.2, 0) },
                { pos: new THREE.Vector3(3.8, 4.4, 2.2), target: new THREE.Vector3(0, 1.2, 0) }
            ];

            ringSpotSettings.forEach((cfg, idx) => {
                const spot = new THREE.SpotLight(lightingPresets[currentPreset].ringSpotColor, lightBases.ringSpot, 18, Math.PI / 5.2, 0.72, 1.6);
                spot.position.copy(cfg.pos);
                spot.target.position.copy(cfg.target);
                spot.castShadow = !isMobile;
                spot.shadow.mapSize.set(1024, 1024);
                spot.shadow.bias = -0.00012;
                spot.penumbra = 0.85;
                spot.name = `ringSpot-${idx}`;
                scene.add(spot);
                scene.add(spot.target);
                ringSpotLights.push(spot);
            });

            cinemaBackLight = new THREE.SpotLight(lightingPresets[currentPreset].cinemaBackColor, lightBases.cinemaBack, 12, Math.PI / 3.2, 0.9, 1);
            cinemaBackLight.position.set(0, 1.6, -7.6);
            cinemaBackLight.target.position.set(0, 1.2, 0);
            cinemaBackLight.castShadow = false;
            cinemaBackLight.penumbra = 0.95;
            scene.add(cinemaBackLight);
            scene.add(cinemaBackLight.target);
        }

        function createVolumetricLight() {
            const geometry = new THREE.CylinderGeometry(3.6, 0.05, 6, 48, 1, true);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: new THREE.Color(0xffaa77) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPos;
                    void main() {
                        vUv = uv;
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform vec3 uColor;
                    varying vec2 vUv;
                    varying vec3 vPos;
                    float rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }
                    float noise(vec2 p){
                        vec2 ip = floor(p); vec2 u = fract(p);
                        u = u*u*(3.0-2.0*u);
                        float res = mix(mix(rand(ip), rand(ip+vec2(1.0,0.0)), u.x), mix(rand(ip+vec2(0.0,1.0)), rand(ip+vec2(1.0,1.0)), u.x), u.y);
                        return res*res;
                    }
                    void main() {
                        float radial = length(vPos.xz) / 3.6;
                        float beam = smoothstep(1.0, 0.2, radial);
                        float mist = noise(vec2(vUv.x * 22.0, vUv.y * 7.0 + uTime * 0.32));
                        float alpha = beam * (1.0 - vUv.y) * 0.16 * (0.85 + mist * 0.45);
                        alpha *= smoothstep(0.0, 0.18, vUv.y);
                        alpha *= smoothstep(1.0, 0.78, vUv.y);
                        if (alpha < 0.01) discard;
                        gl_FragColor = vec4(uColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            volumetricMesh = new THREE.Mesh(geometry, material);
            volumetricMesh.position.y = 2.5;
            scene.add(volumetricMesh);
        }

        function alignVolumetricLight() {
            if (!volumetricMesh || !keyLight || !keyLight.target) return;
            const dir = new THREE.Vector3().subVectors(keyLight.target.position, keyLight.position).normalize();
            volumetricMesh.position.copy(keyLight.position).add(dir.clone().multiplyScalar(3.0));
            volumetricMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
            const spread = THREE.MathUtils.lerp(0.9, 1.1, punchActivity);
            volumetricMesh.scale.set(spread, 1, spread);
        }

        function applyLightingPreset(name) {
            const preset = lightingPresets[name];
            if (!preset) return;

            currentPreset = name;

            applyPresetBagSettings(name);

            lightBases.key = preset.keyBase;
            lightBases.fill = preset.fillBase;
            lightBases.rim = preset.rimBase;
            lightBases.ring = preset.ringBase;
            lightBases.cinemaBack = preset.cinemaBackBase;
            lightBases.door = preset.doorBase;
            lightBases.fluorescent = preset.fluorescentBase;
            lightBases.ringSpot = preset.ringSpotBase;
            baseFogDensity = preset.fogDensity;
            volumetricBaseHue = preset.volumetricHue;
            ambientBaseIntensity = preset.ambientBase;

            if (keyLight) keyLight.color.setHex(preset.keyColor);
            if (fillLight) fillLight.color.setHex(preset.fillColor);
            if (rimLight) rimLight.color.setHex(preset.rimColor);
            if (ringLight) ringLight.color.setHex(preset.ringColor);
            if (cinemaBackLight) cinemaBackLight.color.setHex(preset.cinemaBackColor);
            if (ringSpotLights.length) ringSpotLights.forEach(s => s.color.setHex(preset.ringSpotColor));
            if (ambientLight) {
                ambientLight.color.setHex(preset.ambientSky);
                ambientLight.groundColor.setHex(preset.ambientGround);
                ambientLight.intensity = preset.ambientBase;
            }
            if (doorLight) doorLight.color.setHex(preset.doorColor);
            if (fluorescentLights.length) {
                fluorescentLights.forEach(l => l.color.setHex(preset.fluorescentColor));
            }
            if (doorGodrayMesh && doorGodrayMesh.material.uniforms && doorGodrayMesh.material.uniforms.uColor) {
                doorGodrayMesh.material.uniforms.uColor.value.setHex(preset.doorColor);
            }
            if (scene && scene.fog) {
                scene.fog.color.setHex(preset.fogColor);
                scene.fog.density = baseFogDensity;
            }
            if (scene && scene.background) {
                scene.background.setHex(preset.background);
            }

            if (cinemaBackLight) cinemaBackLight.intensity = preset.cinemaBackBase;
            if (ringSpotLights.length) {
                ringSpotLights.forEach(s => {
                    s.intensity = preset.ringSpotBase;
                });
            }
        }

        function setupPresetButton() {
            const presetBtn = document.getElementById('presetBtn');
            if (!presetBtn) return;

            const updateLabel = () => {
                presetBtn.textContent = currentPreset === 'night' ? 'üåô Noche' : 'üåá Atardecer';
            };

            presetBtn.addEventListener('click', () => {
                const nextPreset = currentPreset === 'night' ? 'sunset' : 'night';
                applyLightingPreset(nextPreset);
                updateLabel();
            });

            applyLightingPreset(currentPreset);
            updateLabel();
        }

        function triggerImpactFlash(strength = 1.0, addPunchEnergy = true) {
            const s = THREE.MathUtils.clamp(strength, 0, 1);
            if (addPunchEnergy) {
                punchActivity = Math.min(1.0, punchActivity + 0.3 * s);
            }
            impactFlashTime = IMPACT_FLASH_DURATION;
            impactFlashStrength = s;
        }

        function registerPunch(strength = 1) {
            const s = THREE.MathUtils.clamp(strength, 0, 1);
            triggerImpactFlash(s, true);
        }

        function updatePunchState(dt) {
            const decay = 0.6;
            punchActivity = Math.max(0, punchActivity - dt * decay);
            if (impactFlashTime > 0) {
                impactFlashTime -= dt;
                if (impactFlashTime < 0) impactFlashTime = 0;
            }
        }

        function getImpactFlashPhase() {
            if (impactFlashTime <= 0) return 0;
            const t = impactFlashTime / IMPACT_FLASH_DURATION;
            return t * t;
        }

        function updateLights(elapsed, dt, flashPhase) {
            if (!noiseGen) return;

            if (keyLight) {
                const low = noiseGen.noise2D(elapsed * 0.7, 0.1) * 0.5 + 0.5;
                const hi = noiseGen.noise2D(elapsed * 4.0, 1.3) * 0.5 + 0.5;
                const flick = 1.0 + ((low * 0.7 + hi * 0.3) - 0.8) * 0.4;
                const activity = 1.0 + punchActivity * 0.4;
                const flashBoost = 1.0 + flashPhase * 0.8 * (0.5 + 0.5 * impactFlashStrength);
                const intensity = lightBases.key * flick * activity * flashBoost;
                keyLight.intensity = Math.max(0.0, intensity);
            }

            if (fillLight) {
                const n = noiseGen.noise2D(elapsed * 0.9, 4.2) * 0.5 + 0.5;
                const f = 1.0 + (n - 0.5) * 0.25;
                fillLight.intensity = Math.max(0.0, lightBases.fill * f);
            }

            if (ambientLight) {
                const n = noiseGen.noise2D(elapsed * 0.35, 9.1) * 0.5 + 0.5;
                const flick = 1.0 + (n - 0.5) * 0.2;
                const flashBoost = 1.0 + flashPhase * 0.25 + punchActivity * 0.08;
                ambientLight.intensity = Math.max(0.0, ambientBaseIntensity * flick * flashBoost);
            }

            if (rimLight) {
                const n = noiseGen.noise2D(elapsed * 0.6, 8.3) * 0.5 + 0.5;
                const flashBoost = 1.0 + flashPhase * 0.4 * (0.5 + 0.5 * impactFlashStrength);
                const f = 1.0 + (n - 0.5) * 0.3 + punchActivity * 0.2;
                rimLight.intensity = Math.max(0.0, lightBases.rim * f * flashBoost);
            }

            if (ringLight) {
                const n = noiseGen.noise2D(elapsed * 1.2, 2.7) * 0.5 + 0.5;
                const f = 1.0 + (n - 0.5) * 0.25 + punchActivity * 0.3 + flashPhase * 0.6 * impactFlashStrength;
                ringLight.intensity = Math.max(0.0, lightBases.ring * f);
            }

            if (ringSpotLights.length) {
                ringSpotLights.forEach((spot, idx) => {
                    const n = noiseGen.noise2D(elapsed * 0.55 + idx * 1.7, 6.3) * 0.5 + 0.5;
                    const jitter = 1.0 + (n - 0.5) * 0.25;
                    const flashBoost = 1.0 + flashPhase * 0.55 * (0.5 + 0.5 * impactFlashStrength);
                    const activity = 1.0 + punchActivity * 0.32;
                    spot.intensity = Math.max(0.0, lightBases.ringSpot * jitter * flashBoost * activity);
                });
            }

            if (cinemaBackLight) {
                const n = noiseGen.noise2D(elapsed * 0.18, 1.7) * 0.5 + 0.5;
                const f = 1.0 + (n - 0.5) * 0.08;
                cinemaBackLight.intensity = Math.max(0.0, lightBases.cinemaBack * f);
            }

            if (doorLight) {
                const n = noiseGen.noise2D(elapsed * 0.5, 5.5) * 0.5 + 0.5;
                const f = 1.0 + (n - 0.5) * 0.3;
                doorLight.intensity = Math.max(0.0, lightBases.door * f);
            }

            if (fluorescentLights.length) {
                fluorescentLights.forEach((l, i) => {
                    const t = elapsed + i * 10.123;
                    const n = noiseGen.noise2D(t * 1.4, 2.5) * 0.5 + 0.5;
                    const fast = noiseGen.noise2D(t * 12.0, 7.8) * 0.5 + 0.5;
                    let flick = 1.0 + (n - 0.5) * 0.3 + (fast - 0.5) * 0.6;
                    if (fast > 0.9) {
                        const k = THREE.MathUtils.clamp((1.0 - fast) / 0.1, 0.0, 1.0);
                        flick *= THREE.MathUtils.lerp(0.3, 0.7, k);
                    }
                    const base = lightBases.fluorescent;
                    const intensity = Math.max(0.0, base * flick);
                    l.intensity = intensity;
                    if (fluorescentGlowCards[i]) {
                        fluorescentGlowCards[i].material.opacity = THREE.MathUtils.clamp(0.3 + (intensity / base) * 0.35, 0, 0.85);
                    }
                });
            }
        }

        function updateFog(dt, elapsed) {
            if (!scene || !scene.fog) return;
            const fogNoise = noiseGen ? (noiseGen.noise2D(elapsed * 0.05, 2.2) * 0.5 + 0.5) : 0.5;
            const targetDensity = baseFogDensity * (0.85 + fogNoise * 0.3);
            const h = THREE.MathUtils.clamp((camera.position.y - 0.5) / 4.0, 0.0, 1.0);
            const gradientDensity = THREE.MathUtils.lerp(targetDensity * 0.4, targetDensity, h);
            scene.fog.density += (gradientDensity - scene.fog.density) * 0.05;
        }

        // --- F√çSICA ---
        function initWorld() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.solver.iterations = 40;
            world.solver.tolerance = 0.0001;
            world.allowSleep = true;
        }

        function initPhysics(tex, envProps) {
            const { staticMat, ceilingMat } = envProps;

            const bagMat = new CANNON.Material('bag');
            const chainMaterial = new CANNON.Material('chain');

            const wornClothContact = {
                friction: 0.55,
                restitution: 0.08,
                contactEquationStiffness: 50000,
                contactEquationRelaxation: 4.5,
                frictionEquationRelaxation: 3.5
            };

            const metalToCloth = {
                friction: 0.48,
                restitution: 0.03,
                contactEquationStiffness: 40000,
                contactEquationRelaxation: 5.5,
                frictionEquationRelaxation: 4.5
            };

            const metalToCeiling = {
                friction: 0.42,
                restitution: 0.02,
                contactEquationStiffness: 35000,
                contactEquationRelaxation: 6.5,
                frictionEquationRelaxation: 5.5
            };

            world.addContactMaterial(new CANNON.ContactMaterial(staticMat, bagMat, wornClothContact));
            world.addContactMaterial(new CANNON.ContactMaterial(staticMat, chainMaterial, {
                friction: 0.5,
                restitution: 0.04,
                contactEquationStiffness: 60000,
                contactEquationRelaxation: 3.5,
                frictionEquationRelaxation: 2.5
            }));
            world.addContactMaterial(new CANNON.ContactMaterial(bagMat, chainMaterial, metalToCloth));
            world.addContactMaterial(new CANNON.ContactMaterial(chainMaterial, ceilingMat, metalToCeiling));
            world.addContactMaterial(new CANNON.ContactMaterial(bagMat, ceilingMat, {
                friction: 0.35,
                restitution: 0.01,
                contactEquationStiffness: 28000,
                contactEquationRelaxation: 6.5,
                frictionEquationRelaxation: 5.5
            }));

            createPunchingBag(tex.bag, { bagMaterial: bagMat, chainMaterial, ceilingMaterial: ceilingMat, staticMat });
        }

        function applyBagPhysicsToBody() {
            if (!bagBody) return;
            bagBody.mass = visualConfig.bag.mass;
            bagBody.updateMassProperties();
            bagBody.linearDamping = visualConfig.bag.linearDamping;
            bagBody.angularDamping = visualConfig.bag.angularDamping;
        }

        function createPunchingBag(tex, materials) {
            const { bagMaterial, chainMaterial, ceilingMaterial, staticMat } = materials;
            const h = 1.5, r = 0.35;
            let geo = new THREE.CylinderGeometry(r, r, h, 64, 32);
            geo = geo.toNonIndexed();
            const pos = geo.attributes.position;
            
            for(let i=0; i<pos.count; i++) {
                const v = new THREE.Vector3().fromBufferAttribute(pos, i);
                if(Math.abs(v.y) < h/2 - 0.1) {
                    const n = noiseGen.noise2D(v.x*1.5, v.y*1.5 + v.z*1.5) * visualConfig.bag.noiseFactor;
                    const bulgeY = Math.sin(v.y * 3) * 0.02;
                    let dent = 0;
                    if(v.z > 0.1 && Math.abs(v.y) < 0.3) {
                        const d = noiseGen.noise2D(v.x*4, v.y*4);
                        if(d > 0.5) dent = -0.02;
                    }
                    const scale = 1.0 + n + bulgeY + dent;
                    v.x *= scale; v.z *= scale; 
                    pos.setXYZ(i, v.x, v.y, v.z);
                }
            }
            geo.computeVertexNormals();
            
            for(let i=0; i<pos.count; i++){
                originalPositions.push(new THREE.Vector3().fromBufferAttribute(pos, i));
                vertexVelocities.push(new THREE.Vector3());
            }

            const mat = new THREE.MeshStandardMaterial({
                map: tex.c, normalMap: tex.n, roughnessMap: tex.r, 
                color: visualConfig.bag.color,
                roughness: visualConfig.bag.roughness, metalness: visualConfig.bag.metalness
            });
            bagMesh = new THREE.Mesh(geo, mat);
            bagMesh.castShadow = true;
            bagMesh.receiveShadow = true;
            scene.add(bagMesh);

            const collisionGroups = {
                static: 1,
                chain: 1 << 1,
                bag: 1 << 2
            };

            world.addContactMaterial(new CANNON.ContactMaterial(chainMaterial, chainMaterial, {
                friction: 0.38,
                restitution: 0.04,
                contactEquationStiffness: 32000,
                contactEquationRelaxation: 7,
                frictionEquationRelaxation: 6
            }));

            const ancBody = new CANNON.Body({
                mass: 0,
                position: new CANNON.Vec3(0, 4.25, 0),
                material: ceilingMaterial,
                collisionFilterGroup: collisionGroups.static,
                collisionFilterMask: collisionGroups.chain | collisionGroups.bag
            });
            ancBody.addShape(new CANNON.Sphere(0.08));
            world.addBody(ancBody);

            const chainGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.25);
            const chainMat = new THREE.MeshStandardMaterial({color:0x888888, metalness:1.0, roughness:0.2});
            let last = ancBody;
            const links = 3;
            const linkLength = 0.25;
            for(let i=0; i<links; i++){
                const b = new CANNON.Body({
                    mass: 2,
                    position: new CANNON.Vec3(0, 4.25 - (i + 1) * linkLength, 0),
                    shape: new CANNON.Sphere(0.05),
                    material: chainMaterial,
                    collisionFilterGroup: collisionGroups.chain,
                    collisionFilterMask: collisionGroups.static | collisionGroups.chain | collisionGroups.bag,
                    linearDamping: 0.35,
                    angularDamping: 0.85,
                    allowSleep: true
                });
                b.sleepSpeedLimit = 0.25;
                b.sleepTimeLimit = 0.5;
                world.addBody(b);
                const constraint = new CANNON.DistanceConstraint(last, b, linkLength, 1e5);
                constraint.collideConnected = true;
                world.addConstraint(constraint);
                const m = new THREE.Mesh(chainGeo, chainMat);
                m.castShadow = true;
                scene.add(m);
                chains.push({m, b});
                last = b;
            }

            const bagShapeOffset = new CANNON.Vec3(0, -0.1, 0);
            const bagHookOffset = new CANNON.Vec3(0, h/2 + bagShapeOffset.y - 0.05, 0);
            const bagAttachmentOffset = h/2 + bagShapeOffset.y + 0.05;

            const bagCylinderShape = new CANNON.Cylinder(r, r, h, 16);
            const bagHookShape = new CANNON.Sphere(0.12);

            bagBody = new CANNON.Body({
                mass: visualConfig.bag.mass,
                material: bagMaterial,
                position: new CANNON.Vec3(0, 2, 0),
                collisionFilterGroup: collisionGroups.bag,
                collisionFilterMask: collisionGroups.static | collisionGroups.chain,
                linearDamping: visualConfig.bag.linearDamping,
                angularDamping: visualConfig.bag.angularDamping,
                allowSleep: true
            });
            bagBody.addShape(bagCylinderShape, bagShapeOffset);
            bagBody.addShape(bagHookShape, bagHookOffset);
            bagBody.sleepSpeedLimit = 0.2;
            bagBody.sleepTimeLimit = 1.0;
            bagBody.shapeOrientations[0].setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            world.addBody(bagBody);
            bagVisualOffset.set(bagShapeOffset.x, bagShapeOffset.y, bagShapeOffset.z);
            const swingConstraint = new CANNON.ConeTwistConstraint(
                last,
                bagBody,
                {
                    pivotA: new CANNON.Vec3(0, -0.125, 0),
                    pivotB: new CANNON.Vec3(0, bagAttachmentOffset, 0),
                    axisA: new CANNON.Vec3(0, 1, 0),
                    axisB: new CANNON.Vec3(0, 1, 0),
                    angle: THREE.MathUtils.degToRad(30),
                    twistAngle: THREE.MathUtils.degToRad(15)
                }
            );
            world.addConstraint(swingConstraint);
        }

        // --- DEFORMACI√ìN ---
        function deform(point, dir, dt) {
            if(!bagMesh) return;
            const visualStep = dt || lastVisualStep || fixedVisualStep;
            const lp = bagMesh.worldToLocal(point.clone());
            const pos = bagMesh.geometry.attributes.position;
            const rot = bagMesh.quaternion.clone().invert();
            const ld = dir.clone().applyQuaternion(rot).normalize();
            
            for(let i=0; i<pos.count; i++) {
                const v = new THREE.Vector3().fromBufferAttribute(pos, i);
                const d = v.distanceTo(lp);
                if(d < 0.5) {
                    const f = (1 - d/0.5);
                    vertexVelocities[i].add(ld.clone().multiplyScalar(f * visualConfig.bag.deformationAmount * visualStep));
                } else if(d < 0.9) {
                    const t = (d-0.5)/(0.4);
                    const f = Math.sin(t*Math.PI) * visualConfig.bag.bulgeAmount * 0.3;
                    vertexVelocities[i].add(ld.clone().negate().multiplyScalar(f * visualStep));
                }
            }
        }

        function updateMesh(dt) {
            if(!bagMesh) return;
            const visualStep = dt || lastVisualStep || fixedVisualStep;
            const pos = bagMesh.geometry.attributes.position;
            let moved = false;

            for(let i=0; i<pos.count; i++) {
                tempV.fromBufferAttribute(pos, i);
                const o = originalPositions[i];
                const vel = vertexVelocities[i];

                tempDisp.subVectors(tempV, o);
                const displacementLenSq = tempDisp.lengthSq();

                const force = tempDisp.multiplyScalar(-visualConfig.bag.elasticity * visualStep);
                vel.add(force);

                const baseStep = Math.max(fixedVisualStep, 0.0001);
                const dampingFactor = Math.pow(visualConfig.bag.damping, visualStep / baseStep);
                vel.multiplyScalar(dampingFactor);
                vel.clampLength(0, visualConfig.bag.maxVertexSpeed);

                if(vel.lengthSq()>0.00001 || displacementLenSq>0.00001) {
                    tempV.addScaledVector(vel, visualStep);
                    pos.setXYZ(i, tempV.x, tempV.y, tempV.z);
                    moved = true;
                }
            }
            if(moved) {
                pos.needsUpdate = true;
                bagMesh.geometry.computeVertexNormals();
            }
        }

        // --- AUDIO ---
        function initAudioContext() {
            if (audioInitialized) return;
            audioInitialized = true;

            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            masterGain = audioContext.createGain();
            masterGain.gain.value = audioConfig.volume;
            setupReverb();
            masterGain.connect(audioContext.destination);
            loadAllAudio();
        }

        function createImpulseResponse(context, decaySeconds) {
            const decay = Math.max(0.1, decaySeconds || 1);
            const sampleRate = context.sampleRate;
            const length = Math.floor(sampleRate * decay);
            const impulse = context.createBuffer(2, length, sampleRate);

            for (let channel = 0; channel < impulse.numberOfChannels; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    const t = i / length;
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, 2.5);
                }
            }

            return impulse;
        }

        function setupReverb() {
            if (!audioContext || !masterGain || !audioConfig.reverb?.enabled) return;

            reverbNode = audioContext.createConvolver();
            reverbWetGain = audioContext.createGain();
            reverbDryGain = audioContext.createGain();

            reverbNode.buffer = createImpulseResponse(audioContext, audioConfig.reverb.decay);

            updateReverbMix(audioConfig.reverb.mix);

            reverbNode.connect(reverbWetGain);
            reverbWetGain.connect(masterGain);
            reverbDryGain.connect(masterGain);
        }

        function updateReverbMix(mix) {
            if (!reverbWetGain || !reverbDryGain) return;
            const clamped = Math.min(1, Math.max(0, mix ?? 0));
            reverbWetGain.gain.value = clamped;
            reverbDryGain.gain.value = 1 - clamped;
        }

        function updateReverbDecay(decaySeconds) {
            if (!audioContext || !reverbNode) return;
            reverbNode.buffer = createImpulseResponse(audioContext, decaySeconds);
        }

        function setReverbDecay(decaySeconds) {
            if (!audioConfig.reverb) return;
            const decay = Math.max(0.1, decaySeconds);
            audioConfig.reverb.decay = decay;
            updateReverbDecay(decay);
        }

        function setReverbMix(mix) {
            if (!audioConfig.reverb) return;
            const clamped = Math.min(1, Math.max(0, mix));
            audioConfig.reverb.mix = clamped;
            updateReverbMix(clamped);
        }

        function connectToAudioGraph(gainNode) {
            if (!masterGain) return;
            if (audioConfig.reverb?.enabled && reverbNode && reverbWetGain && reverbDryGain) {
                gainNode.connect(reverbNode);
                gainNode.connect(reverbDryGain);
            } else {
                gainNode.connect(masterGain);
            }
        }

        window.gymReverbSettings = {
            setDecay: setReverbDecay,
            setMix: setReverbMix,
            getSettings: () => ({ ...audioConfig.reverb })
        };

        async function loadAudioBuffer(url) {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            return audioContext.decodeAudioData(arrayBuffer);
        }

        async function loadAllAudio() {
            const entries = [];
            audioFiles.impacts.forEach((file) => entries.push(['impact:' + file, file]));
            entries.push(['heavyImpact', audioFiles.heavyImpact]);
            entries.push(['bell', audioFiles.bell]);
            entries.push(['countdown', audioFiles.countdown]);
            entries.push(['breath', audioFiles.breath]);
            entries.push(['crowd', audioFiles.crowd]);
            audioFiles.shouts.forEach((file, idx) => entries.push([`shout:${idx}`, file]));

            for (const [key, file] of entries) {
                try {
                    const buffer = await loadAudioBuffer(file);
                    audioBuffers.set(key, buffer);
                } catch (err) {
                    console.warn('No se pudo cargar el audio', file, err);
                }
            }
        }

        function playBuffer(name, { volume = 1, playbackRate = 1, slices = 1 } = {}) {
            if (!audioConfig.enabled || !audioContext) return;
            const buffer = audioBuffers.get(name);
            if (!buffer) return;

            if (audioContext.state === 'suspended') audioContext.resume();

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.playbackRate.value = playbackRate;

            const gainNode = audioContext.createGain();
            gainNode.gain.value = volume;

            source.connect(gainNode);
            connectToAudioGraph(gainNode);

            const totalSlices = Math.max(1, Math.floor(slices));
            const segmentDuration = buffer.duration / totalSlices;
            const sliceIndex = Math.floor(Math.random() * totalSlices);
            const offset = sliceIndex * segmentDuration;
            const duration = Math.max(0.01, segmentDuration);

            updateDebugSound(name);
            source.start(0, offset, duration);
        }

        function playImpactSound(strength = 1) {
            const vol = THREE.MathUtils.clamp(strength / 90, 0.2, 1.1);
            const rate = 0.9 + Math.random() * 0.2;
            const impactFiles = audioFiles.impacts
                .map((file) => ({ key: 'impact:' + file, slices: 4 }))
                .filter((entry) => audioBuffers.has(entry.key));
            if (impactFiles.length === 0) return;
            const pick = impactFiles[Math.floor(Math.random() * impactFiles.length)];
            playBuffer(pick.key, { volume: vol, playbackRate: rate, slices: pick.slices });
        }

        function playHeavyImpactSound(strength = 1) {
            const vol = THREE.MathUtils.clamp(strength / 60, 0.25, 0.7);
            playBuffer('heavyImpact', { volume: vol });
        }

        function playBell() { playBuffer('bell', { volume: 0.9 }); }
        function playCountdown() { playBuffer('countdown', { volume: 0.85 }); }
        function playBreath() { playBuffer('breath', { volume: 0.35 + Math.random() * 0.15 }); }
        function playCrowd() { playBuffer('crowd', { volume: 0.6 }); }
        function playShout() {
            const shoutKeys = audioFiles.shouts
                .map((_, idx) => `shout:${idx}`)
                .filter((key) => audioBuffers.has(key));
            if (shoutKeys.length === 0) return;
            const pick = shoutKeys[Math.floor(Math.random() * shoutKeys.length)];
            playBuffer(pick, { volume: 0.65 + Math.random() * 0.2 });
        }

        function setupMuteButton() {
            const muteBtn = document.getElementById('muteBtn');
            let muted = false;

            muteBtn.addEventListener('click', () => {
                muted = !muted;
                audioConfig.enabled = !muted;
                if (masterGain) {
                    masterGain.gain.value = muted ? 0 : audioConfig.volume;
                }
                muteBtn.textContent = muted ? 'üîá OFF' : 'üîä ON';
            });
        }

        function applyViewMode() {
            if (!controls || !camera) return;

            if (thirdPersonActive) {
                camera.position.copy(baseTarget).add(thirdPersonCameraOffset);
                targetBase.copy(baseTarget).add(thirdPersonTargetOffset);
            } else {
                camera.position.copy(defaultCameraPosition);
                targetBase.copy(baseTarget);
            }

            controls.target.copy(targetBase);
        }

        function setupViewButton() {
            const viewBtn = document.getElementById('viewBtn');
            if (!viewBtn) return;

            applyViewMode();

            viewBtn.addEventListener('click', () => {
                thirdPersonActive = !thirdPersonActive;
                applyViewMode();
                viewBtn.textContent = thirdPersonActive ? 'üëÅÔ∏è 3ra Persona' : 'üéØ POV';
            });
        }

        function setupUiFxEvents() {
            const ids = ['presetBtn', 'muteBtn', 'viewBtn', 'webcamBtn'];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                const handler = (evt) => {
                    spawnUiSpark(evt.clientX, evt.clientY, evt.type === 'click' ? 0.7 : 0.4);
                    triggerImpactFlash(evt.type === 'click' ? 0.45 : 0.25, false);
                };
                el.addEventListener('mouseenter', handler);
                el.addEventListener('click', handler);
            });
        }

        // --- INTERACCI√ìN (click sobre saco: solo si DEBUG_MOUSE_PUNCH = true) ---
        function onPointerDown(e) {
            if (!DEBUG_MOUSE_PUNCH) return;

            mouse.x = (e.clientX/window.innerWidth)*2-1;
            mouse.y = -(e.clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);
            
            if(!bagMesh || !bagBody) return;

            const hits = raycaster.intersectObject(bagMesh);
            if(hits.length>0) {
                initAudioContext();

                const hit = hits[0];
                const dir = hit.point.clone().sub(camera.position).normalize();
                const rightSettings = punchConfig.right;
                const targetImpulse = visualConfig.bag.punchForce;
                const syntheticSpeed = targetImpulse / (rightSettings.effectiveMass * rightSettings.contactArea);
                const handVelocity = dir.clone().multiplyScalar(syntheticSpeed);

                    const punchData = computePunchImpulse(handVelocity, hit.point, false);
                    if (punchData) {
                        bagBody.applyImpulse(punchData.impulse, punchData.contactPoint);
                        const normalDir = new THREE.Vector3(punchData.normal.x, punchData.normal.y, punchData.normal.z);
                        deform(hit.point, normalDir, lastVisualStep);
                        const impactForce = Math.max(targetImpulse, punchData.impulseMagnitude);
                        playImpactSound(impactForce);

                    registerPunch(Math.min(1, punchData.normalSpeed / 6));

                    shakeTime = shakeDuration;
                    shakeStrength = 0.03 * (impactForce / visualConfig.bag.punchForce);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
            resizeCanvasToVideo();
        }

        function animate(time) {
            requestAnimationFrame(animate);
            const dtVis = Math.min(clock.getDelta(), 0.1);
            const elapsed = clock.getElapsedTime();
            const visualStep = fixedVisualStep || dtVis;
            lastVisualStep = visualStep;

            if (world) {
                if (lastTime !== undefined) {
                    const frameDelta = Math.min(maxDelta, (time - lastTime) / 1000);
                    accumulator += frameDelta;

                    while (accumulator >= fixedTimeStep) {
                        world.step(fixedTimeStep);
                        accumulator -= fixedTimeStep;
                    }

                    accumulator = Math.min(accumulator, fixedTimeStep);
                }

                lastTime = time;
            }

            if (mixer) {
                mixer.update(dtVis);
                keepTysonFeetOnFloor();
                if (animationDirector) animationDirector.update();
            }

            if (bagMesh && bagBody) {
                bagMesh.position.copy(bagBody.position);
                if (bagVisualOffset.lengthSq() > 0) {
                    tempV.copy(bagVisualOffset).applyQuaternion(bagBody.quaternion);
                    bagMesh.position.add(tempV);
                }
                bagMesh.quaternion.copy(bagBody.quaternion);
            }
            chains.forEach(o => {
                o.m.position.copy(o.b.position);
                o.m.quaternion.copy(o.b.quaternion);
            });

            const distanceToBag = enforceTysonDistanceToBag();
            orientTysonTowardBag();
            if (animationDirector) animationDirector.cutWalkIfTooClose(distanceToBag);

            if (fanMesh) fanMesh.rotation.y -= 2.0 * dtVis;

            if (clockHandSec) {
                const d = new Date();
                const s = d.getSeconds() + d.getMilliseconds() / 1000;
                const m = d.getMinutes();
                const h = d.getHours();
                clockHandSec.rotation.z = -s * (Math.PI / 30);
                clockHandMin.rotation.z = -m * (Math.PI / 30);
                clockHandHour.rotation.z = -(h % 12 + m / 60) * (Math.PI / 6);
            }

            updatePunchState(dtVis);
            const flashPhase = getImpactFlashPhase();
            updateLights(elapsed, dtVis, flashPhase);

            if (volumetricMesh) {
                alignVolumetricLight();
                volumetricMesh.material.uniforms.uTime.value = elapsed;
                const hueNoise = noiseGen ? (noiseGen.noise2D(elapsed * 0.1, 9.1) * 0.5 + 0.5) * 0.015 : 0.0;
                const hue = (volumetricBaseHue || 0.08) + hueNoise;
                const l = 0.7 + Math.sin(elapsed) * 0.05 + punchActivity * 0.08;
                volumetricMesh.material.uniforms.uColor.value.setHSL(hue, 0.6, l);
            }

            if (doorGodrayMesh) {
                doorGodrayMesh.material.uniforms.uTime.value = elapsed;
            }

            if (DUST_ENABLED) {
                updateDust(elapsed, dtVis);
            }
            updateUiSparks(dtVis);

            if (bagMesh && bokehPass && bokehPass.materialBokeh && bokehPass.materialBokeh.uniforms.focus) {
                const d = camera.position.distanceTo(bagMesh.position);
                bokehPass.materialBokeh.uniforms.focus.value = d;
            }

            const headAnchor = getHeadBone();
            const usingHeadAnchor = !thirdPersonActive && headAnchor;

            if (usingHeadAnchor) {
                headAnchor.getWorldPosition(tmpVecA);
                headAnchor.getWorldQuaternion(tmpQuatA);

                targetBase.copy(tmpVecA).add(tmpDir.copy(povTargetOffset).applyQuaternion(tmpQuatA));
                camera.position.copy(tmpVecA).add(tmpVecB.copy(povCameraOffset).applyQuaternion(tmpQuatA));
            } else if (!thirdPersonActive) {
                camera.position.copy(defaultCameraPosition);
                targetBase.copy(baseTarget);
            }

            const bobEnabled = thirdPersonActive || !usingHeadAnchor;
            if (bobEnabled) {
                const bobAmount = 0.03;
                const swayAmount = 0.04;
                const bobY = Math.sin(elapsed * 1.8) * bobAmount;
                const swayX = Math.sin(elapsed * 1.2) * swayAmount;
                tmpVecB.set(
                    targetBase.x + swayX,
                    targetBase.y + bobY,
                    targetBase.z
                );
                controls.target.copy(tmpVecB);
            } else {
                controls.target.copy(targetBase);
            }

            controls.update();

            if (shakeTime > 0) {
                shakeTime -= dtVis;
                camera.position.sub(shakeOffset);
                const s = shakeStrength * (shakeTime / shakeDuration);
                shakeOffset.set(
                    (Math.random() - 0.5) * s,
                    (Math.random() - 0.5) * s,
                    (Math.random() - 0.5) * s
                );
                camera.position.add(shakeOffset);
            } else if (!shakeOffset.equals(new THREE.Vector3(0, 0, 0))) {
                camera.position.sub(shakeOffset);
                shakeOffset.set(0, 0, 0);
            }

            updateMesh(visualStep);
            updateFog(dtVis, elapsed);

            // Golpes desde manos del personaje
            updatePosePunch(dtVis);

            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>







